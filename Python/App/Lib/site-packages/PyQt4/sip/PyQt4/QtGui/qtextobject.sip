// qtextobject.sip generated by MetaSIP on Sun Apr 21 13:05:21 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QTextObject : QObject
{
%TypeHeaderCode
#include <qtextobject.h>
%End

protected:
    explicit QTextObject(QTextDocument *doc);
    virtual ~QTextObject();
    void setFormat(const QTextFormat &format);

public:
    QTextFormat format() const;
    int formatIndex() const;
    QTextDocument *document() const;
    int objectIndex() const;

private:
    QTextObject(const QTextObject &);
};

class QTextBlockGroup : QTextObject
{
%TypeHeaderCode
#include <qtextobject.h>
%End

protected:
    explicit QTextBlockGroup(QTextDocument *doc);
    virtual ~QTextBlockGroup();
    virtual void blockInserted(const QTextBlock &block);
    virtual void blockRemoved(const QTextBlock &block);
    virtual void blockFormatChanged(const QTextBlock &block);
    QList<QTextBlock> blockList() const;

private:
    QTextBlockGroup(const QTextBlockGroup &);
};

class QTextFrame : QTextObject
{
%TypeHeaderCode
#include <qtextobject.h>
%End

public:
    explicit QTextFrame(QTextDocument *doc);
    virtual ~QTextFrame();
    QTextFrameFormat frameFormat() const;
    QTextCursor firstCursorPosition() const;
    QTextCursor lastCursorPosition() const;
    int firstPosition() const;
    int lastPosition() const;
    QList<QTextFrame*> childFrames() const;
    QTextFrame *parentFrame() const;

    class iterator
    {
%TypeHeaderCode
#include <qtextobject.h>
%End

    public:
        iterator();
        iterator(const QTextFrame::iterator &o);
        QTextFrame *parentFrame() const;
        QTextFrame *currentFrame() const;
        QTextBlock currentBlock() const;
        bool atEnd() const;
        bool operator==(const QTextFrame::iterator &o) const;
        bool operator!=(const QTextFrame::iterator &o) const;
        QTextFrame::iterator &operator+=(int);
%MethodCode
            if (a0 > 0)
                while (a0--)
                    (*sipCpp)++;
            else if (a0 < 0)
                while (a0++)
                    (*sipCpp)--;
%End

        QTextFrame::iterator &operator-=(int);
%MethodCode
            if (a0 > 0)
                while (a0--)
                    (*sipCpp)--;
            else if (a0 < 0)
                while (a0++)
                    (*sipCpp)++;
%End
    };

    typedef QTextFrame::iterator Iterator;
    QTextFrame::iterator begin() const;
    QTextFrame::iterator end() const;

private:
    QTextFrame(const QTextFrame &);

public:
    void setFrameFormat(const QTextFrameFormat &aformat);
};

class QTextBlock /Supertype=sip.wrapper/
{
%TypeHeaderCode
#include <qtextobject.h>
%End

public:
    QTextBlock();
    QTextBlock(const QTextBlock &o);
    bool isValid() const;
    bool operator==(const QTextBlock &o) const;
    bool operator!=(const QTextBlock &o) const;
    bool operator<(const QTextBlock &o) const;
    int position() const;
    int length() const;
    bool contains(int position) const;
    QTextLayout *layout() const;
    QTextBlockFormat blockFormat() const;
    int blockFormatIndex() const;
    QTextCharFormat charFormat() const;
    int charFormatIndex() const;
    QString text() const;
    const QTextDocument *document() const;
    QTextList *textList() const;

    class iterator
    {
%TypeHeaderCode
#include <qtextobject.h>
%End

    public:
        iterator();
        iterator(const QTextBlock::iterator &o);
        QTextFragment fragment() const;
        bool atEnd() const;
        bool operator==(const QTextBlock::iterator &o) const;
        bool operator!=(const QTextBlock::iterator &o) const;
        QTextBlock::iterator &operator+=(int);
%MethodCode
            if (a0 > 0)
                while (a0--)
                    (*sipCpp)++;
            else if (a0 < 0)
                while (a0++)
                    (*sipCpp)--;
%End

        QTextBlock::iterator &operator-=(int);
%MethodCode
            if (a0 > 0)
                while (a0--)
                    (*sipCpp)--;
            else if (a0 < 0)
                while (a0++)
                    (*sipCpp)++;
%End
    };

    typedef QTextBlock::iterator Iterator;
    QTextBlock::iterator begin() const;
    QTextBlock::iterator end() const;
    QTextBlock next() const;
    QTextBlock previous() const;
    QTextBlockUserData *userData() const;
    void setUserData(QTextBlockUserData *data /GetWrapper/);
%MethodCode
        // Ownership of the user data is with the document not the text block.
        const QTextDocument *td = sipCpp->document();
        
        if (td)
        {
            PyObject *td_obj = sipConvertFromType(const_cast<QTextDocument *>(td),
                    sipType_QTextDocument, 0);
        
            if (td_obj)
            {
                sipTransferTo(a0Wrapper, td_obj);
                Py_DECREF(td_obj);
            }
        }
        
        sipCpp->setUserData(a0);
%End

    int userState() const;
    void setUserState(int state);
%If (Qt_4_4_0 -)
    void clearLayout();
%End
%If (Qt_4_4_0 -)
    int revision() const;
%End
%If (Qt_4_4_0 -)
    void setRevision(int rev);
%End
%If (Qt_4_4_0 -)
    bool isVisible() const;
%End
%If (Qt_4_4_0 -)
    void setVisible(bool visible);
%End
%If (Qt_4_4_0 -)
    int blockNumber() const;
%End
%If (Qt_4_5_0 -)
    int firstLineNumber() const;
%End
%If (Qt_4_5_0 -)
    void setLineCount(int count);
%End
%If (Qt_4_5_0 -)
    int lineCount() const;
%End
%If (Qt_4_7_0 -)
    Qt::LayoutDirection textDirection() const;
%End
};

class QTextFragment
{
%TypeHeaderCode
#include <qtextobject.h>
%End

public:
    QTextFragment();
    QTextFragment(const QTextFragment &o);
    bool isValid() const;
    bool operator==(const QTextFragment &o) const;
    bool operator!=(const QTextFragment &o) const;
    bool operator<(const QTextFragment &o) const;
    int position() const;
    int length() const;
    bool contains(int position) const;
    QTextCharFormat charFormat() const;
    int charFormatIndex() const;
    QString text() const;
%If (Qt_5_0_0 -)
    QList<QGlyphRun> glyphRuns(int from = -1, int length = -1) const;
%End
%If (Qt_4_8_0 - Qt_5_0_0)
%If (PyQt_RawFont)
    QList<QGlyphRun> glyphRuns() const;
%End
%End
};

class QTextBlockUserData /Supertype=sip.wrapper/
{
%TypeHeaderCode
#include <qtextobject.h>
%End

public:
    virtual ~QTextBlockUserData();
};
