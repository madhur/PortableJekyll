// qbrush.sip generated by MetaSIP on Sun Apr 21 13:05:20 2013
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qbrush.h>
%End

class QBrush
{
%TypeHeaderCode
#include <qbrush.h>
%End

%ConvertToTypeCode
// SIP doesn't support automatic type convertors so we explicitly allow a
// QColor or a QGradient to be used whenever a QBrush is expected.  Note that
// SIP must process QColor before QBrush so that the former's QVariant cast
// operator is applied before the latter's.

if (sipIsErr == NULL)
    return (sipCanConvertToType(sipPy, sipType_QBrush, SIP_NO_CONVERTORS) ||
            sipCanConvertToType(sipPy, sipType_QColor, 0) ||
            sipCanConvertToType(sipPy, sipType_QGradient, 0));

if (sipCanConvertToType(sipPy, sipType_QBrush, SIP_NO_CONVERTORS))
{
    *sipCppPtr = reinterpret_cast<QBrush *>(sipConvertToType(sipPy, sipType_QBrush, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

    return 0;
}

int state;

if (sipCanConvertToType(sipPy, sipType_QColor, 0))
{
    QColor *c = reinterpret_cast<QColor *>(sipConvertToType(sipPy, sipType_QColor, 0, 0, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(c, sipType_QColor, state);
        return 0;
    }

    *sipCppPtr = new QBrush(*c);

    sipReleaseType(c, sipType_QColor, state);

    return sipGetState(sipTransferObj);
}

QGradient *g = reinterpret_cast<QGradient *>(sipConvertToType(sipPy, sipType_QGradient, 0, 0, &state, sipIsErr));

if (*sipIsErr)
{
    sipReleaseType(g, sipType_QGradient, state);
    return 0;
}

*sipCppPtr = new QBrush(*g);

sipReleaseType(g, sipType_QGradient, state);

return sipGetState(sipTransferObj);
%End

public:
    QBrush();
    QBrush(Qt::BrushStyle bs);
    QBrush(const QColor &color, Qt::BrushStyle style = Qt::SolidPattern);
    QBrush(Qt::GlobalColor color, Qt::BrushStyle style = Qt::SolidPattern);
    QBrush(const QColor &color, const QPixmap &pixmap);
    QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
    QBrush(const QPixmap &pixmap);
%If (Qt_4_2_0 -)
    QBrush(const QImage &image);
%End
    QBrush(const QGradient &gradient);
    QBrush(const QBrush &brush);
    QBrush(const QVariant &variant) /NoDerived/;
%MethodCode
        #if QT_VERSION >= 0x050000
        sipCpp = new QBrush(a0->value<QBrush>());
        #else
        sipCpp = new QBrush(qVariantValue<QBrush>(*a0));
        #endif
%End

    ~QBrush();
    void setStyle(Qt::BrushStyle);
    QPixmap texture() const;
    void setTexture(const QPixmap &pixmap);
    void setColor(const QColor &color);
    const QGradient *gradient() const;
    bool isOpaque() const;
    bool operator==(const QBrush &b) const;
    bool operator!=(const QBrush &b) const;
    void setColor(Qt::GlobalColor acolor);
    Qt::BrushStyle style() const;
    const QColor &color() const;
%If (Qt_4_2_0 -)
    void setMatrix(const QMatrix &mat);
%End
%If (Qt_4_2_0 -)
    const QMatrix &matrix() const;
%End
%If (Qt_4_2_0 -)
    void setTextureImage(const QImage &image);
%End
%If (Qt_4_2_0 -)
    QImage textureImage() const;
%End
%If (Qt_4_3_0 -)
    void setTransform(const QTransform &);
%End
%If (Qt_4_3_0 -)
    QTransform transform() const;
%End
%If (Qt_4_8_0 -)
    void swap(QBrush &other);
%End
};

QDataStream &operator>>(QDataStream &, QBrush & /Constrained/);
QDataStream &operator<<(QDataStream &, const QBrush & /Constrained/);
%If (Qt_5_0_0 -)
typedef QVector<QPair<double, QColor>> QGradientStops;
%End
%If (- Qt_5_0_0)
typedef QVector<QPair<qreal, QColor>> QGradientStops;
%End

class QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
%If (Qt_4_4_0 -)

    enum CoordinateMode
    {
        LogicalMode,
        StretchToDeviceMode,
        ObjectBoundingMode,
    };

%End

    enum Type
    {
        LinearGradient,
        RadialGradient,
        ConicalGradient,
        NoGradient,
    };

    enum Spread
    {
        PadSpread,
        ReflectSpread,
        RepeatSpread,
    };

    QGradient();
    QGradient::Type type() const;
    QGradient::Spread spread() const;
    void setColorAt(qreal pos, const QColor &color);
    void setStops(const QGradientStops &stops);
    QGradientStops stops() const;
    bool operator==(const QGradient &gradient) const;
%If (Qt_4_2_0 -)
    bool operator!=(const QGradient &other) const;
%End
    void setSpread(QGradient::Spread aspread);
%If (Qt_4_4_0 -)
    QGradient::CoordinateMode coordinateMode() const;
%End
%If (Qt_4_4_0 -)
    void setCoordinateMode(QGradient::CoordinateMode mode);
%End
};

class QLinearGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
%If (Qt_4_2_0 -)
    QLinearGradient();
%End
    QLinearGradient(const QPointF &start, const QPointF &finalStop);
    QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);
    QPointF start() const;
    QPointF finalStop() const;
%If (Qt_4_2_0 -)
    void setStart(const QPointF &start);
%End
%If (Qt_4_2_0 -)
    void setStart(qreal x, qreal y);
%End
%If (Qt_4_2_0 -)
    void setFinalStop(const QPointF &stop);
%End
%If (Qt_4_2_0 -)
    void setFinalStop(qreal x, qreal y);
%End
};

class QRadialGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
%If (Qt_4_2_0 -)
    QRadialGradient();
%End
%If (Qt_4_2_0 -)
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint);
%End
%If (Qt_4_8_0 -)
    QRadialGradient(const QPointF &center, qreal centerRadius, const QPointF &focalPoint, qreal focalRadius);
%End
%If (Qt_4_2_0 -)
    QRadialGradient(const QPointF &center, qreal radius);
%End
%If (- Qt_4_2_0)
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint = QPointF());
%End
%If (Qt_4_2_0 -)
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx, qreal fy);
%End
%If (Qt_4_8_0 -)
    QRadialGradient(qreal cx, qreal cy, qreal centerRadius, qreal fx, qreal fy, qreal focalRadius);
%End
%If (Qt_4_2_0 -)
    QRadialGradient(qreal cx, qreal cy, qreal radius);
%End
%If (- Qt_4_2_0)
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx = 0, qreal fy = 0);
%End
    QPointF center() const;
    QPointF focalPoint() const;
    qreal radius() const;
%If (Qt_4_2_0 -)
    void setCenter(const QPointF &center);
%End
%If (Qt_4_2_0 -)
    void setCenter(qreal x, qreal y);
%End
%If (Qt_4_2_0 -)
    void setFocalPoint(const QPointF &focalPoint);
%End
%If (Qt_4_2_0 -)
    void setFocalPoint(qreal x, qreal y);
%End
%If (Qt_4_2_0 -)
    void setRadius(qreal radius);
%End
%If (Qt_4_8_0 -)
    qreal centerRadius() const;
%End
%If (Qt_4_8_0 -)
    void setCenterRadius(qreal radius);
%End
%If (Qt_4_8_0 -)
    qreal focalRadius() const;
%End
%If (Qt_4_8_0 -)
    void setFocalRadius(qreal radius);
%End
};

class QConicalGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
%If (Qt_4_2_0 -)
    QConicalGradient();
%End
    QConicalGradient(const QPointF &center, qreal startAngle);
    QConicalGradient(qreal cx, qreal cy, qreal startAngle);
    QPointF center() const;
    qreal angle() const;
%If (Qt_4_2_0 -)
    void setCenter(const QPointF &center);
%End
%If (Qt_4_2_0 -)
    void setCenter(qreal x, qreal y);
%End
%If (Qt_4_2_0 -)
    void setAngle(qreal angle);
%End
};

%If (Qt_4_3_0 -)
void qSwap(QBrush &value1, QBrush &value2);
%End
