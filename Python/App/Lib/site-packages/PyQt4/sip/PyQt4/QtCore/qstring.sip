// qstring.sip generated by MetaSIP on Sun Apr 21 13:05:19 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qstring.h>
%End

// class QString /AllowNone,API=QString:2 -,DocType="str"/
%MappedType QString /AllowNone,API=QString:2 -,DocType="str"/
{
%TypeHeaderCode
#include <qstring.h>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
#if PY_MAJOR_VERSION < 3
    return (sipPy == Py_None || PyString_Check(sipPy) || PyUnicode_Check(sipPy));
#else
    return (sipPy == Py_None || PyUnicode_Check(sipPy));
#endif

if (sipPy == Py_None)
{
    // None is the only way to create a null (as opposed to empty) QString.
    *sipCppPtr = new QString();

    return sipGetState(sipTransferObj);
}

#if PY_MAJOR_VERSION < 3
if (PyString_Check(sipPy))
{
    *sipCppPtr = new QString(PyString_AS_STRING(sipPy));

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = new QString(qpycore_PyObject_AsQString(sipPy));

return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
    return qpycore_PyObject_FromQString(*sipCpp);
%End
};

class QString /API=QString: - 2/
{
%TypeHeaderCode
#include <qstring.h>
%End

%TypeCode
// This is needed by __hash__().
#include <qhash.h>


// This is needed by the %BIGetCharBufferCode.
#include <qtextcodec.h>
%End

%ConvertToTypeCode
// See the comments for the QByteArray %ConvertToTypeCode for an explanation
// of the conversions that are done below.

if (sipIsErr == NULL)
    return (PyUnicode_Check(sipPy) ||
#if PY_MAJOR_VERSION < 3
            PyString_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QLatin1String, 0) ||
            sipCanConvertToType(sipPy, sipType_QChar, 0) ||
            sipCanConvertToType(sipPy, sipType_QString, SIP_NO_CONVERTORS));

if (PyUnicode_Check(sipPy))
{
    *sipCppPtr = new QString(qpycore_PyObject_AsQString(sipPy));

    return sipGetState(sipTransferObj);
}

#if PY_MAJOR_VERSION < 3
if (PyString_Check(sipPy))
{
    *sipCppPtr = new QString(PyString_AS_STRING(sipPy));

    return sipGetState(sipTransferObj);
}
#endif

if (sipCanConvertToType(sipPy, sipType_QLatin1String, 0))
{
    int state;
    QLatin1String *q = reinterpret_cast<QLatin1String *>(sipConvertToType(sipPy,
            sipType_QLatin1String, 0, 0, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(q, sipType_QLatin1String, state);
        return 0;
    }

    *sipCppPtr = new QString(*q);

    sipReleaseType(q, sipType_QLatin1String, state);

    return sipGetState(sipTransferObj);
}

if (sipCanConvertToType(sipPy, sipType_QChar, 0))
{
    int state;
    QChar *q = reinterpret_cast<QChar *>(sipConvertToType(sipPy,
            sipType_QChar, 0, 0, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(q, sipType_QChar, state);
        return 0;
    }

    *sipCppPtr = new QString(*q);

    sipReleaseType(q, sipType_QChar, state);

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QString *>(sipConvertToType(sipPy,
        sipType_QString, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%BIGetReadBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QString segment");
        sipRes = -1;
    }
    else
    {
        // To keep things easy we convert to a Python Unicode object, keep a
        // reference to it and expose its contents.
        PyObject *uobj = qpycore_PyObject_FromQString(*sipCpp);
    
        if (uobj)
        {
            Py_XDECREF(((sipSimpleWrapper *)sipSelf)->user);
            ((sipSimpleWrapper *)sipSelf)->user = uobj;
    
            *sipPtrPtr = (void *)PyUnicode_AS_UNICODE(uobj);
            sipRes = PyUnicode_GET_DATA_SIZE(uobj);
        }
        else
        {
            sipRes = -1;
        }
    }
%End

%BIGetSegCountCode
    if (sipLenPtr)
        *sipLenPtr = sipCpp->size() * sizeof (Py_UNICODE);
    
    sipRes = 1;
%End

%BIGetCharBufferCode
    if (sipSegment != 0)
    {
        PyErr_SetString(PyExc_SystemError, "accessing non-existent QString segment");
        sipRes = -1;
    }
    else
    {
        static QTextCodec *codec = 0;
        static bool check_codec = true;
    
        // For the first time only, try and find a Qt codec that corresponds to the
        // default Python codec.  If one wasn't found then fall back to ASCII
        // (which is actually the codec returned by QTextCodec::codecForCStrings()).
        if (check_codec)
        {
            codec = QTextCodec::codecForName(PyUnicode_GetDefaultEncoding());
            check_codec = false;
        }
    
        QByteArray enc;
    
        if (codec)
            enc = codec->fromUnicode(*sipCpp);
        else
    #if QT_VERSION >= 0x050000
            enc = sipCpp->toLatin1();
    #else
            enc = sipCpp->toAscii();
    #endif
        
        // A Python string is the most convenient method to save the encoded
        // version on the heap.
        PyObject *encobj = ((sipSimpleWrapper *)sipSelf)->user;
    
        Py_XDECREF(encobj);
    
        if ((encobj = PyString_FromStringAndSize(enc.data(), enc.size())) != NULL)
        {
            *sipPtrPtr = (void *)PyString_AS_STRING(encobj);
            sipRes = PyString_GET_SIZE(encobj);
    
            ((sipSimpleWrapper *)sipSelf)->user = encobj;
        }
        else
            sipRes = -1;
    }
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"(O)", qpycore_PyObject_FromQString(*sipCpp));
%End

public:
    QString();
    QString(int size, QChar c);
    QString(const QString &s);
    QString(const QByteArray &a);
    ~QString();
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        PyObject *uni = qpycore_PyObject_FromQString(*sipCpp);
        
        if (uni)
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QString(%R)", uni);
        #else
            sipRes = PyString_FromString("PyQt4.QtCore.QString(");
            PyString_ConcatAndDel(&sipRes, PyObject_Repr(uni));
            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
        
            Py_DECREF(uni);
        }
%End

    int size() const;
    int count() const /__len__/;
    void resize(int size);
    QString &fill(QChar ch, int size = -1);
    void truncate(int pos);
    void chop(int n);
    void squeeze();
%If (Qt_5_0_0 -)
    QString arg(int a /Constrained/, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const;
%End
%If (- Qt_5_0_0)
    QString arg(int a /Constrained/, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
%End
%If (Qt_5_0_0 -)
    QString arg(double a /Constrained/, int fieldWidth = 0, char format = 'g', int precision = -1, QChar fillChar = QLatin1Char(' ')) const;
%End
%If (- Qt_5_0_0)
    QString arg(double a /Constrained/, int fieldWidth = 0, char format = 'g', int precision = -1, const QChar &fillChar = QLatin1Char(' ')) const;
%End
%If (Qt_5_0_0 -)
    QString arg(qlonglong a, int fieldwidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const;
%End
%If (- Qt_5_0_0)
    QString arg(qlonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
%End
%If (Qt_5_0_0 -)
    QString arg(qulonglong a, int fieldwidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const;
%End
%If (- Qt_5_0_0)
    QString arg(qulonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
%End
%If (Qt_5_0_0 -)
    QString arg(const QString &a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const;
%End
%If (- Qt_5_0_0)
    QString arg(const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const;
%End
    QString arg(const QString &a1, const QString &a2) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const;
%If (Qt_4_3_0 -)
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5) const;
%End
%If (Qt_4_3_0 -)
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6) const;
%End
%If (Qt_4_3_0 -)
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7) const;
%End
%If (Qt_4_3_0 -)
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8) const;
%End
%If (Qt_4_3_0 -)
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8, const QString &a9) const;
%End
    int count(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_4_8_0 -)
    int count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    int count(const QRegExp &) const;
    int indexOf(const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_4_8_0 -)
    int indexOf(const QStringRef &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    int indexOf(const QLatin1String &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    int indexOf(const QRegExp &rx, int from = 0) const;
    int lastIndexOf(const QString &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_4_8_0 -)
    int lastIndexOf(const QStringRef &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    int lastIndexOf(const QLatin1String &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    int lastIndexOf(const QRegExp &rx, int from = -1) const;
%If (Qt_5_0_0 -)
    bool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (- Qt_5_0_0)
    QBool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_5_0_0 -)
    bool contains(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 - Qt_5_0_0)
    QBool contains(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_5_0_0 -)
    bool contains(const QRegExp &rx) const;
%End
%If (- Qt_5_0_0)
    QBool contains(const QRegExp &rx) const;
%End

    enum SectionFlag
    {
        SectionDefault,
        SectionSkipEmpty,
        SectionIncludeLeadingSep,
        SectionIncludeTrailingSep,
        SectionCaseInsensitiveSeps,
    };

    typedef QFlags<QString::SectionFlag> SectionFlags;
    QString section(const QString &sep, int start, int end = -1, QFlags<QString::SectionFlag> flags = SectionDefault) const;
    QString section(const QRegExp &reg, int start, int end = -1, QFlags<QString::SectionFlag> flags = SectionDefault) const;
    QString left(int len) const;
    QString right(int len) const;
    QString mid(int position, int n = -1) const;
    bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_4_8_0 -)
    bool startsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    bool startsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_4_8_0 -)
    bool endsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    bool endsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QString leftJustified(int width, QChar fillChar = QLatin1Char(' '), bool truncate = false) const;
    QString rightJustified(int width, QChar fillChar = QLatin1Char(' '), bool truncate = false) const;
    QString toLower() const;
    QString toUpper() const;
    QString trimmed() const;
    QString simplified() const;
    QString &insert(int i, const QString &s);
    QString &insert(int i, const QLatin1String &s);
    QString &append(const QString &s);
    QString &append(const QLatin1String &s);
    QString &prepend(const QString &s);
    QString &prepend(const QLatin1String &s);
    QString &operator+=(QChar::SpecialCharacter c);
    QString &operator+=(const QString &s);
    QString &operator+=(const QLatin1String &s);
    QString &remove(int i, int len);
    QString &remove(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(int i, int len, const QString &after);
    QString &replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QRegExp &rx, const QString &after);
    QString &remove(const QRegExp &rx);

    enum SplitBehavior
    {
        KeepEmptyParts,
        SkipEmptyParts,
    };

    QStringList split(const QString &sep, QString::SplitBehavior behavior = QString::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QStringList split(const QRegExp &sep, QString::SplitBehavior behavior = QString::KeepEmptyParts) const;

    enum NormalizationForm
    {
        NormalizationForm_D,
        NormalizationForm_C,
        NormalizationForm_KD,
        NormalizationForm_KC,
    };

%If (Qt_5_0_0 -)
    QString normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version = QChar::Unicode_Unassigned) const;
%End
%If (- Qt_5_0_0)
    QString normalized(QString::NormalizationForm mode) const;
%End
%If (- Qt_5_0_0)
    QString normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version) const;
%End
%If (PyQt_Deprecated_5_0)
    QByteArray toAscii() const;
%End
    QByteArray toLatin1() const;
    QByteArray toUtf8() const;
    QByteArray toLocal8Bit() const;
%If (PyQt_Deprecated_5_0)
    static QString fromAscii(const char *str /Encoding="ASCII"/, int size = -1);
%End
    static QString fromLatin1(const char *str /Encoding="Latin-1"/, int size = -1);
    static QString fromUtf8(const char *str /Encoding="UTF-8"/, int size = -1);
    static QString fromLocal8Bit(const char *str /Encoding="None"/, int size = -1);
%If (Qt_5_0_0 -)
    int compare(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (- Qt_5_0_0)
    int compare(const QString &s) const;
%End
%If (Qt_4_2_0 - Qt_5_0_0)
    int compare(const QString &s, Qt::CaseSensitivity cs) const;
%End
%If (Qt_4_2_0 -)
    int compare(const QLatin1String &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    int compare(const QStringRef &ref, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_5_0_0 -)
    static int compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (- Qt_5_0_0)
    static int compare(const QString &s1, const QString &s2);
%End
%If (Qt_4_2_0 - Qt_5_0_0)
    static int compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs);
%End
%If (Qt_4_2_0 -)
    static int compare(const QString &s1, const QLatin1String &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_2_0 -)
    static int compare(const QLatin1String &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    static int compare(const QString &s1, const QStringRef &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
    int localeAwareCompare(const QString &s) const;
%If (Qt_4_5_0 -)
    int localeAwareCompare(const QStringRef &s) const;
%End
    static int localeAwareCompare(const QString &s1, const QString &s2);
%If (Qt_4_5_0 -)
    static int localeAwareCompare(const QString &s1, const QStringRef &s2);
%End
    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    long toLong(bool *ok = 0, int base = 10) const;
    ulong toULong(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
    QString &setNum(int n /Constrained/, int base = 10);
    QString &setNum(double n /Constrained/, char format = 'g', int precision = 6);
    QString &setNum(qlonglong n, int base = 10);
    QString &setNum(qulonglong n, int base = 10);
    static QString number(int n /Constrained/, int base = 10);
    static QString number(double n /Constrained/, char format = 'g', int precision = 6);
    static QString number(qlonglong n, int base = 10);
    static QString number(qulonglong n, int base = 10);
    bool operator==(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator==(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator==(*a0);
        #endif
%End

    bool operator<(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator<(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator<(*a0);
        #endif
%End

    bool operator>(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator>(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator<(*a0);
        #endif
%End

    bool operator!=(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator!=(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator!=(*a0);
        #endif
%End

    bool operator<=(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator<=(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator<=(*a0);
        #endif
%End

    bool operator>=(const QString &s) const;
%MethodCode
        // In Qt5 this is a global operator and so SIP appends it to the list of class operators.
        // However these must appear before the corresponding QByteArray argument operator.
        #if QT_VERSION >= 0x050000
            sipRes = operator>=(*sipCpp, *a0);
        #else
            sipRes = sipCpp->QString::operator>=(*a0);
        #endif
%End

    bool operator==(const QLatin1String &s) const;
    bool operator<(const QLatin1String &s) const;
    bool operator>(const QLatin1String &s) const;
    bool operator!=(const QLatin1String &s) const;
    bool operator<=(const QLatin1String &s) const;
    bool operator>=(const QLatin1String &s) const;
    QString &prepend(const QByteArray &s);
    QString &append(const QByteArray &s);
    QString &operator+=(const QByteArray &s);
    bool operator==(const QByteArray &s) const;
    bool operator!=(const QByteArray &s) const;
    bool operator<(const QByteArray &s) const;
    bool operator>(const QByteArray &s) const;
    bool operator<=(const QByteArray &s) const;
    bool operator>=(const QByteArray &s) const;
    void push_back(const QString &s);
    void push_front(const QString &s);
    bool isNull() const;
    bool isSimpleText() const;
    bool isRightToLeft() const;
    int length() const;
    const QChar at(int i) const;
    QString operator[](int i) const;
%MethodCode
        // Note that we return a QString (rather than a QChar as Qt does).  This makes
        // things a bit easier in Python (because it doesn't distinguish between
        // characters and strings), although now that a QChar can be used whenever a
        // QString is expected it doesn't really matter.
        SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());
        
        if (idx < 0)
            sipIsErr = 1;
        else
            sipRes = new QString(sipCpp->operator[]((int)idx));
%End

    QString operator[](SIP_PYSLICE slice) const;
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->length();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
        {
            sipRes = new QString();
        
            for (i = 0; i < slicelength; ++i)
            {
                sipRes -> append(sipCpp->at(start));
                start += step;
            }
        }
%End

    int __contains__(const QString &s) const;
%MethodCode
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

%If (!Py_v3)
    SIP_PYOBJECT __unicode__() const /DocType="unicode"/;
%MethodCode
        sipRes = qpycore_PyObject_FromQString(*sipCpp);
%End

%End
    SIP_PYOBJECT __str__() const /DocType="str"/;
%MethodCode
        sipRes = qpycore_PyObject_FromQString(*sipCpp);
%End

    long __hash__() const;
%MethodCode
        sipRes = qHash(*sipCpp);
%End

    QString operator*(int m) const;
%MethodCode
        sipRes = new QString();
        
        while (a0-- > 0)
            *sipRes += *sipCpp;
%End

    QString &operator*=(int m);
%MethodCode
        QString orig(*sipCpp);
        
        sipCpp->clear();
        
        while (a0-- > 0)
            *sipCpp += orig;
%End

    bool isEmpty() const;
    void clear();
    int capacity() const;
    void reserve(int asize);
%If (Qt_4_3_0 -)
    QString toCaseFolded() const;
%End
%If (Qt_4_5_0 -)
    QString &replace(const QLatin1String &before, const QLatin1String &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    QString &replace(const QLatin1String &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    QString &replace(const QString &before, const QLatin1String &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    QString repeated(int times) const;
%End
%If (Qt_4_8_0 -)
    void swap(QString &other);
%End
%If (Qt_5_0_0 -)
    QString toHtmlEscaped() const;
%End
%If (Qt_5_0_0 -)
    static QString fromLatin1(const QByteArray &str);
%End
%If (Qt_5_0_0 -)
    static QString fromUtf8(const QByteArray &str);
%End
%If (Qt_5_0_0 -)
    static QString fromLocal8Bit(const QByteArray &str);
%End
};

class QLatin1String /API=QString: - 2/
{
%TypeHeaderCode
#include <qstring.h>
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"(s)", sipCpp->latin1());
%End

public:
    explicit QLatin1String(const char *s /Encoding="Latin-1",KeepReference/);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        PyObject *str = SIPBytes_FromString(sipCpp->latin1());
        
        if (str)
        {
        #if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QLatin1String(%R)", str);
        #else
            sipRes = PyString_FromString("PyQt4.QtCore.QLatin1String(");
            PyString_ConcatAndDel(&sipRes, PyObject_Repr(str));
            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
        
            Py_DECREF(str);
        }
%End

    const char *latin1() const /Encoding="None"/;
    bool operator==(const QString &s) const;
    bool operator!=(const QString &s) const;
    bool operator>(const QString &s) const;
    bool operator<(const QString &s) const;
    bool operator>=(const QString &s) const;
    bool operator<=(const QString &s) const;
%If (Qt_5_0_0 -)
    int size() const;
%End
};

const QString operator+(const QString &s1, const QString &s2) /Numeric/;
const QString operator+(QChar s1, const QString &s2) /Numeric/;
const QString operator+(const QByteArray &ba, const QString &s) /Numeric/;
const QString operator+(const QString &s, const QByteArray &ba) /Numeric/;
QDataStream &operator<<(QDataStream &, const QString & /Constrained/) /API=QString: - 2/;
QDataStream &operator>>(QDataStream &, QString & /Constrained/) /API=QString: - 2/;
QFlags<QString::SectionFlag> operator|(QString::SectionFlag f1, QFlags<QString::SectionFlag> f2);
%If (Qt_5_0_0 -)
bool operator==(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator==(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator!=(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator!=(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator<(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator<(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator<=(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator<=(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator>(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator>(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator>=(QLatin1String s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator>=(const QLatin1String &s1, const QLatin1String &s2);
%End
%If (Qt_4_3_0 -)
void qSwap(QString &value1, QString &value2) /API=QString: - 2/;
%End
%If (Qt_4_3_0 -)
// class QStringRef /API=QString:2 - /
%MappedType QStringRef /API=QString:2 - /
{
%TypeHeaderCode
#include <qstring.h>
%End

%ConvertToTypeCode
    // Qt only ever returns a QStringRef so this conversion isn't needed.
    return 0;
%End

%ConvertFromTypeCode
    return qpycore_PyObject_FromQString(sipCpp->toString());
%End
};
%End
%If (Qt_4_3_0 -)

class QStringRef /API=QString: - 2/
{
%TypeHeaderCode
#include <qstring.h>
%End

public:
    QStringRef();
    QStringRef(const QString *aString, int aPosition, int aSize);
    QStringRef(const QString *aString);
    QStringRef(const QStringRef &other);
    ~QStringRef();
    const QString *string() const;
    int position() const;
    int size() const;
    int count() const /__len__/;
    int length() const;
    const QChar *unicode() const;
    const QChar *data() const;
    const QChar *constData() const;
    void clear();
    QString toString() const;
    bool isEmpty() const;
    bool isNull() const;
    QStringRef appendTo(QString *string) const;
    const QChar at(int i) const;
%If (Qt_4_5_0 -)
    int compare(const QString &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    int compare(const QStringRef &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    int compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_5_0 -)
    static int compare(const QStringRef &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    static int compare(const QStringRef &s1, const QStringRef &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    static int compare(const QStringRef &s1, QLatin1String s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (Qt_4_5_0 -)
    int localeAwareCompare(const QString &s) const;
%End
%If (Qt_4_5_0 -)
    int localeAwareCompare(const QStringRef &s) const;
%End
%If (Qt_4_5_0 -)
    static int localeAwareCompare(const QStringRef &s1, const QString &s2);
%End
%If (Qt_4_5_0 -)
    static int localeAwareCompare(const QStringRef &s1, const QStringRef &s2);
%End
%If (!Py_v3)
    SIP_PYOBJECT __unicode__() const /DocType="unicode"/;
%MethodCode
        sipRes = qpycore_PyObject_FromQString(sipCpp->toString());
%End

%End
    SIP_PYOBJECT __str__() const /DocType="str"/;
%MethodCode
        sipRes = qpycore_PyObject_FromQString(sipCpp->toString());
%End

%If (Qt_4_8_0 -)
    int indexOf(const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int indexOf(QLatin1String str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int indexOf(const QStringRef &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int lastIndexOf(const QString &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int lastIndexOf(QLatin1String str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int lastIndexOf(const QStringRef &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int count(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    int count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool startsWith(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool startsWith(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool startsWith(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool endsWith(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool endsWith(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
    bool endsWith(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 -)
%If (PyQt_Deprecated_5_0)
    QByteArray toAscii() const;
%End
%End
%If (Qt_4_8_0 -)
    QByteArray toLatin1() const;
%End
%If (Qt_4_8_0 -)
    QByteArray toUtf8() const;
%End
%If (Qt_4_8_0 -)
    QByteArray toLocal8Bit() const;
%End
%If (Qt_4_8_0 -)
    QVector<unsigned int> toUcs4() const;
%End
%If (Qt_5_0_0 -)
    bool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 - Qt_5_0_0)
    QBool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_5_0_0 -)
    bool contains(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 - Qt_5_0_0)
    QBool contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_5_0_0 -)
    bool contains(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (Qt_4_8_0 - Qt_5_0_0)
    QBool contains(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
};

%End
%If (Qt_4_3_0 -)
bool operator==(const QStringRef &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator!=(const QStringRef &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator==(const QString &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator!=(const QString &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator==(const QStringRef &s1, const QString &s2);
%End
%If (Qt_4_3_0 -)
bool operator!=(const QStringRef &s1, const QString &s2);
%End
%If (Qt_5_0_0 -)
bool operator==(QLatin1String s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator==(const QLatin1String &s1, const QStringRef &s2);
%End
%If (Qt_5_0_0 -)
bool operator!=(QLatin1String s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator!=(const QLatin1String &s1, const QStringRef &s2);
%End
%If (Qt_5_0_0 -)
bool operator==(const QStringRef &s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator==(const QStringRef &s1, const QLatin1String &s2);
%End
%If (Qt_5_0_0 -)
bool operator!=(const QStringRef &s1, QLatin1String s2);
%End
%If (Qt_4_3_0 - Qt_5_0_0)
bool operator!=(const QStringRef &s1, const QLatin1String &s2);
%End
%If (Qt_4_3_0 -)
bool operator<(const QStringRef &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator>(const QStringRef &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator<=(const QStringRef &s1, const QStringRef &s2);
%End
%If (Qt_4_3_0 -)
bool operator>=(const QStringRef &s1, const QStringRef &s2);
%End
