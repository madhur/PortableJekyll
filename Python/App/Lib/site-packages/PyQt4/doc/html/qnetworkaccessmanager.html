<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QNetworkAccessManager Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QNetworkAccessManager Class Reference<br /><sup><sup>[<a href="qtnetwork.html">QtNetwork</a> module]</sup></sup></h1><p>The QNetworkAccessManager class allows the application to send
network requests and receive replies <a href="#details">More...</a></p>

<p>Inherits <a href="qobject.html">QObject</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">NetworkAccessibility</a></b> { UnknownAccessibility, NotAccessible, Accessible }</li><li><div class="fn" />enum <b><a href="qnetworkaccessmanager.html#Operation-enum">Operation</a></b> { HeadOperation, GetOperation, PutOperation, PostOperation, DeleteOperation, CustomOperation }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#QNetworkAccessManager">__init__</a></b> (<i>self</i>, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" />QNetworkConfiguration <b><a href="qnetworkaccessmanager.html#activeConfiguration">activeConfiguration</a></b> (<i>self</i>)</li><li><div class="fn" />QAbstractNetworkCache <b><a href="qnetworkaccessmanager.html#cache">cache</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkConfiguration <b><a href="qnetworkaccessmanager.html#configuration">configuration</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkCookieJar <b><a href="qnetworkaccessmanager.html#cookieJar">cookieJar</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#createRequest">createRequest</a></b> (<i>self</i>, Operation&#160;<i>op</i>, QNetworkRequest&#160;<i>request</i>, QIODevice&#160;<i>device</i>&#160;=&#160;None)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#get">get</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#head">head</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>)</li><li><div class="fn" />NetworkAccessibility <b><a href="qnetworkaccessmanager.html#networkAccessible">networkAccessible</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#post">post</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QIODevice&#160;<i>data</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#post-2">post</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QByteArray&#160;<i>data</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#post-3">post</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QHttpMultiPart&#160;<i>multiPart</i>)</li><li><div class="fn" />QNetworkProxy <b><a href="qnetworkaccessmanager.html#proxy">proxy</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkProxyFactory <b><a href="qnetworkaccessmanager.html#proxyFactory">proxyFactory</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#put">put</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QIODevice&#160;<i>data</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#put-2">put</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QByteArray&#160;<i>data</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#put-3">put</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QHttpMultiPart&#160;<i>multiPart</i>)</li><li><div class="fn" />QNetworkReply <b><a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a></b> (<i>self</i>, QNetworkRequest&#160;<i>request</i>, QByteArray&#160;<i>verb</i>, QIODevice&#160;<i>data</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setCache">setCache</a></b> (<i>self</i>, QAbstractNetworkCache&#160;<i>cache</i>)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setConfiguration">setConfiguration</a></b> (<i>self</i>, QNetworkConfiguration&#160;<i>config</i>)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a></b> (<i>self</i>, QNetworkCookieJar&#160;<i>cookieJar</i>)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setNetworkAccessible">setNetworkAccessible</a></b> (<i>self</i>, NetworkAccessibility&#160;<i>accessible</i>)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setProxy">setProxy</a></b> (<i>self</i>, QNetworkProxy&#160;<i>proxy</i>)</li><li><div class="fn" /><b><a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a></b> (<i>self</i>, QNetworkProxyFactory&#160;<i>factory</i>)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qnetworkaccessmanager.html#authenticationRequired">authenticationRequired</a></b> (QNetworkReply *,QAuthenticator *)</li><li><div class="fn" />void <b><a href="qnetworkaccessmanager.html#finished">finished</a></b> (QNetworkReply *)</li><li><div class="fn" />void <b><a href="qnetworkaccessmanager.html#networkAccessibleChanged">networkAccessibleChanged</a></b> (QNetworkAccessManager::NetworkAccessibility)</li><li><div class="fn" />void <b><a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a></b> (const QNetworkProxy&amp;,QAuthenticator *)</li><li><div class="fn" />void <b><a href="qnetworkaccessmanager.html#sslErrors">sslErrors</a></b> (QNetworkReply *,const QList&lt;QSslError&gt;&amp;)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QNetworkAccessManager class allows the application to send
network requests and receive replies</p>
<p>The Network Access API is constructed around one
QNetworkAccessManager object, which holds the common configuration
and settings for the requests it sends. It contains the proxy and
cache configuration, as well as the signals related to such issues,
and reply signals that can be used to monitor the progress of a
network operation. One QNetworkAccessManager should be enough for
the whole Qt application.</p>
<p>Once a QNetworkAccessManager object has been created, the
application can use it to send requests over the network. A group
of standard functions are supplied that take a request and optional
data, and each return a <a href="qnetworkreply.html">QNetworkReply</a> object. The returned object
is used to obtain any data returned in response to the
corresponding request.</p>
<p>A simple download off the network could be accomplished
with:</p>
<pre class="cpp">
 <span class="type">QNetworkAccessManager</span> <span class="operator">*</span>manager <span class="operator">=</span> <span class="keyword">new</span> <span class="type">QNetworkAccessManager</span>(<span class="keyword">this</span>);
 <a href="qobject.html#connect">connect</a>(manager<span class="operator">,</span> SIGNAL(finished(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">*</span>))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(replyFinished(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">*</span>)));

 manager<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkaccessmanager.html#get">get</a>(<span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span>(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">"http://qt.nokia.com"</span>)));
</pre>
<p>QNetworkAccessManager has an asynchronous API. When the
<tt>replyFinished</tt> slot above is called, the parameter it takes
is the <a href="qnetworkreply.html">QNetworkReply</a> object
containing the downloaded data as well as meta-data (headers,
etc.).</p>
<p><b>Note:</b> After the request has finished, it is the
responsibility of the user to delete the <a href="qnetworkreply.html">QNetworkReply</a> object at an appropriate
time. Do not directly delete it inside the slot connected to
<a href="qnetworkaccessmanager.html#finished">finished</a>(). You
can use the <a href="qobject.html#deleteLater">deleteLater</a>()
function.</p>
<p><b>Note:</b> QNetworkAccessManager queues the requests it
receives. The number of requests executed in parallel is dependent
on the protocol. Currently, for the HTTP protocol on desktop
platforms, 6 requests are executed in parallel for one host/port
combination.</p>
<p>A more involved example, assuming the manager is already
existent, can be:</p>
<pre class="cpp">
 <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> request;
 request<span class="operator">.</span>setUrl(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">"http://qt.nokia.com"</span>));
 request<span class="operator">.</span>setRawHeader(<span class="string">"User-Agent"</span><span class="operator">,</span> <span class="string">"MyOwnBrowser 1.0"</span>);

 <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkaccessmanager.html#get">get</a>(request);
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(readyRead())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(slotReadyRead()));
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(error(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">.</span>NetworkError))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(slotError(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">.</span>NetworkError)));
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(sslErrors(<span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span>))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(slotSslErrors(<span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span>)));
</pre>
<a id="network-and-roaming-support" name="network-and-roaming-support" />
<h3>Network and Roaming support</h3>
<p>With the addition of the <a href="bearer-management.html">Bearer
Management</a> API to Qt 4.7 QNetworkAccessManager gained the
ability to manage network connections. QNetworkAccessManager can
start the network interface if the device is offline and terminates
the interface if the current process is the last one to use the
uplink. Note that some platform utilize grace periods from when the
last application stops using a uplink until the system actually
terminates the connectivity link. Roaming is equally transparent.
Any queued/pending network requests are automatically transferred
to new access point.</p>
<p>Clients wanting to utilize this feature should not require any
changes. In fact it is likely that existing platform specific
connection code can simply be removed from the application.</p>
<p><b>Note:</b> The network and roaming support in
QNetworkAccessManager is conditional upon the platform supporting
connection management. The <a href="qnetworkconfigurationmanager.html#Capability-enum">QNetworkConfigurationManager.NetworkSessionRequired</a>
can be used to detect whether QNetworkAccessManager utilizes this
feature. Currently only Meego/Harmattan and Symbian platforms
provide connection management support.</p>
<p><b>Note:</b> This feature cannot be used in combination with the
Bearer Management API as provided by QtMobility. Applications have
to migrate to the Qt version of Bearer Management.</p>
<a id="symbian-platform-security-requirements" name="symbian-platform-security-requirements" />
<h3>Symbian Platform Security Requirements</h3>
<p>On Symbian, processes which use this class must have the
<tt>NetworkServices</tt> platform security capability. If the
client process lacks this capability, operations will result in a
panic.</p>
<p>Platform security capabilities are added via the <a href="qmake-variable-reference.html#target-capability">TARGET.CAPABILITY</a>
qmake variable.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="NetworkAccessibility-enum" />QNetworkAccessManager.NetworkAccessibility</h3><p>Indicates whether the network is accessible via this network
access manager.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.UnknownAccessibility</tt></td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">The network accessibility cannot be
determined.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.NotAccessible</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The network is not currently accessible,
either because there is currently no network coverage or network
access has been explicitly disabled by a call to <a href="qnetworkaccessmanager.html#networkAccessible-prop">setNetworkAccessible</a>().</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.Accessible</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The network is accessible.</td>
</tr>
</table>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a>.</p>


<h3 class="fn"><a name="Operation-enum" />QNetworkAccessManager.Operation</h3><p>Indicates the operation this reply is processing.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.HeadOperation</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">retrieve headers operation (created with
<a href="qnetworkaccessmanager.html#head">head</a>())</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.GetOperation</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">retrieve headers and download contents
(created with <a href="qnetworkaccessmanager.html#get">get</a>())</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.PutOperation</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">upload contents operation (created with
<a href="qnetworkaccessmanager.html#put">put</a>())</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.PostOperation</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">send the contents of an HTML form for
processing via HTTP POST (created with <a href="qnetworkaccessmanager.html#post">post</a>())</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.DeleteOperation</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">delete contents operation (created with
<a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>())</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkAccessManager.CustomOperation</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">custom operation (created with <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>())</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.7.</p>
<p><b>See also</b> <a href="qnetworkreply.html#operation">QNetworkReply.operation</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QNetworkAccessManager" />QNetworkAccessManager.__init__ (<i>self</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Constructs a <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object that
is the center of the Network Access API and sets <i>parent</i> as
the parent object.</p>


<h3 class="fn"><a name="activeConfiguration" /><a href="qnetworkconfiguration.html">QNetworkConfiguration</a> QNetworkAccessManager.activeConfiguration (<i>self</i>)</h3><p>Returns the current active network configuration.</p>
<p>If the network configuration returned by <a href="qnetworkaccessmanager.html#configuration">configuration</a>() is
of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration.ServiceNetwork</a>
this function will return the current active child network
configuration of that configuration. Otherwise returns the same
network configuration as <a href="qnetworkaccessmanager.html#configuration">configuration</a>().</p>
<p>Use this function to return the actual network configuration
currently in use by the network session.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#configuration">configuration</a>().</p>


<h3 class="fn"><a name="cache" /><a href="qabstractnetworkcache.html">QAbstractNetworkCache</a> QNetworkAccessManager.cache (<i>self</i>)</h3><p>Returns the cache that is used to store data obtained from the
network.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#setCache">setCache</a>().</p>


<h3 class="fn"><a name="configuration" /><a href="qnetworkconfiguration.html">QNetworkConfiguration</a> QNetworkAccessManager.configuration (<i>self</i>)</h3><p>Returns the network configuration that will be used to create
the <a href="qnetworksession.html">network session</a> which will
be used when processing network requests.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#setConfiguration">setConfiguration</a>()
and <a href="qnetworkaccessmanager.html#activeConfiguration">activeConfiguration</a>().</p>


<h3 class="fn"><a name="cookieJar" /><a href="qnetworkcookiejar.html">QNetworkCookieJar</a> QNetworkAccessManager.cookieJar (<i>self</i>)</h3><p>Returns the <a href="qnetworkcookiejar.html">QNetworkCookieJar</a> that is used to
store cookies obtained from the network as well as cookies that are
about to be sent.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a>().</p>


<h3 class="fn"><a name="createRequest" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.createRequest (<i>self</i>, <a href="qnetworkaccessmanager.html#Operation-enum">Operation</a>&#160;<i>op</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>&#160;=&#160;None)</h3><p>Returns a new <a href="qnetworkreply.html">QNetworkReply</a>
object to handle the operation <i>op</i> and request <i>req</i>.
The device <i>outgoingData</i> is always 0 for Get and Head
requests, but is the value passed to <a href="qnetworkaccessmanager.html#post">post</a>() and <a href="qnetworkaccessmanager.html#put">put</a>() in those operations (the
<a href="qbytearray.html">QByteArray</a> variants will pass a
<a href="qbuffer.html">QBuffer</a> object).</p>
<p>The default implementation calls <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar.cookiesForUrl</a>()
on the cookie jar set with <a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a>() to
obtain the cookies to be sent to the remote server.</p>
<p>The returned object must be in an open state.</p>


<h3 class="fn"><a name="deleteResource" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.deleteResource (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>)</h3><p>Sends a request to delete the resource identified by the URL of
<i>request</i>.</p>
<p><b>Note:</b> This feature is currently available for HTTP only,
performing an HTTP DELETE request.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>


<h3 class="fn"><a name="get" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.get (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>)</h3><p>Posts a request to obtain the contents of the target
<i>request</i> and returns a new <a href="qnetworkreply.html">QNetworkReply</a> object opened for reading
which emits the <a href="qiodevice.html#readyRead">readyRead()</a>
signal whenever new data arrives.</p>
<p>The contents as well as associated headers will be
downloaded.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(),
and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>


<h3 class="fn"><a name="head" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.head (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>)</h3><p>Posts a request to obtain the network headers for <i>request</i>
and returns a new <a href="qnetworkreply.html">QNetworkReply</a>
object which will contain such headers.</p>
<p>The function is named after the HTTP request associated
(HEAD).</p>


<h3 class="fn"><a name="networkAccessible" /><a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">NetworkAccessibility</a> QNetworkAccessManager.networkAccessible (<i>self</i>)</h3><h3 class="fn"><a name="post" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.post (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>data</i>)</h3><p>Sends an HTTP POST request to the destination specified by
<i>request</i> and returns a new <a href="qnetworkreply.html">QNetworkReply</a> object opened for reading
that will contain the reply sent by the server. The contents of the
<i>data</i> device will be uploaded to the server.</p>
<p><i>data</i> must be open for reading and must remain valid until
the <a href="qnetworkaccessmanager.html#finished">finished</a>()
signal is emitted for this reply.</p>
<p><b>Note:</b> Sending a POST request on protocols other than HTTP
and HTTPS is undefined and will probably fail.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(),
and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>


<h3 class="fn"><a name="post-2" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.post (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>)</h3><p>This is an overloaded function.</p>
<p>Sends the contents of the <i>data</i> byte array to the
destination specified by <i>request</i>.</p>


<h3 class="fn"><a name="post-3" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.post (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qhttpmultipart.html">QHttpMultiPart</a>&#160;<i>multiPart</i>)</h3><p>This is an overloaded function.</p>
<p>Sends the contents of the <i>multiPart</i> message to the
destination specified by <i>request</i>.</p>
<p>This can be used for sending MIME multipart messages over
HTTP.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qhttpmultipart.html">QHttpMultiPart</a>, <a href="qhttppart.html">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#put">put</a>().</p>


<h3 class="fn"><a name="proxy" /><a href="qnetworkproxy.html">QNetworkProxy</a> QNetworkAccessManager.proxy (<i>self</i>)</h3><p>Returns the <a href="qnetworkproxy.html">QNetworkProxy</a> that
the requests sent using this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object will
use. The default value for the proxy is <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.DefaultProxy</a>.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), <a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>(),
and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>


<h3 class="fn"><a name="proxyFactory" /><a href="qnetworkproxyfactory.html">QNetworkProxyFactory</a> QNetworkAccessManager.proxyFactory (<i>self</i>)</h3><p>Returns the proxy factory that this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object is
using to determine the proxies to be used for requests.</p>
<p>Note that the pointer returned by this function is managed by
<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> and
could be deleted at any time.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>()
and <a href="qnetworkaccessmanager.html#proxy">proxy</a>().</p>


<h3 class="fn"><a name="put" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.put (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>data</i>)</h3><p>Uploads the contents of <i>data</i> to the destination
<i>request</i> and returnes a new <a href="qnetworkreply.html">QNetworkReply</a> object that will be open for
reply.</p>
<p><i>data</i> must be opened for reading when this function is
called and must remain valid until the <a href="qnetworkaccessmanager.html#finished">finished</a>() signal is
emitted for this reply.</p>
<p>Whether anything will be available for reading from the returned
object is protocol dependent. For HTTP, the server may send a small
HTML page indicating the upload was successful (or not). Other
protocols will probably have content in their replies.</p>
<p><b>Note:</b> For HTTP, this request will send a PUT request,
which most servers do not allow. Form upload mechanisms, including
that of uploading files through HTML forms, use the POST
mechanism.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(),
and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>


<h3 class="fn"><a name="put-2" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.put (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>)</h3><p>This is an overloaded function.</p>
<p>Sends the contents of the <i>multiPart</i> message to the
destination specified by <i>request</i>.</p>
<p>This can be used for sending MIME multipart messages over
HTTP.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qhttpmultipart.html">QHttpMultiPart</a>, <a href="qhttppart.html">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#post">post</a>().</p>


<h3 class="fn"><a name="put-3" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.put (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qhttpmultipart.html">QHttpMultiPart</a>&#160;<i>multiPart</i>)</h3><p>This is an overloaded function.</p>
<p>Sends the contents of the <i>data</i> byte array to the
destination specified by <i>request</i>.</p>


<h3 class="fn"><a name="sendCustomRequest" /><a href="qnetworkreply.html">QNetworkReply</a> QNetworkAccessManager.sendCustomRequest (<i>self</i>, <a href="qnetworkrequest.html">QNetworkRequest</a>&#160;<i>request</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>verb</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>data</i>&#160;=&#160;None)</h3><p>Sends a custom request to the server identified by the URL of
<i>request</i>.</p>
<p>It is the user's responsibility to send a <i>verb</i> to the
server that is valid according to the HTTP specification.</p>
<p>This method provides means to send verbs other than the common
ones provided via <a href="qnetworkaccessmanager.html#get">get</a>() or <a href="qnetworkaccessmanager.html#post">post</a>() etc., for instance
sending an HTTP OPTIONS command.</p>
<p>If <i>data</i> is not empty, the contents of the <i>data</i>
device will be uploaded to the server; in that case, data must be
open for reading and must remain valid until the <a href="qnetworkaccessmanager.html#finished">finished</a>() signal is
emitted for this reply.</p>
<p><b>Note:</b> This feature is currently available for HTTP(S)
only.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>().</p>


<h3 class="fn"><a name="setCache" />QNetworkAccessManager.setCache (<i>self</i>, <a href="qabstractnetworkcache.html">QAbstractNetworkCache</a>&#160;<i>cache</i>)</h3><p>The <i>cache</i> argument has it's ownership transferred to Qt.</p><p>Sets the manager's network cache to be the <i>cache</i>
specified. The cache is used for all requests dispatched by the
manager.</p>
<p>Use this function to set the network cache object to a class
that implements additional features, like saving the cookies to
permanent storage.</p>
<p><b>Note:</b> <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> takes
ownership of the <i>cache</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>
by default does not have a set cache. Qt provides a simple disk
cache, <a href="qnetworkdiskcache.html">QNetworkDiskCache</a>,
which can be used.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#cache">cache</a>() and <a href="qnetworkrequest.html#CacheLoadControl-enum">QNetworkRequest.CacheLoadControl</a>.</p>


<h3 class="fn"><a name="setConfiguration" />QNetworkAccessManager.setConfiguration (<i>self</i>, <a href="qnetworkconfiguration.html">QNetworkConfiguration</a>&#160;<i>config</i>)</h3><p>Sets the network configuration that will be used when creating
the <a href="qnetworksession.html">network session</a> to
<i>config</i>.</p>
<p>The network configuration is used to create and open a network
session before any request that requires network access is process.
If no network configuration is explicitly set via this function the
network configuration returned by <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager.defaultConfiguration</a>()
will be used.</p>
<p>To restore the default network configuration set the network
configuration to the value returned from <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager.defaultConfiguration</a>().</p>
<pre class="cpp">
 <span class="type"><a href="qnetworkconfigurationmanager.html">QNetworkConfigurationManager</a></span> manager;
 networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setConfiguration(manager<span class="operator">.</span>defaultConfiguration());
</pre>
<p>If an invalid network configuration is set, a network session
will not be created. In this case network requests will be
processed regardless, but may fail. For example:</p>
<pre class="cpp">
 networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setConfiguration(<span class="type"><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></span>());
</pre>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#configuration">configuration</a>() and
<a href="qnetworksession.html">QNetworkSession</a>.</p>


<h3 class="fn"><a name="setCookieJar" />QNetworkAccessManager.setCookieJar (<i>self</i>, <a href="qnetworkcookiejar.html">QNetworkCookieJar</a>&#160;<i>cookieJar</i>)</h3><p>The <i>cookieJar</i> argument has it's ownership transferred to Qt.</p><p>Sets the manager's cookie jar to be the <i>cookieJar</i>
specified. The cookie jar is used by all requests dispatched by the
manager.</p>
<p>Use this function to set the cookie jar object to a class that
implements additional features, like saving the cookies to
permanent storage.</p>
<p><b>Note:</b> <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> takes
ownership of the <i>cookieJar</i> object.</p>
<p>If <i>cookieJar</i> is in the same thread as this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, it will set
the parent of the <i>cookieJar</i> so that the cookie jar is
deleted when this object is deleted as well. If you want to share
cookie jars between different <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> objects, you
may want to set the cookie jar's parent to 0 after calling this
function.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>
by default does not implement any cookie policy of its own: it
accepts all cookies sent by the server, as long as they are well
formed and meet the minimum security requirements (cookie domain
matches the request's and cookie path matches the request's). In
order to implement your own security policy, override the <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar.cookiesForUrl</a>()
and <a href="qnetworkcookiejar.html#setCookiesFromUrl">QNetworkCookieJar.setCookiesFromUrl</a>()
virtual functions. Those functions are called by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> when it
detects a new cookie.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#cookieJar">cookieJar</a>(), <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar.cookiesForUrl</a>(),
and <a href="qnetworkcookiejar.html#setCookiesFromUrl">QNetworkCookieJar.setCookiesFromUrl</a>().</p>


<h3 class="fn"><a name="setNetworkAccessible" />QNetworkAccessManager.setNetworkAccessible (<i>self</i>, <a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">NetworkAccessibility</a>&#160;<i>accessible</i>)</h3><h3 class="fn"><a name="setProxy" />QNetworkAccessManager.setProxy (<i>self</i>, <a href="qnetworkproxy.html">QNetworkProxy</a>&#160;<i>proxy</i>)</h3><p>Sets the proxy to be used in future requests to be <i>proxy</i>.
This does not affect requests that have already been sent. The
<a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>()
signal will be emitted if the proxy requests authentication.</p>
<p>A proxy set with this function will be used for all requests
issued by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. In some
cases, it might be necessary to select different proxies depending
on the type of request being sent or the destination host. If
that's the case, you should consider using <a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>().</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#proxy">proxy</a>() and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>


<h3 class="fn"><a name="setProxyFactory" />QNetworkAccessManager.setProxyFactory (<i>self</i>, <a href="qnetworkproxyfactory.html">QNetworkProxyFactory</a>&#160;<i>factory</i>)</h3><p>The <i>factory</i> argument has it's ownership transferred to Qt.</p><p>Sets the proxy factory for this class to be <i>factory</i>. A
proxy factory is used to determine a more specific list of proxies
to be used for a given request, instead of trying to use the same
proxy value for all requests.</p>
<p>All queries sent by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will have
type <a href="qnetworkproxyquery.html#QueryType-enum">QNetworkProxyQuery.UrlRequest</a>.</p>
<p>For example, a proxy factory could apply the following
rules:</p>
<ul>
<li>if the target address is in the local network (for example, if
the hostname contains no dots or if it's an IP address in the
organization's range), return <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.NoProxy</a></li>
<li>if the request is FTP, return an FTP proxy</li>
<li>if the request is HTTP or HTTPS, then return an HTTP proxy</li>
<li>otherwise, return a SOCKSv5 proxy server</li>
</ul>
<p>The lifetime of the object <i>factory</i> will be managed by
<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. It
will delete the object when necessary.</p>
<p><b>Note:</b> If a specific proxy is set with <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), the factory
will not be used.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#proxyFactory">proxyFactory</a>(),
<a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), and
<a href="qnetworkproxyquery.html">QNetworkProxyQuery</a>.</p>


<hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="authenticationRequired" />void authenticationRequired (QNetworkReply *,QAuthenticator *)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted whenever a final server requests
authentication before it delivers the requested contents. The slot
connected to this signal should fill the credentials for the
contents (which can be determined by inspecting the <i>reply</i>
object) in the <i>authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>
will cache the credentials internally and will send the same values
if the server requires authentication again, without emitting the
authenticationRequired() signal. If it rejects the credentials,
this signal will be emitted again.</p>
<p><b>Note:</b> It is not possible to use a QueuedConnection to
connect to this signal, as the connection will fail if the
authenticator has not been filled in with new information when the
signal returns.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>


<h3 class="fn"><a name="finished" />void finished (QNetworkReply *)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted whenever a pending network reply is
finished. The <i>reply</i> parameter will contain a pointer to the
reply that has just finished. This signal is emitted in tandem with
the <a href="qnetworkreply.html#finished">QNetworkReply.finished</a>()
signal.</p>
<p>See <a href="qnetworkreply.html#finished">QNetworkReply.finished</a>() for
information on the status that the object will be in.</p>
<p><b>Note:</b> Do not delete the <i>reply</i> object in the slot
connected to this signal. Use <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<p><b>See also</b> <a href="qnetworkreply.html#finished">QNetworkReply.finished</a>() and
<a href="qnetworkreply.html#error">QNetworkReply.error</a>().</p>


<h3 class="fn"><a name="networkAccessibleChanged" />void networkAccessibleChanged (QNetworkAccessManager::NetworkAccessibility)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the value of the <a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a>
property changes. <i>accessible</i> is the new network
accessibility.</p>


<h3 class="fn"><a name="proxyAuthenticationRequired" />void proxyAuthenticationRequired (const QNetworkProxy&amp;,QAuthenticator *)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted whenever a proxy requests authentication
and <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>
cannot find a valid, cached credential. The slot connected to this
signal should fill in the credentials for the proxy <i>proxy</i> in
the <i>authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>
will cache the credentials internally. The next time the proxy
requests authentication, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will
automatically send the same credential without emitting the
proxyAuthenticationRequired signal again.</p>
<p>If the proxy rejects the credentials, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will emit
the signal again.</p>
<p><b>See also</b> <a href="qnetworkaccessmanager.html#proxy">proxy</a>(), <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), and <a href="qnetworkaccessmanager.html#authenticationRequired">authenticationRequired</a>().</p>


<h3 class="fn"><a name="sslErrors" />void sslErrors (QNetworkReply *,const QList&lt;QSslError&gt;&amp;)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted if the SSL/TLS session encountered errors
during the set up, including certificate verification errors. The
<i>errors</i> parameter contains the list of errors and
<i>reply</i> is the <a href="qnetworkreply.html">QNetworkReply</a>
that is encountering these errors.</p>
<p>To indicate that the errors are not fatal and that the
connection should proceed, the <a href="qnetworkreply.html#ignoreSslErrors">QNetworkReply.ignoreSslErrors</a>()
function should be called from the slot connected to this signal.
If it is not called, the SSL session will be torn down before any
data is exchanged (including the URL).</p>
<p>This signal can be used to display an error message to the user
indicating that security may be compromised and display the SSL
settings (see sslConfiguration() to obtain it). If the user decides
to proceed after analyzing the remote certificate, the slot should
call ignoreSslErrors().</p>
<p><b>See also</b> <a href="qsslsocket.html#sslErrors">QSslSocket.sslErrors</a>(), <a href="qnetworkreply.html#sslErrors">QNetworkReply.sslErrors</a>(),
<a href="qnetworkreply.html#sslConfiguration">QNetworkReply.sslConfiguration</a>(),
and <a href="qnetworkreply.html#ignoreSslErrors">QNetworkReply.ignoreSslErrors</a>().</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>