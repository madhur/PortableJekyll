<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QAbstractSocket Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QAbstractSocket Class Reference<br /><sup><sup>[<a href="qtnetwork.html">QtNetwork</a> module]</sup></sup></h1><p>The QAbstractSocket class provides the base functionality common
to all socket types. <a href="#details">More...</a></p>

<p>Inherits <a href="qiodevice.html">QIODevice</a>.</p><p>Inherited by <a href="qtcpsocket.html">QTcpSocket</a> and <a href="qudpsocket.html">QUdpSocket</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qabstractsocket.html#NetworkLayerProtocol-enum">NetworkLayerProtocol</a></b> { IPv4Protocol, IPv6Protocol, UnknownNetworkLayerProtocol }</li><li><div class="fn" />enum <b><a href="qabstractsocket.html#SocketError-enum">SocketError</a></b> { ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, SocketAccessError, ..., UnknownSocketError }</li><li><div class="fn" />enum <b><a href="qabstractsocket.html#SocketOption-enum">SocketOption</a></b> { LowDelayOption, KeepAliveOption, MulticastTtlOption, MulticastLoopbackOption }</li><li><div class="fn" />enum <b><a href="qabstractsocket.html#SocketState-enum">SocketState</a></b> { UnconnectedState, HostLookupState, ConnectingState, ConnectedState, ..., ClosingState }</li><li><div class="fn" />enum <b><a href="qabstractsocket.html#SocketType-enum">SocketType</a></b> { TcpSocket, UdpSocket, UnknownSocketType }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qabstractsocket.html#QAbstractSocket">__init__</a></b> (<i>self</i>, SocketType&#160;<i>socketType</i>, QObject&#160;<i>parent</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#abort">abort</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#atEnd">atEnd</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#bytesAvailable">bytesAvailable</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#bytesToWrite">bytesToWrite</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#canReadLine">canReadLine</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#close">close</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#connectToHost">connectToHost</a></b> (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>, QIODevice.OpenMode&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</li><li><div class="fn" /><b><a href="qabstractsocket.html#connectToHost-2">connectToHost</a></b> (<i>self</i>, QHostAddress&#160;<i>address</i>, int&#160;<i>port</i>, QIODevice.OpenMode&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</li><li><div class="fn" /><b><a href="qabstractsocket.html#connectToHostImplementation">connectToHostImplementation</a></b> (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>, QIODevice.OpenMode&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</li><li><div class="fn" /><b><a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#disconnectFromHostImplementation">disconnectFromHostImplementation</a></b> (<i>self</i>)</li><li><div class="fn" />SocketError <b><a href="qabstractsocket.html#error">error</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#flush">flush</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#isSequential">isSequential</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />QHostAddress <b><a href="qabstractsocket.html#localAddress">localAddress</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#localPort">localPort</a></b> (<i>self</i>)</li><li><div class="fn" />QHostAddress <b><a href="qabstractsocket.html#peerAddress">peerAddress</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qabstractsocket.html#peerName">peerName</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#peerPort">peerPort</a></b> (<i>self</i>)</li><li><div class="fn" />QNetworkProxy <b><a href="qabstractsocket.html#proxy">proxy</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#readBufferSize">readBufferSize</a></b> (<i>self</i>)</li><li><div class="fn" />str <b><a href="qabstractsocket.html#readData">readData</a></b> (<i>self</i>, int&#160;<i>maxlen</i>)</li><li><div class="fn" />str <b><a href="qabstractsocket.html#readLineData">readLineData</a></b> (<i>self</i>, int&#160;<i>maxlen</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setLocalAddress">setLocalAddress</a></b> (<i>self</i>, QHostAddress&#160;<i>address</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setLocalPort">setLocalPort</a></b> (<i>self</i>, int&#160;<i>port</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setPeerAddress">setPeerAddress</a></b> (<i>self</i>, QHostAddress&#160;<i>address</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setPeerName">setPeerName</a></b> (<i>self</i>, QString&#160;<i>name</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setPeerPort">setPeerPort</a></b> (<i>self</i>, int&#160;<i>port</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setProxy">setProxy</a></b> (<i>self</i>, QNetworkProxy&#160;<i>networkProxy</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setReadBufferSize">setReadBufferSize</a></b> (<i>self</i>, int&#160;<i>size</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a></b> (<i>self</i>, int&#160;<i>socketDescriptor</i>, SocketState&#160;<i>state</i>&#160;=&#160;QAbstractSocket.ConnectedState, QIODevice.OpenMode&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setSocketError">setSocketError</a></b> (<i>self</i>, SocketError&#160;<i>socketError</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setSocketOption">setSocketOption</a></b> (<i>self</i>, SocketOption&#160;<i>option</i>, QVariant&#160;<i>value</i>)</li><li><div class="fn" /><b><a href="qabstractsocket.html#setSocketState">setSocketState</a></b> (<i>self</i>, SocketState&#160;<i>state</i>)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#socketDescriptor">socketDescriptor</a></b> (<i>self</i>)</li><li><div class="fn" />QVariant <b><a href="qabstractsocket.html#socketOption">socketOption</a></b> (<i>self</i>, SocketOption&#160;<i>option</i>)</li><li><div class="fn" />SocketType <b><a href="qabstractsocket.html#socketType">socketType</a></b> (<i>self</i>)</li><li><div class="fn" />SocketState <b><a href="qabstractsocket.html#state">state</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a></b> (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#waitForConnected">waitForConnected</a></b> (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#waitForDisconnected">waitForDisconnected</a></b> (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</li><li><div class="fn" />bool <b><a href="qabstractsocket.html#waitForReadyRead">waitForReadyRead</a></b> (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</li><li><div class="fn" />int <b><a href="qabstractsocket.html#writeData">writeData</a></b> (<i>self</i>, str&#160;<i>data</i>)</li></ul><h3>Qt Signals</h3><ul><li><div class="fn" />void <b><a href="qabstractsocket.html#connected">connected</a></b> ()</li><li><div class="fn" />void <b><a href="qabstractsocket.html#disconnected">disconnected</a></b> ()</li><li><div class="fn" />void <b><a href="qabstractsocket.html#error-2">error</a></b> (QAbstractSocket::SocketError)</li><li><div class="fn" />void <b><a href="qabstractsocket.html#hostFound">hostFound</a></b> ()</li><li><div class="fn" />void <b><a href="qabstractsocket.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a></b> (const QNetworkProxy&amp;,QAuthenticator *)</li><li><div class="fn" />void <b><a href="qabstractsocket.html#stateChanged">stateChanged</a></b> (QAbstractSocket::SocketState)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QAbstractSocket class provides the base functionality common
to all socket types.</p>
<p>QAbstractSocket is the base class for <a href="qtcpsocket.html">QTcpSocket</a> and <a href="qudpsocket.html">QUdpSocket</a> and contains all common
functionality of these two classes. If you need a socket, you have
two options:</p>
<ul>
<li>Instantiate <a href="qtcpsocket.html">QTcpSocket</a> or
<a href="qudpsocket.html">QUdpSocket</a>.</li>
<li>Create a native socket descriptor, instantiate QAbstractSocket,
and call <a href="qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a>()
to wrap the native socket.</li>
</ul>
<p>TCP (Transmission Control Protocol) is a reliable,
stream-oriented, connection-oriented transport protocol. UDP (User
Datagram Protocol) is an unreliable, datagram-oriented,
connectionless protocol. In practice, this means that TCP is better
suited for continuous transmission of data, whereas the more
lightweight UDP can be used when reliability isn't important.</p>
<p>QAbstractSocket's API unifies most of the differences between
the two protocols. For example, although UDP is connectionless,
<a href="qabstractsocket.html#connectToHost">connectToHost</a>()
establishes a virtual connection for UDP sockets, enabling you to
use QAbstractSocket in more or less the same way regardless of the
underlying protocol. Internally, QAbstractSocket remembers the
address and port passed to <a href="qabstractsocket.html#connectToHost">connectToHost</a>(), and
functions like <a href="qiodevice.html#read">read</a>() and
<a href="qiodevice.html#write">write</a>() use these values.</p>
<p>At any time, QAbstractSocket has a state (returned by <a href="qabstractsocket.html#state">state</a>()). The initial state is
<a href="qabstractsocket.html#SocketState-enum">UnconnectedState</a>. After
calling <a href="qabstractsocket.html#connectToHost">connectToHost</a>(), the
socket first enters <a href="qabstractsocket.html#SocketState-enum">HostLookupState</a>. If the
host is found, QAbstractSocket enters <a href="qabstractsocket.html#SocketState-enum">ConnectingState</a> and
emits the <a href="qabstractsocket.html#hostFound">hostFound</a>()
signal. When the connection has been established, it enters
<a href="qabstractsocket.html#SocketState-enum">ConnectedState</a>
and emits <a href="qabstractsocket.html#connected">connected</a>().
If an error occurs at any stage, <a href="qabstractsocket.html#error">error</a>() is emitted. Whenever the
state changes, <a href="qabstractsocket.html#stateChanged">stateChanged</a>() is emitted.
For convenience, <a href="qabstractsocket.html#isValid">isValid</a>() returns true if the
socket is ready for reading and writing, but note that the socket's
state must be <a href="qabstractsocket.html#SocketState-enum">ConnectedState</a> before
reading and writing can occur.</p>
<p>Read or write data by calling <a href="qiodevice.html#read">read</a>() or <a href="qiodevice.html#write">write</a>(), or use the convenience
functions <a href="qiodevice.html#readLine">readLine</a>() and
<a href="qiodevice.html#readAll">readAll</a>(). QAbstractSocket
also inherits <a href="qiodevice.html#getChar">getChar</a>(),
<a href="qiodevice.html#putChar">putChar</a>(), and <a href="qiodevice.html#ungetChar">ungetChar</a>() from <a href="qiodevice.html">QIODevice</a>, which work on single bytes. The
<a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal is
emitted when data has been written to the socket (i.e., when the
client has read the data). Note that Qt does not limit the write
buffer size. You can monitor its size by listening to this
signal.</p>
<p>The <a href="qiodevice.html#readyRead">readyRead</a>() signal is
emitted every time a new chunk of data has arrived. <a href="qabstractsocket.html#bytesAvailable">bytesAvailable</a>() then
returns the number of bytes that are available for reading.
Typically, you would connect the <a href="qiodevice.html#readyRead">readyRead</a>() signal to a slot and
read all available data there. If you don't read all the data at
once, the remaining data will still be available later, and any new
incoming data will be appended to QAbstractSocket's internal read
buffer. To limit the size of the read buffer, call <a href="qabstractsocket.html#setReadBufferSize">setReadBufferSize</a>().</p>
<p>To close the socket, call <a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>().
QAbstractSocket enters <a href="qabstractsocket.html#SocketState-enum">QAbstractSocket.ClosingState</a>.
After all pending data has been written to the socket,
QAbstractSocket actually closes the socket, enters
QAbstractSocket.ClosedState, and emits <a href="qabstractsocket.html#disconnected">disconnected</a>(). If you want
to abort a connection immediately, discarding all pending data,
call <a href="qabstractsocket.html#abort">abort</a>() instead. If
the remote host closes the connection, QAbstractSocket will emit
error(<a href="qabstractsocket.html#SocketError-enum">QAbstractSocket.RemoteHostClosedError</a>),
during which the socket state will still be <a href="qabstractsocket.html#SocketState-enum">ConnectedState</a>, and
then the <a href="qabstractsocket.html#disconnected">disconnected</a>() signal will
be emitted.</p>
<p>The port and address of the connected peer is fetched by calling
<a href="qabstractsocket.html#peerPort">peerPort</a>() and <a href="qabstractsocket.html#peerAddress">peerAddress</a>(). <a href="qabstractsocket.html#peerName">peerName</a>() returns the host
name of the peer, as passed to <a href="qabstractsocket.html#connectToHost">connectToHost</a>(). <a href="qabstractsocket.html#localPort">localPort</a>() and <a href="qabstractsocket.html#localAddress">localAddress</a>() return the
port and address of the local socket.</p>
<p>QAbstractSocket provides a set of functions that suspend the
calling thread until certain signals are emitted. These functions
can be used to implement blocking sockets:</p>
<ul>
<li><a href="qabstractsocket.html#waitForConnected">waitForConnected</a>()
blocks until a connection has been established.</li>
<li><a href="qabstractsocket.html#waitForReadyRead">waitForReadyRead</a>()
blocks until new data is available for reading.</li>
<li><a href="qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>()
blocks until one payload of data has been written to the
socket.</li>
<li><a href="qabstractsocket.html#waitForDisconnected">waitForDisconnected</a>()
blocks until the connection has closed.</li>
</ul>
<p>We show an example:</p>
<pre class="cpp">
     <span class="type">int</span> numRead <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> numReadTotal <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">char</span> buffer<span class="operator">[</span><span class="number">50</span><span class="operator">]</span>;

     forever {
         numRead  <span class="operator">=</span> socket<span class="operator">.</span>read(buffer<span class="operator">,</span> <span class="number">50</span>);

         <span class="comment">// do whatever with array</span>

         numReadTotal <span class="operator">+</span><span class="operator">=</span> numRead;
         <span class="keyword">if</span> (numRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>socket<span class="operator">.</span>waitForReadyRead())
             <span class="keyword">break</span>;
     }
</pre>
<p>If <a href="qiodevice.html#waitForReadyRead">waitForReadyRead()</a> returns
false, the connection has been closed or an error has occurred.</p>
<p>Programming with a blocking socket is radically different from
programming with a non-blocking socket. A blocking socket doesn't
require an event loop and typically leads to simpler code. However,
in a GUI application, blocking sockets should only be used in
non-GUI threads, to avoid freezing the user interface. See the
<a href="network-fortuneclient.html">network/fortuneclient</a> and
<a href="network-blockingfortuneclient.html">network/blockingfortuneclient</a>
examples for an overview of both approaches.</p>
<p><b>Note:</b> We discourage the use of the blocking functions
together with signals. One of the two possibilities should be
used.</p>
<p>QAbstractSocket can be used with <a href="qtextstream.html">QTextStream</a> and <a href="qdatastream.html">QDataStream</a>'s stream operators
(operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to
be aware of, though: You must make sure that enough data is
available before attempting to read it using
operator&gt;&gt;().</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="NetworkLayerProtocol-enum" />QAbstractSocket.NetworkLayerProtocol</h3><p>This enum describes the network layer protocol values used in
Qt.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.IPv4Protocol</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">IPv4</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.IPv6Protocol</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">IPv6</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownNetworkLayerProtocol</tt></td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">Other than IPv4 and IPv6</td>
</tr>
</table>
<p><b>See also</b> <a href="qhostaddress.html#protocol">QHostAddress.protocol</a>().</p>


<h3 class="fn"><a name="SocketError-enum" />QAbstractSocket.SocketError</h3><p>This enum describes the socket errors that can occur.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ConnectionRefusedError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The connection was refused by the peer (or
timed out).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.RemoteHostClosedError</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The remote host closed the connection. Note
that the client socket (i.e., this socket) will be closed after the
remote close notification has been sent.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.HostNotFoundError</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The host address was not found.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketAccessError</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The socket operation failed because the
application lacked the required privileges.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketResourceError</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The local system ran out of resources (e.g.,
too many sockets).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketTimeoutError</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The socket operation timed out.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.DatagramTooLargeError</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The datagram was larger than the operating
system's limit (which can be as low as 8192 bytes).</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.NetworkError</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">An error occurred with the network (e.g., the
network cable was accidentally plugged out).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.AddressInUseError</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The address specified to <a href="qudpsocket.html#bind">QUdpSocket.bind</a>() is already in use and
was set to be exclusive.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketAddressNotAvailableError</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">The address specified to <a href="qudpsocket.html#bind">QUdpSocket.bind</a>() does not belong to
the host.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnsupportedSocketOperationError</tt></td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">The requested socket operation is not
supported by the local operating system (e.g., lack of IPv6
support).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyAuthenticationRequiredError</tt></td>
<td class="topAlign"><tt>12</tt></td>
<td class="topAlign">The socket is using a proxy, and the proxy
requires authentication.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SslHandshakeFailedError</tt></td>
<td class="topAlign"><tt>13</tt></td>
<td class="topAlign">The SSL/TLS handshake failed, so the
connection was closed (only used in <a href="qsslsocket.html">QSslSocket</a>) (This value was introduced in
4.4.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnfinishedSocketOperationError</tt></td>
<td class="topAlign"><tt>11</tt></td>
<td class="topAlign">Used by QAbstractSocketEngine only, The last
operation attempted has not finished yet (still in progress in the
background). (This value was introduced in 4.4.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionRefusedError</tt></td>
<td class="topAlign"><tt>14</tt></td>
<td class="topAlign">Could not contact the proxy server because the
connection to that server was denied (This value was introduced in
4.5.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionClosedError</tt></td>
<td class="topAlign"><tt>15</tt></td>
<td class="topAlign">The connection to the proxy server was closed
unexpectedly (before the connection to the final peer was
established) (This value was introduced in 4.5.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionTimeoutError</tt></td>
<td class="topAlign"><tt>16</tt></td>
<td class="topAlign">The connection to the proxy server timed out
or the proxy server stopped responding in the authentication phase.
(This value was introduced in 4.5.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyNotFoundError</tt></td>
<td class="topAlign"><tt>17</tt></td>
<td class="topAlign">The proxy address set with <a href="qabstractsocket.html#setProxy">setProxy</a>() (or the application
proxy) was not found. (This value was introduced in 4.5.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyProtocolError</tt></td>
<td class="topAlign"><tt>18</tt></td>
<td class="topAlign">The connection negotiation with the proxy
server because the response from the proxy server could not be
understood. (This value was introduced in 4.5.)</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownSocketError</tt></td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">An unidentified error occurred.</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#error">QAbstractSocket.error</a>().</p>


<h3 class="fn"><a name="SocketOption-enum" />QAbstractSocket.SocketOption</h3><p>This enum represents the options that can be set on a socket. If
desired, they can be set after having received the <a href="qabstractsocket.html#connected">connected</a>() signal from the
socket or after having received a new socket from a <a href="qtcpserver.html">QTcpServer</a>.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.LowDelayOption</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">Try to optimize the socket for low latency.
For a <a href="qtcpsocket.html">QTcpSocket</a> this would set the
TCP_NODELAY option and disable Nagle's algorithm. Set this to 1 to
enable.</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.KeepAliveOption</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">Set this to 1 to enable the SO_KEEPALIVE
socket option</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.MulticastTtlOption</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">Set this to an integer value to set
IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.MulticastLoopbackOption</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">Set this to 1 to enable the IP_MULTICAST_LOOP
(multicast loopback) socket option.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.6.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketOption">QAbstractSocket.setSocketOption</a>()
and <a href="qabstractsocket.html#socketOption">QAbstractSocket.socketOption</a>().</p>


<h3 class="fn"><a name="SocketState-enum" />QAbstractSocket.SocketState</h3><p>This enum describes the different states in which a socket can
be.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnconnectedState</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The socket is not connected.</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.HostLookupState</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The socket is performing a host name
lookup.</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ConnectingState</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The socket has started establishing a
connection.</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ConnectedState</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">A connection is established.</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.BoundState</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The socket is bound to an address and port
(for servers).</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ClosingState</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The socket is about to close (data may still
be waiting to be written).</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ListeningState</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">For internal use only.</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#state">QAbstractSocket.state</a>().</p>


<h3 class="fn"><a name="SocketType-enum" />QAbstractSocket.SocketType</h3><p>This enum describes the transport layer protocol.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.TcpSocket</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">TCP</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.UdpSocket</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">UDP</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownSocketType</tt></td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">Other than TCP and UDP</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#socketType">QAbstractSocket.socketType</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QAbstractSocket" />QAbstractSocket.__init__ (<i>self</i>, <a href="qabstractsocket.html#SocketType-enum">SocketType</a>&#160;<i>socketType</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Creates a new abstract socket of type <i>socketType</i>. The
<i>parent</i> argument is passed to <a href="qobject.html">QObject</a>'s constructor.</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketType">socketType</a>(), <a href="qtcpsocket.html">QTcpSocket</a>, and <a href="qudpsocket.html">QUdpSocket</a>.</p>


<h3 class="fn"><a name="abort" />QAbstractSocket.abort (<i>self</i>)</h3><p>Aborts the current connection and resets the socket. Unlike
<a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>(),
this function immediately closes the socket, discarding any pending
data in the write buffer.</p>
<p><b>See also</b> <a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>()
and <a href="qabstractsocket.html#close">close</a>().</p>


<h3 class="fn"><a name="atEnd" />bool QAbstractSocket.atEnd (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#atEnd">QIODevice.atEnd</a>().</p>
<p>Returns true if no more data is currently available for reading;
otherwise returns false.</p>
<p>This function is most commonly used when reading data from the
socket in a loop. For example:</p>
<pre class="cpp">
  <span class="comment">// This slot is connected to QAbstractSocket.readyRead()</span>
  <span class="type">void</span> SocketClass<span class="operator">.</span>readyReadSlot()
  {
      <span class="keyword">while</span> (<span class="operator">!</span>socket<span class="operator">.</span>atEnd()) {
          <span class="type"><a href="qbytearray.html">QByteArray</a></span> data <span class="operator">=</span> socket<span class="operator">.</span>read(<span class="number">100</span>);
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
      }
  }
</pre>
<p><b>See also</b> <a href="qabstractsocket.html#bytesAvailable">bytesAvailable</a>() and
<a href="qiodevice.html#readyRead">readyRead</a>().</p>


<h3 class="fn"><a name="bytesAvailable" />int QAbstractSocket.bytesAvailable (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#bytesAvailable">QIODevice.bytesAvailable</a>().</p>
<p>Returns the number of incoming bytes that are waiting to be
read.</p>
<p><b>See also</b> <a href="qabstractsocket.html#bytesToWrite">bytesToWrite</a>() and <a href="qiodevice.html#read">read</a>().</p>


<h3 class="fn"><a name="bytesToWrite" />int QAbstractSocket.bytesToWrite (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#bytesToWrite">QIODevice.bytesToWrite</a>().</p>
<p>Returns the number of bytes that are waiting to be written. The
bytes are written when control goes back to the event loop or when
<a href="qabstractsocket.html#flush">flush</a>() is called.</p>
<p><b>See also</b> <a href="qabstractsocket.html#bytesAvailable">bytesAvailable</a>() and
<a href="qabstractsocket.html#flush">flush</a>().</p>


<h3 class="fn"><a name="canReadLine" />bool QAbstractSocket.canReadLine (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#canReadLine">QIODevice.canReadLine</a>().</p>
<p>Returns true if a line of data can be read from the socket;
otherwise returns false.</p>
<p><b>See also</b> <a href="qiodevice.html#readLine">readLine</a>().</p>


<h3 class="fn"><a name="close" />QAbstractSocket.close (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#close">QIODevice.close</a>().</p>
<p>Closes the I/O device for the socket, disconnects the socket's
connection with the host, closes the socket, and resets the name,
address, port number and underlying socket descriptor.</p>
<p>See <a href="qiodevice.html#close">QIODevice.close</a>() for a
description of the actions that occur when an I/O device is
closed.</p>
<p><b>See also</b> <a href="qabstractsocket.html#abort">abort</a>().</p>


<h3 class="fn"><a name="connectToHost" />QAbstractSocket.connectToHost (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>, <a href="qiodevice-openmode.html">QIODevice.OpenMode</a>&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</h3><p>Attempts to make a connection to <i>hostName</i> on the given
<i>port</i>.</p>
<p>The socket is opened in the given <i>openMode</i> and first
enters <a href="qabstractsocket.html#SocketState-enum">HostLookupState</a>, then
performs a host name lookup of <i>hostName</i>. If the lookup
succeeds, <a href="qabstractsocket.html#hostFound">hostFound</a>()
is emitted and <a href="qabstractsocket.html">QAbstractSocket</a>
enters <a href="qabstractsocket.html#SocketState-enum">ConnectingState</a>. It
then attempts to connect to the address or addresses returned by
the lookup. Finally, if a connection is established, <a href="qabstractsocket.html">QAbstractSocket</a> enters <a href="qabstractsocket.html#SocketState-enum">ConnectedState</a> and
emits <a href="qabstractsocket.html#connected">connected</a>().</p>
<p>At any point, the socket can emit <a href="qabstractsocket.html#error">error</a>() to signal that an error
occurred.</p>
<p><i>hostName</i> may be an IP address in string form (e.g.,
"43.195.83.32"), or it may be a host name (e.g., "example.com").
<a href="qabstractsocket.html">QAbstractSocket</a> will do a lookup
only if required. <i>port</i> is in native byte order.</p>
<p><b>See also</b> <a href="qabstractsocket.html#state">state</a>(), <a href="qabstractsocket.html#peerName">peerName</a>(), <a href="qabstractsocket.html#peerAddress">peerAddress</a>(), <a href="qabstractsocket.html#peerPort">peerPort</a>(), and <a href="qabstractsocket.html#waitForConnected">waitForConnected</a>().</p>


<h3 class="fn"><a name="connectToHost-2" />QAbstractSocket.connectToHost (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>address</i>, int&#160;<i>port</i>, <a href="qiodevice-openmode.html">QIODevice.OpenMode</a>&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</h3><p>This is an overloaded function.</p>
<p>Attempts to make a connection to <i>address</i> on port
<i>port</i>.</p>


<h3 class="fn"><a name="connectToHostImplementation" />QAbstractSocket.connectToHostImplementation (<i>self</i>, QString&#160;<i>hostName</i>, int&#160;<i>port</i>, <a href="qiodevice-openmode.html">QIODevice.OpenMode</a>&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</h3><p>This method is also a Qt slot with the C++ signature <tt>void connectToHostImplementation(const QString&amp;,quint16,QIODevice::OpenMode = QIODevice.ReadWrite)</tt>.</p><p>Contains the implementation of <a href="qabstractsocket.html#connectToHost">connectToHost</a>().</p>
<p>Attempts to make a connection to <i>hostName</i> on the given
<i>port</i>. The socket is opened in the given <i>openMode</i>.</p>
<p>This function was introduced in Qt 4.1.</p>


<h3 class="fn"><a name="disconnectFromHost" />QAbstractSocket.disconnectFromHost (<i>self</i>)</h3><p>Attempts to close the socket. If there is pending data waiting
to be written, <a href="qabstractsocket.html">QAbstractSocket</a>
will enter <a href="qabstractsocket.html#SocketState-enum">ClosingState</a> and wait
until all data has been written. Eventually, it will enter <a href="qabstractsocket.html#SocketState-enum">UnconnectedState</a> and
emit the <a href="qabstractsocket.html#disconnected">disconnected</a>() signal.</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost">connectToHost</a>().</p>


<h3 class="fn"><a name="disconnectFromHostImplementation" />QAbstractSocket.disconnectFromHostImplementation (<i>self</i>)</h3><p>This method is also a Qt slot with the C++ signature <tt>void disconnectFromHostImplementation()</tt>.</p><p>Contains the implementation of <a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>().</p>
<p>This function was introduced in Qt 4.1.</p>


<h3 class="fn"><a name="error" /><a href="qabstractsocket.html#SocketError-enum">SocketError</a> QAbstractSocket.error (<i>self</i>)</h3><p>Returns the type of error that last occurred.</p>
<p><b>See also</b> <a href="qabstractsocket.html#state">state</a>()
and <a href="qiodevice.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="flush" />bool QAbstractSocket.flush (<i>self</i>)</h3><p>This function writes as much as possible from the internal write
buffer to the underlying network socket, without blocking. If any
data was written, this function returns true; otherwise false is
returned.</p>
<p>Call this function if you need <a href="qabstractsocket.html">QAbstractSocket</a> to start sending
buffered data immediately. The number of bytes successfully written
depends on the operating system. In most cases, you do not need to
call this function, because <a href="qabstractsocket.html">QAbstractSocket</a> will start sending data
automatically once control goes back to the event loop. In the
absence of an event loop, call <a href="qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>()
instead.</p>
<p><b>See also</b> <a href="qiodevice.html#write">write</a>() and
<a href="qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>().</p>


<h3 class="fn"><a name="isSequential" />bool QAbstractSocket.isSequential (<i>self</i>)</h3><p>Reimplemented from <a href="qiodevice.html#isSequential">QIODevice.isSequential</a>().</p>


<h3 class="fn"><a name="isValid" />bool QAbstractSocket.isValid (<i>self</i>)</h3><p>Returns true if the socket is valid and ready for use; otherwise
returns false.</p>
<p><b>Note:</b> The socket's state must be <a href="qabstractsocket.html#SocketState-enum">ConnectedState</a> before
reading and writing can occur.</p>
<p><b>See also</b> <a href="qabstractsocket.html#state">state</a>().</p>


<h3 class="fn"><a name="localAddress" /><a href="qhostaddress.html">QHostAddress</a> QAbstractSocket.localAddress (<i>self</i>)</h3><p>Returns the host address of the local socket if available;
otherwise returns <a href="qhostaddress.html#SpecialAddress-enum">QHostAddress.Null</a>.</p>
<p>This is normally the main IP address of the host, but can be
<a href="qhostaddress.html#SpecialAddress-enum">QHostAddress.LocalHost</a>
(127.0.0.1) for connections to the local host.</p>
<p><b>See also</b> <a href="qabstractsocket.html#localPort">localPort</a>(), <a href="qabstractsocket.html#peerAddress">peerAddress</a>(), and <a href="qabstractsocket.html#setLocalAddress">setLocalAddress</a>().</p>


<h3 class="fn"><a name="localPort" />int QAbstractSocket.localPort (<i>self</i>)</h3><p>Returns the host port number (in native byte order) of the local
socket if available; otherwise returns 0.</p>
<p><b>See also</b> <a href="qabstractsocket.html#localAddress">localAddress</a>(), <a href="qabstractsocket.html#peerPort">peerPort</a>(), and <a href="qabstractsocket.html#setLocalPort">setLocalPort</a>().</p>


<h3 class="fn"><a name="peerAddress" /><a href="qhostaddress.html">QHostAddress</a> QAbstractSocket.peerAddress (<i>self</i>)</h3><p>Returns the address of the connected peer if the socket is in
<a href="qabstractsocket.html#SocketState-enum">ConnectedState</a>;
otherwise returns <a href="qhostaddress.html#SpecialAddress-enum">QHostAddress.Null</a>.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerName">peerName</a>(), <a href="qabstractsocket.html#peerPort">peerPort</a>(), <a href="qabstractsocket.html#localAddress">localAddress</a>(), and
<a href="qabstractsocket.html#setPeerAddress">setPeerAddress</a>().</p>


<h3 class="fn"><a name="peerName" />QString QAbstractSocket.peerName (<i>self</i>)</h3><p>Returns the name of the peer as specified by <a href="qabstractsocket.html#connectToHost">connectToHost</a>(), or an
empty <a href="qstring.html">QString</a> if <a href="qabstractsocket.html#connectToHost">connectToHost</a>() has not
been called.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress">peerAddress</a>(), <a href="qabstractsocket.html#peerPort">peerPort</a>(), and <a href="qabstractsocket.html#setPeerName">setPeerName</a>().</p>


<h3 class="fn"><a name="peerPort" />int QAbstractSocket.peerPort (<i>self</i>)</h3><p>Returns the port of the connected peer if the socket is in
<a href="qabstractsocket.html#SocketState-enum">ConnectedState</a>;
otherwise returns 0.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress">peerAddress</a>(), <a href="qabstractsocket.html#localPort">localPort</a>(), and <a href="qabstractsocket.html#setPeerPort">setPeerPort</a>().</p>


<h3 class="fn"><a name="proxy" /><a href="qnetworkproxy.html">QNetworkProxy</a> QAbstractSocket.proxy (<i>self</i>)</h3><p>Returns the network proxy for this socket. By default <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.DefaultProxy</a>
is used, which means this socket will query the default proxy
settings for the application.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setProxy">setProxy</a>(), <a href="qnetworkproxy.html">QNetworkProxy</a>, and <a href="qnetworkproxyfactory.html">QNetworkProxyFactory</a>.</p>


<h3 class="fn"><a name="readBufferSize" />int QAbstractSocket.readBufferSize (<i>self</i>)</h3><p>Returns the size of the internal read buffer. This limits the
amount of data that the client can receive before you call <a href="qiodevice.html#read">read</a>() or <a href="qiodevice.html#readAll">readAll</a>().</p>
<p>A read buffer size of 0 (the default) means that the buffer has
no size limit, ensuring that no data is lost.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setReadBufferSize">setReadBufferSize</a>()
and <a href="qiodevice.html#read">read</a>().</p>


<h3 class="fn"><a name="readData" />str QAbstractSocket.readData (<i>self</i>, int&#160;<i>maxlen</i>)</h3><p>Reimplemented from <a href="qiodevice.html#readData">QIODevice.readData</a>().</p>


<h3 class="fn"><a name="readLineData" />str QAbstractSocket.readLineData (<i>self</i>, int&#160;<i>maxlen</i>)</h3><p>Reimplemented from <a href="qiodevice.html#readLineData">QIODevice.readLineData</a>().</p>


<h3 class="fn"><a name="setLocalAddress" />QAbstractSocket.setLocalAddress (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>address</i>)</h3><p>Sets the address on the local side of a connection to
<i>address</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> to change the return
value of the <a href="qabstractsocket.html#localAddress">localAddress</a>() function
after a connection has been established. This feature is commonly
used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local address of the
socket prior to a connection (e.g., <a href="qudpsocket.html#bind">QUdpSocket.bind</a>()).</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#localAddress">localAddress</a>(), <a href="qabstractsocket.html#setLocalPort">setLocalPort</a>(), and
<a href="qabstractsocket.html#setPeerAddress">setPeerAddress</a>().</p>


<h3 class="fn"><a name="setLocalPort" />QAbstractSocket.setLocalPort (<i>self</i>, int&#160;<i>port</i>)</h3><p>Sets the port on the local side of a connection to
<i>port</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> to change the return
value of the <a href="qabstractsocket.html#localPort">localPort</a>() function after a
connection has been established. This feature is commonly used by
proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local port of the
socket prior to a connection (e.g., <a href="qudpsocket.html#bind">QUdpSocket.bind</a>()).</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#localPort">localPort</a>(), <a href="qabstractsocket.html#localAddress">localAddress</a>(), <a href="qabstractsocket.html#setLocalAddress">setLocalAddress</a>(), and
<a href="qabstractsocket.html#setPeerPort">setPeerPort</a>().</p>


<h3 class="fn"><a name="setPeerAddress" />QAbstractSocket.setPeerAddress (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>address</i>)</h3><p>Sets the address of the remote side of the connection to
<i>address</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> to change the return
value of the <a href="qabstractsocket.html#peerAddress">peerAddress</a>() function after
a connection has been established. This feature is commonly used by
proxy connections for virtual connection settings.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress">peerAddress</a>(), <a href="qabstractsocket.html#setPeerPort">setPeerPort</a>(), and <a href="qabstractsocket.html#setLocalAddress">setLocalAddress</a>().</p>


<h3 class="fn"><a name="setPeerName" />QAbstractSocket.setPeerName (<i>self</i>, QString&#160;<i>name</i>)</h3><p>Sets the host name of the remote peer to <i>name</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> to change the return
value of the <a href="qabstractsocket.html#peerName">peerName</a>()
function after a connection has been established. This feature is
commonly used by proxy connections for virtual connection
settings.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerName">peerName</a>().</p>


<h3 class="fn"><a name="setPeerPort" />QAbstractSocket.setPeerPort (<i>self</i>, int&#160;<i>port</i>)</h3><p>Sets the port of the remote side of the connection to
<i>port</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> to change the return
value of the <a href="qabstractsocket.html#peerPort">peerPort</a>()
function after a connection has been established. This feature is
commonly used by proxy connections for virtual connection
settings.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerPort">peerPort</a>(), <a href="qabstractsocket.html#setPeerAddress">setPeerAddress</a>(), and
<a href="qabstractsocket.html#setLocalPort">setLocalPort</a>().</p>


<h3 class="fn"><a name="setProxy" />QAbstractSocket.setProxy (<i>self</i>, <a href="qnetworkproxy.html">QNetworkProxy</a>&#160;<i>networkProxy</i>)</h3><p>Sets the explicit network proxy for this socket to
<i>networkProxy</i>.</p>
<p>To disable the use of a proxy for this socket, use the <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.NoProxy</a>
proxy type:</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span>setProxy(<span class="type"><a href="qnetworkproxy.html">QNetworkProxy</a></span><span class="operator">.</span>NoProxy);
</pre>
<p>The default value for the proxy is <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy.DefaultProxy</a>,
which means the socket will use the application settings: if a
proxy is set with QNetworkProxy.setApplicationProxy, it will use
that; otherwise, if a factory is set with
QNetworkProxyFactory.setApplicationProxyFactory, it will query
that factory with type <a href="qnetworkproxyquery.html#QueryType-enum">QNetworkProxyQuery.TcpSocket</a>.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also</b> <a href="qabstractsocket.html#proxy">proxy</a>(), <a href="qnetworkproxy.html">QNetworkProxy</a>, and <a href="qnetworkproxyfactory.html#queryProxy">QNetworkProxyFactory.queryProxy</a>().</p>


<h3 class="fn"><a name="setReadBufferSize" />QAbstractSocket.setReadBufferSize (<i>self</i>, int&#160;<i>size</i>)</h3><p>Sets the size of <a href="qabstractsocket.html">QAbstractSocket</a>'s internal read buffer
to be <i>size</i> bytes.</p>
<p>If the buffer size is limited to a certain size, <a href="qabstractsocket.html">QAbstractSocket</a> won't buffer more than
this size of data. Exceptionally, a buffer size of 0 means that the
read buffer is unlimited and all incoming data is buffered. This is
the default.</p>
<p>This option is useful if you only read the data at certain
points in time (e.g., in a real-time streaming application) or if
you want to protect your socket against receiving too much data,
which may eventually cause your application to run out of
memory.</p>
<p>Only <a href="qtcpsocket.html">QTcpSocket</a> uses <a href="qabstractsocket.html">QAbstractSocket</a>'s internal buffer;
<a href="qudpsocket.html">QUdpSocket</a> does not use any buffering
at all, but rather relies on the implicit buffering provided by the
operating system. Because of this, calling this function on
<a href="qudpsocket.html">QUdpSocket</a> has no effect.</p>
<p><b>See also</b> <a href="qabstractsocket.html#readBufferSize">readBufferSize</a>() and
<a href="qiodevice.html#read">read</a>().</p>


<h3 class="fn"><a name="setSocketDescriptor" />bool QAbstractSocket.setSocketDescriptor (<i>self</i>, int&#160;<i>socketDescriptor</i>, <a href="qabstractsocket.html#SocketState-enum">SocketState</a>&#160;<i>state</i>&#160;=&#160;QAbstractSocket.ConnectedState, <a href="qiodevice-openmode.html">QIODevice.OpenMode</a>&#160;<i>mode</i>&#160;=&#160;QIODevice.ReadWrite)</h3><p>Initializes <a href="qabstractsocket.html">QAbstractSocket</a>
with the native socket descriptor <i>socketDescriptor</i>. Returns
true if <i>socketDescriptor</i> is accepted as a valid socket
descriptor; otherwise returns false. The socket is opened in the
mode specified by <i>openMode</i>, and enters the socket state
specified by <i>socketState</i>.</p>
<p><b>Note:</b> It is not possible to initialize two abstract
sockets with the same native socket descriptor.</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketDescriptor">socketDescriptor</a>().</p>


<h3 class="fn"><a name="setSocketError" />QAbstractSocket.setSocketError (<i>self</i>, <a href="qabstractsocket.html#SocketError-enum">SocketError</a>&#160;<i>socketError</i>)</h3><p>Sets the type of error that last occurred to
<i>socketError</i>.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketState">setSocketState</a>() and
<a href="qiodevice.html#setErrorString">setErrorString</a>().</p>


<h3 class="fn"><a name="setSocketOption" />QAbstractSocket.setSocketOption (<i>self</i>, <a href="qabstractsocket.html#SocketOption-enum">SocketOption</a>&#160;<i>option</i>, QVariant&#160;<i>value</i>)</h3><p>Sets the given <i>option</i> to the value described by
<i>value</i>.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketOption">socketOption</a>().</p>


<h3 class="fn"><a name="setSocketState" />QAbstractSocket.setSocketState (<i>self</i>, <a href="qabstractsocket.html#SocketState-enum">SocketState</a>&#160;<i>state</i>)</h3><p>Sets the state of the socket to <i>state</i>.</p>
<p><b>See also</b> <a href="qabstractsocket.html#state">state</a>().</p>


<h3 class="fn"><a name="socketDescriptor" />int QAbstractSocket.socketDescriptor (<i>self</i>)</h3><p>Returns the native socket descriptor of the <a href="qabstractsocket.html">QAbstractSocket</a> object if this is
available; otherwise returns -1.</p>
<p>If the socket is using <a href="qnetworkproxy.html">QNetworkProxy</a>, the returned descriptor may
not be usable with native socket functions.</p>
<p>The socket descriptor is not available when <a href="qabstractsocket.html">QAbstractSocket</a> is in <a href="qabstractsocket.html#SocketState-enum">UnconnectedState</a>.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a>().</p>


<h3 class="fn"><a name="socketOption" />QVariant QAbstractSocket.socketOption (<i>self</i>, <a href="qabstractsocket.html#SocketOption-enum">SocketOption</a>&#160;<i>option</i>)</h3><p>Returns the value of the <i>option</i> option.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketOption">setSocketOption</a>().</p>


<h3 class="fn"><a name="socketType" /><a href="qabstractsocket.html#SocketType-enum">SocketType</a> QAbstractSocket.socketType (<i>self</i>)</h3><p>Returns the socket type (TCP, UDP, or other).</p>
<p><b>See also</b> <a href="qtcpsocket.html">QTcpSocket</a> and
<a href="qudpsocket.html">QUdpSocket</a>.</p>


<h3 class="fn"><a name="state" /><a href="qabstractsocket.html#SocketState-enum">SocketState</a> QAbstractSocket.state (<i>self</i>)</h3><p>Returns the state of the socket.</p>
<p><b>See also</b> <a href="qabstractsocket.html#error">error</a>().</p>


<h3 class="fn"><a name="waitForBytesWritten" />bool QAbstractSocket.waitForBytesWritten (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</h3><p>Reimplemented from <a href="qiodevice.html#waitForBytesWritten">QIODevice.waitForBytesWritten</a>().</p>


<h3 class="fn"><a name="waitForConnected" />bool QAbstractSocket.waitForConnected (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</h3><p>Waits until the socket is connected, up to <i>msecs</i>
milliseconds. If the connection has been established, this function
returns true; otherwise it returns false. In the case where it
returns false, you can call <a href="qabstractsocket.html#error">error</a>() to determine the cause of
the error.</p>
<p>The following example waits up to one second for a connection to
be established:</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span><a href="qabstractsocket.html#connectToHost">connectToHost</a>(<span class="string">"imap"</span><span class="operator">,</span> <span class="number">143</span>);
 <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>waitForConnected(<span class="number">1000</span>))
     <a href="qtcore.html#qDebug">qDebug</a>(<span class="string">"Connected!"</span>);
</pre>
<p>If msecs is -1, this function will not time out.</p>
<p><b>Note:</b> This function may wait slightly longer than
<i>msecs</i>, depending on the time it takes to complete the host
lookup.</p>
<p><b>Note:</b> Multiple calls to this functions do not accumulate
the time. If the function times out, the connecting process will be
aborted.</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost">connectToHost</a>() and
<a href="qabstractsocket.html#connected">connected</a>().</p>


<h3 class="fn"><a name="waitForDisconnected" />bool QAbstractSocket.waitForDisconnected (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</h3><p>Waits until the socket has disconnected, up to <i>msecs</i>
milliseconds. If the connection has been disconnected, this
function returns true; otherwise it returns false. In the case
where it returns false, you can call <a href="qabstractsocket.html#error">error</a>() to determine the cause of
the error.</p>
<p>The following example waits up to one second for a connection to
be closed:</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span><a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>();
     <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>state() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qabstractsocket.html">QAbstractSocket</a></span><span class="operator">.</span>UnconnectedState <span class="operator">|</span><span class="operator">|</span>
         socket<span class="operator">-</span><span class="operator">&gt;</span>waitForDisconnected(<span class="number">1000</span>))
         <a href="qtcore.html#qDebug">qDebug</a>(<span class="string">"Disconnected!"</span>);
</pre>
<p>If msecs is -1, this function will not time out.</p>
<p><b>See also</b> <a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>()
and <a href="qabstractsocket.html#close">close</a>().</p>


<h3 class="fn"><a name="waitForReadyRead" />bool QAbstractSocket.waitForReadyRead (<i>self</i>, int&#160;<i>msecs</i>&#160;=&#160;30000)</h3><p>Reimplemented from <a href="qiodevice.html#waitForReadyRead">QIODevice.waitForReadyRead</a>().</p>
<p>This function blocks until new data is available for reading and
the <a href="qiodevice.html#readyRead">readyRead()</a> signal has
been emitted. The function will timeout after <i>msecs</i>
milliseconds; the default timeout is 30000 milliseconds.</p>
<p>The function returns true if the <a href="qiodevice.html#readyRead">readyRead</a>() signal is emitted and
there is new data available for reading; otherwise it returns false
(if an error occurred or the operation timed out).</p>
<p><b>See also</b> <a href="qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>().</p>


<h3 class="fn"><a name="writeData" />int QAbstractSocket.writeData (<i>self</i>, str&#160;<i>data</i>)</h3><p>Reimplemented from <a href="qiodevice.html#writeData">QIODevice.writeData</a>().</p>
<hr /><h2>Qt Signal Documentation</h2><h3 class="fn"><a name="connected" />void connected ()</h3><p>This is the default overload of this signal.</p><p>This signal is emitted after <a href="qabstractsocket.html#connectToHost">connectToHost</a>() has been
called and a connection has been successfully established.</p>
<p><b>Note:</b> On some operating systems the connected() signal
may be directly emitted from the <a href="qabstractsocket.html#connectToHost">connectToHost</a>() call for
connections to the localhost.</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost">connectToHost</a>() and
<a href="qabstractsocket.html#disconnected">disconnected</a>().</p>


<h3 class="fn"><a name="disconnected" />void disconnected ()</h3><p>This is the default overload of this signal.</p><p>This signal is emitted when the socket has been
disconnected.</p>
<p><b>Warning:</b> If you need to delete the <a href="qobject.html#sender">sender</a>() of this signal in a slot
connected to it, use the <a href="qobject.html#deleteLater">deleteLater()</a> function.</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost">connectToHost</a>(), <a href="qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>(),
and <a href="qabstractsocket.html#abort">abort</a>().</p>


<h3 class="fn"><a name="error-2" />void error (QAbstractSocket::SocketError)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted after an error occurred. The
<i>socketError</i> parameter describes the type of error that
occurred.</p>
<p><a href="qabstractsocket.html#SocketError-enum">QAbstractSocket.SocketError</a>
is not a registered metatype, so for queued connections, you will
have to register it with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() and
<a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>().</p>
<p><b>See also</b> <a href="qabstractsocket.html#error">error</a>(), <a href="qiodevice.html#errorString">errorString</a>(), and <a href="custom-types.html">Creating Custom Qt Types</a>.</p>


<h3 class="fn"><a name="hostFound" />void hostFound ()</h3><p>This is the default overload of this signal.</p><p>This signal is emitted after <a href="qabstractsocket.html#connectToHost">connectToHost</a>() has been
called and the host lookup has succeeded.</p>
<p><b>Note:</b> Since Qt 4.6.3 <a href="qabstractsocket.html">QAbstractSocket</a> may emit hostFound()
directly from the <a href="qabstractsocket.html#connectToHost">connectToHost</a>() call since
a DNS result could have been cached.</p>
<p><b>See also</b> <a href="qabstractsocket.html#connected">connected</a>().</p>


<h3 class="fn"><a name="proxyAuthenticationRequired" />void proxyAuthenticationRequired (const QNetworkProxy&amp;,QAuthenticator *)</h3><p>This is the default overload of this signal.</p><p>This signal can be emitted when a <i>proxy</i> that requires
authentication is used. The <i>authenticator</i> object can then be
filled in with the required details to allow authentication and
continue the connection.</p>
<p><b>Note:</b> It is not possible to use a QueuedConnection to
connect to this signal, as the connection will fail if the
authenticator has not been filled in with new information when the
signal returns.</p>
<p>This function was introduced in Qt 4.3.</p>
<p><b>See also</b> <a href="qauthenticator.html">QAuthenticator</a>
and <a href="qnetworkproxy.html">QNetworkProxy</a>.</p>


<h3 class="fn"><a name="stateChanged" />void stateChanged (QAbstractSocket::SocketState)</h3><p>This is the default overload of this signal.</p><p>This signal is emitted whenever <a href="qabstractsocket.html">QAbstractSocket</a>'s state changes. The
<i>socketState</i> parameter is the new state.</p>
<p><a href="qabstractsocket.html#SocketState-enum">QAbstractSocket.SocketState</a>
is not a registered metatype, so for queued connections, you will
have to register it with Q_REGISTER_METATYPE() and <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>().</p>
<p><b>See also</b> <a href="qabstractsocket.html#state">state</a>()
and <a href="custom-types.html">Creating Custom Qt Types</a>.</p>


<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>