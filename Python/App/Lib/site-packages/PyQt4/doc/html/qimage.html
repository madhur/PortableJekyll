<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QImage Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QImage Class Reference<br /><sup><sup>[<a href="qtgui.html">QtGui</a> module]</sup></sup></h1><p>The QImage class provides a hardware-independent image
representation that allows direct access to the pixel data, and can
be used as a paint device. <a href="#details">More...</a></p>

<p>Inherits <a href="qpaintdevice.html">QPaintDevice</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qimage.html#Format-enum">Format</a></b> { Format_Invalid, Format_Mono, Format_MonoLSB, Format_Indexed8, ..., Format_ARGB4444_Premultiplied }</li><li><div class="fn" />enum <b><a href="qimage.html#InvertMode-enum">InvertMode</a></b> { InvertRgb, InvertRgba }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qimage.html#QImage">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-2">__init__</a></b> (<i>self</i>, QSize&#160;<i>size</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-3">__init__</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-4">__init__</a></b> (<i>self</i>, str&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-5">__init__</a></b> (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-6">__init__</a></b> (<i>self</i>, str&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>bytesPerLine</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-7">__init__</a></b> (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>bytesPerLine</i>, Format&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-8">__init__</a></b> (<i>self</i>, list-of-str&#160;<i>xpm</i>)</li><li><div class="fn" /><b><a href="qimage.html#QImage-9">__init__</a></b> (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" /><b><a href="qimage.html#QImage-10">__init__</a></b> (<i>self</i>, QImage)</li><li><div class="fn" /><b><a href="qimage.html#QImage-11">__init__</a></b> (<i>self</i>, QVariant&#160;<i>variant</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#allGray">allGray</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qimage.html#alphaChannel">alphaChannel</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#bitPlaneCount">bitPlaneCount</a></b> (<i>self</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qimage.html#bits">bits</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#byteCount">byteCount</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#bytesPerLine">bytesPerLine</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#cacheKey">cacheKey</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#color">color</a></b> (<i>self</i>, int&#160;<i>i</i>)</li><li><div class="fn" />int <b><a href="qimage.html#colorCount">colorCount</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-int <b><a href="qimage.html#colorTable">colorTable</a></b> (<i>self</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qimage.html#constBits">constBits</a></b> (<i>self</i>)</li><li><div class="fn" />sip.voidptr <b><a href="qimage.html#constScanLine">constScanLine</a></b> (<i>self</i>, int)</li><li><div class="fn" />QImage <b><a href="qimage.html#convertToFormat">convertToFormat</a></b> (<i>self</i>, Format&#160;<i>format</i>, Qt.ImageConversionFlags&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</li><li><div class="fn" />QImage <b><a href="qimage.html#convertToFormat-2">convertToFormat</a></b> (<i>self</i>, Format&#160;<i>format</i>, list-of-int&#160;<i>colorTable</i>, Qt.ImageConversionFlags&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</li><li><div class="fn" />QImage <b><a href="qimage.html#copy">copy</a></b> (<i>self</i>, QRect&#160;<i>rect</i>&#160;=&#160;QRect())</li><li><div class="fn" />QImage <b><a href="qimage.html#copy-2">copy</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" />QImage <b><a href="qimage.html#createAlphaMask">createAlphaMask</a></b> (<i>self</i>, Qt.ImageConversionFlags&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</li><li><div class="fn" />QImage <b><a href="qimage.html#createHeuristicMask">createHeuristicMask</a></b> (<i>self</i>, bool&#160;<i>clipTight</i>&#160;=&#160;True)</li><li><div class="fn" />QImage <b><a href="qimage.html#createMaskFromColor">createMaskFromColor</a></b> (<i>self</i>, int&#160;<i>color</i>, Qt.MaskMode&#160;<i>mode</i>&#160;=&#160;Qt.MaskInColor)</li><li><div class="fn" />int <b><a href="qimage.html#depth">depth</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#detach">detach</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#devType">devType</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#dotsPerMeterX">dotsPerMeterX</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#dotsPerMeterY">dotsPerMeterY</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#fill">fill</a></b> (<i>self</i>, Qt.GlobalColor&#160;<i>color</i>)</li><li><div class="fn" /><b><a href="qimage.html#fill-2">fill</a></b> (<i>self</i>, QColor&#160;<i>color</i>)</li><li><div class="fn" /><b><a href="qimage.html#fill-3">fill</a></b> (<i>self</i>, int&#160;<i>pixel</i>)</li><li><div class="fn" />Format <b><a href="qimage.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#hasAlphaChannel">hasAlphaChannel</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#height">height</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#invertPixels">invertPixels</a></b> (<i>self</i>, InvertMode&#160;<i>mode</i>&#160;=&#160;QImage.InvertRgb)</li><li><div class="fn" />bool <b><a href="qimage.html#isDetached">isDetached</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#isGrayscale">isGrayscale</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#isNull">isNull</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#load">load</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>, str&#160;<i>format</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#load-2">load</a></b> (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" />bool <b><a href="qimage.html#loadFromData">loadFromData</a></b> (<i>self</i>, str&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" />bool <b><a href="qimage.html#loadFromData-2">loadFromData</a></b> (<i>self</i>, QByteArray&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" />int <b><a href="qimage.html#metric">metric</a></b> (<i>self</i>, QPaintDevice.PaintDeviceMetric&#160;<i>metric</i>)</li><li><div class="fn" />QImage <b><a href="qimage.html#mirrored">mirrored</a></b> (<i>self</i>, bool&#160;<i>horizontal</i>&#160;=&#160;False, bool&#160;<i>vertical</i>&#160;=&#160;True)</li><li><div class="fn" />int <b><a href="qimage.html#numBytes">numBytes</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#numColors">numColors</a></b> (<i>self</i>)</li><li><div class="fn" />QPoint <b><a href="qimage.html#offset">offset</a></b> (<i>self</i>)</li><li><div class="fn" />QPaintEngine <b><a href="qimage.html#paintEngine">paintEngine</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qimage.html#pixel">pixel</a></b> (<i>self</i>, QPoint&#160;<i>pt</i>)</li><li><div class="fn" />int <b><a href="qimage.html#pixel-2">pixel</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</li><li><div class="fn" />int <b><a href="qimage.html#pixelIndex">pixelIndex</a></b> (<i>self</i>, QPoint&#160;<i>pt</i>)</li><li><div class="fn" />int <b><a href="qimage.html#pixelIndex-2">pixelIndex</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</li><li><div class="fn" />QRect <b><a href="qimage.html#rect">rect</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qimage.html#rgbSwapped">rgbSwapped</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#save">save</a></b> (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None, int&#160;<i>quality</i>&#160;=&#160;-1)</li><li><div class="fn" />bool <b><a href="qimage.html#save-2">save</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>, str&#160;<i>format</i>&#160;=&#160;None, int&#160;<i>quality</i>&#160;=&#160;-1)</li><li><div class="fn" />QImage <b><a href="qimage.html#scaled">scaled</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, Qt.AspectRatioMode&#160;<i>aspectRatioMode</i>&#160;=&#160;Qt.IgnoreAspectRatio, Qt.TransformationMode&#160;<i>transformMode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />QImage <b><a href="qimage.html#scaled-2">scaled</a></b> (<i>self</i>, QSize&#160;<i>size</i>, Qt.AspectRatioMode&#160;<i>aspectRatioMode</i>&#160;=&#160;Qt.IgnoreAspectRatio, Qt.TransformationMode&#160;<i>transformMode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />QImage <b><a href="qimage.html#scaledToHeight">scaledToHeight</a></b> (<i>self</i>, int&#160;<i>height</i>, Qt.TransformationMode&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />QImage <b><a href="qimage.html#scaledToWidth">scaledToWidth</a></b> (<i>self</i>, int&#160;<i>width</i>, Qt.TransformationMode&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />sip.voidptr <b><a href="qimage.html#scanLine">scanLine</a></b> (<i>self</i>, int)</li><li><div class="fn" />int <b><a href="qimage.html#serialNumber">serialNumber</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#setAlphaChannel">setAlphaChannel</a></b> (<i>self</i>, QImage&#160;<i>alphaChannel</i>)</li><li><div class="fn" /><b><a href="qimage.html#setColor">setColor</a></b> (<i>self</i>, int&#160;<i>i</i>, int&#160;<i>c</i>)</li><li><div class="fn" /><b><a href="qimage.html#setColorCount">setColorCount</a></b> (<i>self</i>, int)</li><li><div class="fn" /><b><a href="qimage.html#setColorTable">setColorTable</a></b> (<i>self</i>, list-of-int&#160;<i>colors</i>)</li><li><div class="fn" /><b><a href="qimage.html#setDotsPerMeterX">setDotsPerMeterX</a></b> (<i>self</i>, int)</li><li><div class="fn" /><b><a href="qimage.html#setDotsPerMeterY">setDotsPerMeterY</a></b> (<i>self</i>, int)</li><li><div class="fn" /><b><a href="qimage.html#setNumColors">setNumColors</a></b> (<i>self</i>, int)</li><li><div class="fn" /><b><a href="qimage.html#setOffset">setOffset</a></b> (<i>self</i>, QPoint)</li><li><div class="fn" /><b><a href="qimage.html#setPixel">setPixel</a></b> (<i>self</i>, QPoint&#160;<i>pt</i>, int&#160;<i>index_or_rgb</i>)</li><li><div class="fn" /><b><a href="qimage.html#setPixel-2">setPixel</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>index_or_rgb</i>)</li><li><div class="fn" /><b><a href="qimage.html#setText">setText</a></b> (<i>self</i>, QString&#160;<i>key</i>, QString&#160;<i>value</i>)</li><li><div class="fn" />QSize <b><a href="qimage.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qimage.html#swap">swap</a></b> (<i>self</i>, QImage&#160;<i>other</i>)</li><li><div class="fn" />QString <b><a href="qimage.html#text">text</a></b> (<i>self</i>, QString&#160;<i>key</i>&#160;=&#160;QString())</li><li><div class="fn" />QStringList <b><a href="qimage.html#textKeys">textKeys</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qimage.html#transformed">transformed</a></b> (<i>self</i>, QMatrix&#160;<i>matrix</i>, Qt.TransformationMode&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />QImage <b><a href="qimage.html#transformed-2">transformed</a></b> (<i>self</i>, QTransform&#160;<i>matrix</i>, Qt.TransformationMode&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</li><li><div class="fn" />bool <b><a href="qimage.html#valid">valid</a></b> (<i>self</i>, QPoint&#160;<i>pt</i>)</li><li><div class="fn" />bool <b><a href="qimage.html#valid-2">valid</a></b> (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</li><li><div class="fn" />int <b><a href="qimage.html#width">width</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QImage <b><a href="qimage.html#fromData">fromData</a></b> (str&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" />QImage <b><a href="qimage.html#fromData-2">fromData</a></b> (QByteArray&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</li><li><div class="fn" />QMatrix <b><a href="qimage.html#trueMatrix">trueMatrix</a></b> (QMatrix, int&#160;<i>w</i>, int&#160;<i>h</i>)</li><li><div class="fn" />QTransform <b><a href="qimage.html#trueMatrix-2">trueMatrix</a></b> (QTransform, int&#160;<i>w</i>, int&#160;<i>h</i>)</li></ul><h3>Special Methods</h3><ul><li><div class="fn" />bool <b><a href="qimage.html#__eq__">__eq__</a></b> (<i>self</i>, QImage)</li><li><div class="fn" />bool <b><a href="qimage.html#__ne__">__ne__</a></b> (<i>self</i>, QImage)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QImage class provides a hardware-independent image
representation that allows direct access to the pixel data, and can
be used as a paint device.</p>
<p>Qt provides four classes for handling image data: QImage,
<a href="qpixmap.html">QPixmap</a>, <a href="qbitmap.html">QBitmap</a> and <a href="qpicture.html">QPicture</a>. QImage is designed and optimized for
I/O, and for direct pixel access and manipulation, while <a href="qpixmap.html">QPixmap</a> is designed and optimized for showing
images on screen. <a href="qbitmap.html">QBitmap</a> is only a
convenience class that inherits <a href="qpixmap.html">QPixmap</a>,
ensuring a depth of 1. Finally, the <a href="qpicture.html">QPicture</a> class is a paint device that records
and replays <a href="qpainter.html">QPainter</a> commands.</p>
<p>Because QImage is a <a href="qpaintdevice.html">QPaintDevice</a>
subclass, <a href="qpainter.html">QPainter</a> can be used to draw
directly onto images. When using <a href="qpainter.html">QPainter</a> on a QImage, the painting can be
performed in another thread than the current GUI thread.</p>
<p>The QImage class supports several image formats described by the
<a href="qimage.html#Format-enum">Format</a> enum. These include
monochrome, 8-bit, 32-bit and alpha-blended images which are
available in all versions of Qt 4.x.</p>
<p>QImage provides a collection of functions that can be used to
obtain a variety of information about the image. There are also
several functions that enables transformation of the image.</p>
<p>QImage objects can be passed around by value since the QImage
class uses <a href="implicit-sharing.html#implicit-data-sharing">implicit data
sharing</a>. QImage objects can also be streamed and compared.</p>
<p><b>Note:</b> If you would like to load QImage objects in a
static build of Qt, refer to the <a href="plugins-howto.html#static-plugins">Plugin HowTo</a>.</p>
<p><b>Warning:</b> Painting on a QImage with the format <a href="qimage.html#Format-enum">QImage.Format_Indexed8</a> is not
supported.</p>
<a id="reading-and-writing-image-files" name="reading-and-writing-image-files" />
<h3>Reading and Writing Image Files</h3>
<p>QImage provides several ways of loading an image file: The file
can be loaded when constructing the QImage object, or by using the
<a href="qimage.html#load">load</a>() or <a href="qimage.html#loadFromData">loadFromData</a>() functions later on.
QImage also provides the static <a href="qimage.html#fromData">fromData</a>() function, constructing a
QImage from the given data. When loading an image, the file name
can either refer to an actual file on disk or to one of the
application's embedded resources. See <a href="resources.html">The
Qt Resource System</a> overview for details on how to embed images
and other resource files in the application's executable.</p>
<p>Simply call the <a href="qimage.html#save">save</a>() function
to save a QImage object.</p>
<p>The complete list of supported file formats are available
through the <a href="qimagereader.html#supportedImageFormats">QImageReader.supportedImageFormats</a>()
and <a href="qimagewriter.html#supportedImageFormats">QImageWriter.supportedImageFormats</a>()
functions. New file formats can be added as plugins. By default, Qt
supports the following formats:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th>Format</th>
<th>Description</th>
<th>Qt's support</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td>BMP</td>
<td>Windows Bitmap</td>
<td>Read/write</td>
</tr>
<tr class="even" valign="top">
<td>GIF</td>
<td>Graphic Interchange Format (optional)</td>
<td>Read</td>
</tr>
<tr class="odd" valign="top">
<td>JPG</td>
<td>Joint Photographic Experts Group</td>
<td>Read/write</td>
</tr>
<tr class="even" valign="top">
<td>JPEG</td>
<td>Joint Photographic Experts Group</td>
<td>Read/write</td>
</tr>
<tr class="odd" valign="top">
<td>PNG</td>
<td>Portable Network Graphics</td>
<td>Read/write</td>
</tr>
<tr class="even" valign="top">
<td>PBM</td>
<td>Portable Bitmap</td>
<td>Read</td>
</tr>
<tr class="odd" valign="top">
<td>PGM</td>
<td>Portable Graymap</td>
<td>Read</td>
</tr>
<tr class="even" valign="top">
<td>PPM</td>
<td>Portable Pixmap</td>
<td>Read/write</td>
</tr>
<tr class="odd" valign="top">
<td>TIFF</td>
<td>Tagged Image File Format</td>
<td>Read/write</td>
</tr>
<tr class="even" valign="top">
<td>XBM</td>
<td>X11 Bitmap</td>
<td>Read/write</td>
</tr>
<tr class="odd" valign="top">
<td>XPM</td>
<td>X11 Pixmap</td>
<td>Read/write</td>
</tr>
</table>
<a id="image-information" name="image-information" />
<h3>Image Information</h3>
<p>QImage provides a collection of functions that can be used to
obtain a variety of information about the image:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th />
<th>Available Functions</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td>Geometry</td>
<td>The <a href="qimage.html#size">size</a>(), <a href="qimage.html#width">width</a>(), <a href="qimage.html#height">height</a>(), <a href="qimage.html#dotsPerMeterX">dotsPerMeterX</a>(), and <a href="qimage.html#dotsPerMeterY">dotsPerMeterY</a>() functions provide
information about the image size and aspect ratio.
<p>The <a href="qimage.html#rect">rect</a>() function returns the
image's enclosing rectangle. The <a href="qimage.html#valid">valid</a>() function tells if a given pair of
coordinates is within this rectangle. The <a href="qimage.html#offset">offset</a>() function returns the number of
pixels by which the image is intended to be offset by when
positioned relative to other images, which also can be manipulated
using the <a href="qimage.html#setOffset">setOffset</a>()
function.</p>
</td>
</tr>
<tr class="even" valign="top">
<td>Colors</td>
<td>The color of a pixel can be retrieved by passing its
coordinates to the <a href="qimage.html#pixel">pixel</a>()
function. The <a href="qimage.html#pixel">pixel</a>() function
returns the color as a <a href="qcolor.html#QRgb-typedef">QRgb</a>
value indepedent of the image's format.
<p>In case of monochrome and 8-bit images, the <a href="qimage.html#colorCount">colorCount</a>() and <a href="qimage.html#colorTable">colorTable</a>() functions provide
information about the color components used to store the image
data: The <a href="qimage.html#colorTable">colorTable</a>()
function returns the image's entire color table. To obtain a single
entry, use the <a href="qimage.html#pixelIndex">pixelIndex</a>()
function to retrieve the pixel index for a given pair of
coordinates, then use the <a href="qimage.html#color">color</a>()
function to retrieve the color. Note that if you create an 8-bit
image manually, you have to set a valid color table on the image as
well.</p>
<p>The <a href="qimage.html#hasAlphaChannel">hasAlphaChannel</a>()
function tells if the image's format respects the alpha channel, or
not. The <a href="qimage.html#allGray">allGray</a>() and <a href="qimage.html#isGrayscale">isGrayscale</a>() functions tell whether
an image's colors are all shades of gray.</p>
<p>See also the <a href="#pixel-manipulation">Pixel
Manipulation</a> and <a href="#image-transformations">Image
Transformations</a> sections.</p>
</td>
</tr>
<tr class="odd" valign="top">
<td>Text</td>
<td>The <a href="qimage.html#text">text</a>() function returns the
image text associated with the given text key. An image's text keys
can be retrieved using the <a href="qimage.html#textKeys">textKeys</a>() function. Use the <a href="qimage.html#setText">setText</a>() function to alter an image's
text.</td>
</tr>
<tr class="even" valign="top">
<td>Low-level information</td>
<td>The <a href="qimage.html#depth">depth</a>() function returns
the depth of the image. The supported depths are 1 (monochrome), 8,
16, 24 and 32 bits. The <a href="qimage.html#bitPlaneCount">bitPlaneCount</a>() function tells how
many of those bits that are used. For more information see the
<a href="#image-formats">Image Formats</a> section.
<p>The <a href="qimage.html#format">format</a>(), <a href="qimage.html#bytesPerLine">bytesPerLine</a>(), and <a href="qimage.html#byteCount">byteCount</a>() functions provide low-level
information about the data stored in the image.</p>
<p>The <a href="qimage.html#cacheKey">cacheKey</a>() function
returns a number that uniquely identifies the contents of this
QImage object.</p>
</td>
</tr>
</table>
<a id="pixel-manipulation" name="pixel-manipulation" />
<h3>Pixel Manipulation</h3>
<p>The functions used to manipulate an image's pixels depend on the
image format. The reason is that monochrome and 8-bit images are
index-based and use a color lookup table, while 32-bit images store
ARGB values directly. For more information on image formats, see
the <a href="#image-formats">Image Formats</a> section.</p>
<p>In case of a 32-bit image, the <a href="qimage.html#setPixel">setPixel</a>() function can be used to alter
the color of the pixel at the given coordinates to any other color
specified as an ARGB quadruplet. To make a suitable <a href="qcolor.html#QRgb-typedef">QRgb</a> value, use the <a href="qtgui.html#qRgb">qRgb</a>() (adding a default alpha component to
the given RGB values, i.e. creating an opaque color) or <a href="qtgui.html#qRgba">qRgba</a>() function. For example:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th colspan="2">32-bit</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td><img alt="" src="images/qimage-32bit_scaled.png" /></td>
<td>
<pre class="cpp">
 <span class="type">QImage</span> image(<span class="number">3</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="type">QImage</span><span class="operator">.</span>Format_RGB32);
 <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> value;

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">189</span><span class="operator">,</span> <span class="number">149</span><span class="operator">,</span> <span class="number">39</span>); <span class="comment">// 0xffbd9527</span>
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> value);

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">122</span><span class="operator">,</span> <span class="number">163</span><span class="operator">,</span> <span class="number">39</span>); <span class="comment">// 0xff7aa327</span>
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> value);
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> value);

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">237</span><span class="operator">,</span> <span class="number">187</span><span class="operator">,</span> <span class="number">51</span>); <span class="comment">// 0xffedba31</span>
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> value);
</pre></td>
</tr>
</table>
<p>In case of a 8-bit and monchrome images, the pixel value is only
an index from the image's color table. So the <a href="qimage.html#setPixel">setPixel</a>() function can only be used to
alter the color of the pixel at the given coordinates to a
predefined color from the image's color table, i.e. it can only
change the pixel's index value. To alter or add a color to an
image's color table, use the <a href="qimage.html#setColor">setColor</a>() function.</p>
<p>An entry in the color table is an ARGB quadruplet encoded as an
<a href="qcolor.html#QRgb-typedef">QRgb</a> value. Use the <a href="qtgui.html#qRgb">qRgb</a>() and <a href="qtgui.html#qRgba">qRgba</a>() functions to make a suitable
<a href="qcolor.html#QRgb-typedef">QRgb</a> value for use with the
<a href="qimage.html#setColor">setColor</a>() function. For
example:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th colspan="2">8-bit</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td><img alt="" src="images/qimage-8bit_scaled.png" /></td>
<td>
<pre class="cpp">
 <span class="type">QImage</span> image(<span class="number">3</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="type">QImage</span><span class="operator">.</span>Format_Indexed8);
 <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> value;

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">122</span><span class="operator">,</span> <span class="number">163</span><span class="operator">,</span> <span class="number">39</span>); <span class="comment">// 0xff7aa327</span>
 image<span class="operator">.</span><a href="qimage.html#setColor">setColor</a>(<span class="number">0</span><span class="operator">,</span> value);

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">237</span><span class="operator">,</span> <span class="number">187</span><span class="operator">,</span> <span class="number">51</span>); <span class="comment">// 0xffedba31</span>
 image<span class="operator">.</span><a href="qimage.html#setColor">setColor</a>(<span class="number">1</span><span class="operator">,</span> value);

 value <span class="operator">=</span> <a href="qtgui.html#qRgb">qRgb</a>(<span class="number">189</span><span class="operator">,</span> <span class="number">149</span><span class="operator">,</span> <span class="number">39</span>); <span class="comment">// 0xffbd9527</span>
 image<span class="operator">.</span><a href="qimage.html#setColor">setColor</a>(<span class="number">2</span><span class="operator">,</span> value);

 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span>);
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span>);
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>);
 image<span class="operator">.</span><a href="qimage.html#setPixel">setPixel</a>(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span>);
</pre></td>
</tr>
</table>
<p>QImage also provide the <a href="qimage.html#scanLine">scanLine</a>() function which returns a
pointer to the pixel data at the scanline with the given index, and
the <a href="qimage.html#bits">bits</a>() function which returns a
pointer to the first pixel data (this is equivalent to
<tt>scanLine(0)</tt>).</p>
<a id="image-formats" name="image-formats" />
<h3>Image Formats</h3>
<p>Each pixel stored in a QImage is represented by an integer. The
size of the integer varies depending on the format. QImage supports
several image formats described by the <a href="qimage.html#Format-enum">Format</a> enum.</p>
<p>Monochrome images are stored using 1-bit indexes into a color
table with at most two colors. There are two different types of
monochrome images: big endian (MSB first) or little endian (LSB
first) bit order.</p>
<p>8-bit images are stored using 8-bit indexes into a color table,
i.e. they have a single byte per pixel. The color table is a
<a href="qvector.html">QVector</a>&lt;<a href="qcolor.html#QRgb-typedef">QRgb</a>&gt;, and the <a href="qcolor.html#QRgb-typedef">QRgb</a> typedef is equivalent to an
unsigned int containing an ARGB quadruplet on the format
0xAARRGGBB.</p>
<p>32-bit images have no color table; instead, each pixel contains
an <a href="qcolor.html#QRgb-typedef">QRgb</a> value. There are
three different types of 32-bit images storing RGB (i.e.
0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In
the premultiplied format the red, green, and blue channels are
multiplied by the alpha component divided by 255.</p>
<p>An image's format can be retrieved using the <a href="qimage.html#format">format</a>() function. Use the <a href="qimage.html#convertToFormat">convertToFormat</a>() functions to
convert an image into another format. The <a href="qimage.html#allGray">allGray</a>() and <a href="qimage.html#isGrayscale">isGrayscale</a>() functions tell whether
a color image can safely be converted to a grayscale image.</p>
<a id="image-transformations" name="image-transformations" />
<h3>Image Transformations</h3>
<p>QImage supports a number of functions for creating a new image
that is a transformed version of the original: The <a href="qimage.html#createAlphaMask">createAlphaMask</a>() function builds
and returns a 1-bpp mask from the alpha buffer in this image, and
the <a href="qimage.html#createHeuristicMask">createHeuristicMask</a>()
function creates and returns a 1-bpp heuristic mask for this image.
The latter function works by selecting a color from one of the
corners, then chipping away pixels of that color starting at all
the edges.</p>
<p>The <a href="qimage.html#mirrored">mirrored</a>() function
returns a mirror of the image in the desired direction, the
<a href="qimage.html#scaled">scaled</a>() returns a copy of the
image scaled to a rectangle of the desired measures, and the
<a href="qimage.html#rgbSwapped">rgbSwapped</a>() function
constructs a BGR image from a RGB image.</p>
<p>The <a href="qimage.html#scaledToWidth">scaledToWidth</a>() and
<a href="qimage.html#scaledToHeight">scaledToHeight</a>() functions
return scaled copies of the image.</p>
<p>The <a href="qimage.html#transformed">transformed</a>() function
returns a copy of the image that is transformed with the given
transformation matrix and transformation mode: Internally, the
transformation matrix is adjusted to compensate for unwanted
translation, i.e. <a href="qimage.html#transformed">transformed</a>() returns the smallest
image containing all transformed points of the original image. The
static <a href="qimage.html#trueMatrix">trueMatrix</a>() function
returns the actual matrix used for transforming the image.</p>
<p>There are also functions for changing attributes of an image
in-place:</p>
<table class="generic">
<thead>
<tr class="qt-style">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td><a href="qimage.html#setDotsPerMeterX">setDotsPerMeterX</a>()</td>
<td>Defines the aspect ratio by setting the number of pixels that
fit horizontally in a physical meter.</td>
</tr>
<tr class="even" valign="top">
<td><a href="qimage.html#setDotsPerMeterY">setDotsPerMeterY</a>()</td>
<td>Defines the aspect ratio by setting the number of pixels that
fit vertically in a physical meter.</td>
</tr>
<tr class="odd" valign="top">
<td><a href="qimage.html#fill">fill</a>()</td>
<td>Fills the entire image with the given pixel value.</td>
</tr>
<tr class="even" valign="top">
<td><a href="qimage.html#invertPixels">invertPixels</a>()</td>
<td>Inverts all pixel values in the image using the given <a href="qimage.html#InvertMode-enum">InvertMode</a> value.</td>
</tr>
<tr class="odd" valign="top">
<td><a href="qimage.html#setColorTable">setColorTable</a>()</td>
<td>Sets the color table used to translate color indexes. Only
monochrome and 8-bit formats.</td>
</tr>
<tr class="even" valign="top">
<td><a href="qimage.html#setColorCount">setColorCount</a>()</td>
<td>Resizes the color table. Only monochrome and 8-bit
formats.</td>
</tr>
</table>
<a id="legal-information" name="legal-information" />
<h3>Legal Information</h3>
<p>For smooth scaling, the <a href="qimage.html#transformed">transformed</a>() functions use code
based on smooth scaling algorithm by Daniel M. Duley.</p>
<div class="LegaleseLeft">
<p>Copyright (C) 2004, 2005 Daniel M. Duley</p>
<p>Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the following
conditions are met:</p>
<p>1. Redistributions of source code must retain the above
copyright notice, this list of conditions and the following
disclaimer. 2. Redistributions in binary form must reproduce the
above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.</p>
</div>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="Format-enum" />QImage.Format</h3><p>The following image formats are available in Qt. Values greater
than QImage.Format_RGB16 were added in Qt 4.4. See the notes after
the table.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_Invalid</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The image is invalid.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_Mono</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The image is stored using 1-bit per pixel.
Bytes are packed with the most significant bit (MSB) first.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_MonoLSB</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The image is stored using 1-bit per pixel.
Bytes are packed with the less significant bit (LSB) first.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_Indexed8</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The image is stored using 8-bit indexes into a
colormap.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB32</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The image is stored using a 32-bit RGB format
(0xffRRGGBB).</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_ARGB32</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The image is stored using a 32-bit ARGB format
(0xAARRGGBB).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImage.Format_ARGB32_Premultiplied</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The image is stored using a premultiplied
32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue
channels are multiplied by the alpha component divided by 255. (If
RR, GG, or BB has a higher value than the alpha channel, the
results are undefined.) Certain operations (such as image
composition using alpha blending) are faster using premultiplied
ARGB32 than with plain ARGB32.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB16</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">The image is stored using a 16-bit RGB format
(5-6-5).</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImage.Format_ARGB8565_Premultiplied</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The image is stored using a premultiplied
24-bit ARGB format (8-5-6-5).</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB666</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">The image is stored using a 24-bit RGB format
(6-6-6). The unused most significant bits is always zero.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImage.Format_ARGB6666_Premultiplied</tt></td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">The image is stored using a premultiplied
24-bit ARGB format (6-6-6-6).</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB555</tt></td>
<td class="topAlign"><tt>11</tt></td>
<td class="topAlign">The image is stored using a 16-bit RGB format
(5-5-5). The unused most significant bit is always zero.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImage.Format_ARGB8555_Premultiplied</tt></td>
<td class="topAlign"><tt>12</tt></td>
<td class="topAlign">The image is stored using a premultiplied
24-bit ARGB format (8-5-5-5).</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB888</tt></td>
<td class="topAlign"><tt>13</tt></td>
<td class="topAlign">The image is stored using a 24-bit RGB format
(8-8-8).</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.Format_RGB444</tt></td>
<td class="topAlign"><tt>14</tt></td>
<td class="topAlign">The image is stored using a 16-bit RGB format
(4-4-4). The unused bits are always zero.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QImage.Format_ARGB4444_Premultiplied</tt></td>
<td class="topAlign"><tt>15</tt></td>
<td class="topAlign">The image is stored using a premultiplied
16-bit ARGB format (4-4-4-4).</td>
</tr>
</table>
<p><b>Note:</b> Drawing into a <a href="qimage.html">QImage</a>
with QImage.Format_Indexed8 is not supported.</p>
<p><b>Note:</b> Do not render into ARGB32 images using <a href="qpainter.html">QPainter</a>. Using
QImage.Format_ARGB32_Premultiplied is significantly faster.</p>
<p><b>See also</b> <a href="qimage.html#format">format</a>() and
<a href="qimage.html#convertToFormat">convertToFormat</a>().</p>


<h3 class="fn"><a name="InvertMode-enum" />QImage.InvertMode</h3><p>This enum type is used to describe how pixel values should be
inverted in the <a href="qimage.html#invertPixels">invertPixels</a>() function.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QImage.InvertRgb</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">Invert only the RGB values and leave the alpha
channel unchanged.</td>
</tr>
<tr>
<td class="topAlign"><tt>QImage.InvertRgba</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">Invert all channels, including the alpha
channel.</td>
</tr>
</table>
<p><b>See also</b> <a href="qimage.html#invertPixels">invertPixels</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QImage" />QImage.__init__ (<i>self</i>)</h3><p>Constructs a null image.</p>
<p><b>See also</b> <a href="qimage.html#isNull">isNull</a>().</p>


<h3 class="fn"><a name="QImage-2" />QImage.__init__ (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>size</i> and
<i>format</i>.</p>
<p>A <a href="qimage.html#isNull">null</a> image is returned if
memory cannot be allocated.</p>
<p><b>Warning:</b> This will create a <a href="qimage.html">QImage</a> with uninitialized data. Call <a href="qimage.html#fill">fill</a>() to fill the image with an appropriate
pixel value before drawing onto it with <a href="qpainter.html">QPainter</a>.</p>


<h3 class="fn"><a name="QImage-3" />QImage.__init__ (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>width</i>, <i>height</i>
and <i>format</i>.</p>
<p>A <a href="qimage.html#isNull">null</a> image will be returned
if memory cannot be allocated.</p>
<p><b>Warning:</b> This will create a <a href="qimage.html">QImage</a> with uninitialized data. Call <a href="qimage.html#fill">fill</a>() to fill the image with an appropriate
pixel value before drawing onto it with <a href="qpainter.html">QPainter</a>.</p>


<h3 class="fn"><a name="QImage-4" />QImage.__init__ (<i>self</i>, str&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>width</i>, <i>height</i>
and <i>format</i>, that uses an existing memory buffer,
<i>data</i>. The <i>width</i> and <i>height</i> must be specified
in pixels, <i>data</i> must be 32-bit aligned, and each scanline of
data in the image must also be 32-bit aligned.</p>
<p>The buffer must remain valid throughout the life of the <a href="qimage.html">QImage</a>. The image does not delete the buffer at
destruction.</p>
<p>If <i>format</i> is an indexed color format, the image color
table is initially empty and must be sufficiently expanded with
<a href="qimage.html#setColorCount">setColorCount</a>() or <a href="qimage.html#setColorTable">setColorTable</a>() before the image is
used.</p>


<h3 class="fn"><a name="QImage-5" />QImage.__init__ (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>width</i>, <i>height</i>
and <i>format</i>, that uses an existing read-only memory buffer,
<i>data</i>. The <i>width</i> and <i>height</i> must be specified
in pixels, <i>data</i> must be 32-bit aligned, and each scanline of
data in the image must also be 32-bit aligned.</p>
<p>The buffer must remain valid throughout the life of the <a href="qimage.html">QImage</a> and all copies that have not been modified
or otherwise detached from the original buffer. The image does not
delete the buffer at destruction.</p>
<p>If <i>format</i> is an indexed color format, the image color
table is initially empty and must be sufficiently expanded with
<a href="qimage.html#setColorCount">setColorCount</a>() or <a href="qimage.html#setColorTable">setColorTable</a>() before the image is
used.</p>
<p>Unlike the similar <a href="qimage.html">QImage</a> constructor
that takes a non-const data buffer, this version will never alter
the contents of the buffer. For example, calling <a href="qimage.html#bits">QImage.bits</a>() will return a deep copy of
the image, rather than the buffer passed to the constructor. This
allows for the efficiency of constructing a <a href="qimage.html">QImage</a> from raw data, without the possibility of
the raw data being changed.</p>


<h3 class="fn"><a name="QImage-6" />QImage.__init__ (<i>self</i>, str&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>bytesPerLine</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>width</i>, <i>height</i>
and <i>format</i>, that uses an existing memory buffer,
<i>data</i>. The <i>width</i> and <i>height</i> must be specified
in pixels. <i>bytesPerLine</i> specifies the number of bytes per
line (stride).</p>
<p>The buffer must remain valid throughout the life of the <a href="qimage.html">QImage</a>. The image does not delete the buffer at
destruction.</p>
<p>If <i>format</i> is an indexed color format, the image color
table is initially empty and must be sufficiently expanded with
<a href="qimage.html#setColorCount">setColorCount</a>() or <a href="qimage.html#setColorTable">setColorTable</a>() before the image is
used.</p>


<h3 class="fn"><a name="QImage-7" />QImage.__init__ (<i>self</i>, sip.voidptr&#160;<i>data</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>bytesPerLine</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>)</h3><p>Constructs an image with the given <i>width</i>, <i>height</i>
and <i>format</i>, that uses an existing memory buffer,
<i>data</i>. The <i>width</i> and <i>height</i> must be specified
in pixels. <i>bytesPerLine</i> specifies the number of bytes per
line (stride).</p>
<p>The buffer must remain valid throughout the life of the <a href="qimage.html">QImage</a>. The image does not delete the buffer at
destruction.</p>
<p>If <i>format</i> is an indexed color format, the image color
table is initially empty and must be sufficiently expanded with
<a href="qimage.html#setColorCount">setColorCount</a>() or <a href="qimage.html#setColorTable">setColorTable</a>() before the image is
used.</p>
<p>Unlike the similar <a href="qimage.html">QImage</a> constructor
that takes a non-const data buffer, this version will never alter
the contents of the buffer. For example, calling <a href="qimage.html#bits">QImage.bits</a>() will return a deep copy of
the image, rather than the buffer passed to the constructor. This
allows for the efficiency of constructing a <a href="qimage.html">QImage</a> from raw data, without the possibility of
the raw data being changed.</p>


<h3 class="fn"><a name="QImage-8" />QImage.__init__ (<i>self</i>, list-of-str&#160;<i>xpm</i>)</h3><p>Constructs an image from the given <i>xpm</i> image.</p>
<p>Make sure that the image is a valid XPM image. Errors are
silently ignored.</p>
<p>Note that it's possible to squeeze the XPM variable a little bit
by using an unusual declaration:</p>
<pre class="cpp">
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span> <span class="keyword">const</span> start_xpm<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="string">"16 15 8 1"</span><span class="operator">,</span>
     <span class="string">"a c #cec6bd"</span><span class="operator">,</span>
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>The extra <tt>const</tt> makes the entire definition read-only,
which is slightly more efficient (e.g., when the code is in a
shared library) and able to be stored in ROM with the
application.</p>


<h3 class="fn"><a name="QImage-9" />QImage.__init__ (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>Constructs an image and tries to load the image from the file
with the given <i>fileName</i>.</p>
<p>The loader attempts to read the image using the specified
<i>format</i>. If the <i>format</i> is not specified (which is the
default), the loader probes the file for a header to guess the file
format.</p>
<p>If the loading of the image failed, this object is a null
image.</p>
<p>The file name can either refer to an actual file on disk or to
one of the application's embedded resources. See the <a href="resources.html">Resource System</a> overview for details on how to
embed images and other resource files in the application's
executable.</p>
<p><b>See also</b> <a href="qimage.html#isNull">isNull</a>() and
<a href="qimage.html#reading-and-writing-image-files">Reading and
Writing Image Files</a>.</p>


<h3 class="fn"><a name="QImage-10" />QImage.__init__ (<i>self</i>, <a href="qimage.html">QImage</a>)</h3><p>Constructs an image and tries to load the image from the file
with the given <i>fileName</i>.</p>
<p>The loader attempts to read the image using the specified
<i>format</i>. If the <i>format</i> is not specified (which is the
default), the loader probes the file for a header to guess the file
format.</p>
<p>If the loading of the image failed, this object is a null
image.</p>
<p>The file name can either refer to an actual file on disk or to
one of the application's embedded resources. See the <a href="resources.html">Resource System</a> overview for details on how to
embed images and other resource files in the application's
executable.</p>
<p>You can disable this constructor by defining
<tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications.
This can be useful, for example, if you want to ensure that all
user-visible strings go through <a href="qobject.html#tr">QObject.tr</a>().</p>
<p><b>See also</b> <a href="qstring.html#fromAscii">QString.fromAscii</a>(), <a href="qimage.html#isNull">isNull</a>(), and <a href="qimage.html#reading-and-writing-image-files">Reading and Writing
Image Files</a>.</p>


<h3 class="fn"><a name="QImage-11" />QImage.__init__ (<i>self</i>, QVariant&#160;<i>variant</i>)</h3><p>Constructs a shallow copy of the given <i>image</i>.</p>
<p>For more information about shallow copies, see the <a href="implicit-sharing.html#implicit-data-sharing">Implicit Data
Sharing</a> documentation.</p>
<p><b>See also</b> <a href="qimage.html#copy">copy</a>().</p>


<h3 class="fn"><a name="allGray" />bool QImage.allGray (<i>self</i>)</h3><p>Returns true if all the colors in the image are shades of gray
(i.e. their red, green and blue components are equal); otherwise
false.</p>
<p>Note that this function is slow for images without color
table.</p>
<p><b>See also</b> <a href="qimage.html#isGrayscale">isGrayscale</a>().</p>


<h3 class="fn"><a name="alphaChannel" /><a href="qimage.html">QImage</a> QImage.alphaChannel (<i>self</i>)</h3><h3 class="fn"><a name="bitPlaneCount" />int QImage.bitPlaneCount (<i>self</i>)</h3><p>Returns the number of bit planes in the image.</p>
<p>The number of bit planes is the number of bits of color and
transparency information for each pixel. This is different from
(i.e. smaller than) the depth when the image format contains unused
bits.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qimage.html#depth">depth</a>(),
<a href="qimage.html#format">format</a>(), and <a href="qimage.html#image-formats">Image Formats</a>.</p>


<h3 class="fn"><a name="bits" />sip.voidptr QImage.bits (<i>self</i>)</h3><p>Returns a pointer to the first pixel data. This is equivalent to
scanLine(0).</p>
<p>Note that <a href="qimage.html">QImage</a> uses <a href="implicit-sharing.html#implicit-data-sharing">implicit data
sharing</a>. This function performs a deep copy of the shared pixel
data, thus ensuring that this <a href="qimage.html">QImage</a> is
the only one using the current return value.</p>
<p><b>See also</b> <a href="qimage.html#scanLine">scanLine</a>(),
<a href="qimage.html#byteCount">byteCount</a>(), and <a href="qimage.html#constBits">constBits</a>().</p>


<h3 class="fn"><a name="byteCount" />int QImage.byteCount (<i>self</i>)</h3><p>Returns the number of bytes occupied by the image data.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qimage.html#bytesPerLine">bytesPerLine</a>(), <a href="qimage.html#bits">bits</a>(), and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="bytesPerLine" />int QImage.bytesPerLine (<i>self</i>)</h3><p>Returns the number of bytes per image scanline.</p>
<p>This is equivalent to <a href="qimage.html#byteCount">byteCount</a>() / <a href="qimage.html#height">height</a>().</p>
<p><b>See also</b> <a href="qimage.html#scanLine">scanLine</a>().</p>


<h3 class="fn"><a name="cacheKey" />int QImage.cacheKey (<i>self</i>)</h3><p>Returns a number that identifies the contents of this <a href="qimage.html">QImage</a> object. Distinct <a href="qimage.html">QImage</a> objects can only have the same key if they
refer to the same contents.</p>
<p>The key will change when the image is altered.</p>


<h3 class="fn"><a name="color" />int QImage.color (<i>self</i>, int&#160;<i>i</i>)</h3><p>Returns the color in the color table at index <i>i</i>. The
first color is at index 0.</p>
<p>The colors in an image's color table are specified as ARGB
quadruplets (<a href="qcolor.html#QRgb-typedef">QRgb</a>). Use the
<a href="qtgui.html#qAlpha">qAlpha</a>(), <a href="qtgui.html#qRed">qRed</a>(), <a href="qtgui.html#qGreen">qGreen</a>(), and <a href="qtgui.html#qBlue">qBlue</a>() functions to get the color value
components.</p>
<p><b>See also</b> <a href="qimage.html#setColor">setColor</a>(),
<a href="qimage.html#pixelIndex">pixelIndex</a>(), and <a href="qimage.html#pixel-manipulation">Pixel Manipulation</a>.</p>


<h3 class="fn"><a name="colorCount" />int QImage.colorCount (<i>self</i>)</h3><p>Returns the size of the color table for the image.</p>
<p>Notice that colorCount() returns 0 for 32-bpp images because
these images do not use color tables, but instead encode pixel
values as ARGB quadruplets.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qimage.html#setColorCount">setColorCount</a>() and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="colorTable" />list-of-int QImage.colorTable (<i>self</i>)</h3><p>Returns a list of the colors contained in the image's color
table, or an empty list if the image does not have a color
table</p>
<p><b>See also</b> <a href="qimage.html#setColorTable">setColorTable</a>(), <a href="qimage.html#colorCount">colorCount</a>(), and <a href="qimage.html#color">color</a>().</p>


<h3 class="fn"><a name="constBits" />sip.voidptr QImage.constBits (<i>self</i>)</h3><p>Returns a pointer to the first pixel data.</p>
<p>Note that <a href="qimage.html">QImage</a> uses <a href="implicit-sharing.html#implicit-data-sharing">implicit data
sharing</a>, but this function does <i>not</i> perform a deep copy
of the shared pixel data, because the returned data is const.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qimage.html#bits">bits</a>() and
<a href="qimage.html#constScanLine">constScanLine</a>().</p>


<h3 class="fn"><a name="constScanLine" />sip.voidptr QImage.constScanLine (<i>self</i>, int)</h3><p>Returns a pointer to the pixel data at the scanline with index
<i>i</i>. The first scanline is at index 0.</p>
<p>The scanline data is aligned on a 32-bit boundary.</p>
<p>Note that <a href="qimage.html">QImage</a> uses <a href="implicit-sharing.html#implicit-data-sharing">implicit data
sharing</a>, but this function does <i>not</i> perform a deep copy
of the shared pixel data, because the returned data is const.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also</b> <a href="qimage.html#scanLine">scanLine</a>()
and <a href="qimage.html#constBits">constBits</a>().</p>


<h3 class="fn"><a name="convertToFormat" /><a href="qimage.html">QImage</a> QImage.convertToFormat (<i>self</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>, <a href="qt-imageconversionflags.html">Qt.ImageConversionFlags</a>&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</h3><p>Returns a copy of the image in the given <i>format</i>.</p>
<p>The specified image conversion <i>flags</i> control how the
image data is handled during the conversion process.</p>
<p><b>See also</b> <a href="qimage.html#image-formats">Image
Format</a>.</p>


<h3 class="fn"><a name="convertToFormat-2" /><a href="qimage.html">QImage</a> QImage.convertToFormat (<i>self</i>, <a href="qimage.html#Format-enum">Format</a>&#160;<i>format</i>, list-of-int&#160;<i>colorTable</i>, <a href="qt-imageconversionflags.html">Qt.ImageConversionFlags</a>&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</h3><p>This is an overloaded function.</p>
<p>Returns a copy of the image converted to the given
<i>format</i>, using the specified <i>colorTable</i>.</p>
<p>Conversion from 32 bit to 8 bit indexed is a slow operation and
will use a straightforward nearest color approach, with no
dithering.</p>


<h3 class="fn"><a name="copy" /><a href="qimage.html">QImage</a> QImage.copy (<i>self</i>, <a href="qrect.html">QRect</a>&#160;<i>rect</i>&#160;=&#160;QRect())</h3><p>Returns a sub-area of the image as a new image.</p>
<p>The returned image is copied from the position
(<i>rectangle</i>.x(), <i>rectangle</i>.y()) in this image, and
will always have the size of the given <i>rectangle</i>.</p>
<p>In areas beyond this image, pixels are set to 0. For 32-bit RGB
images, this means black; for 32-bit ARGB images, this means
transparent black; for 8-bit images, this means the color with
index 0 in the color table which can be anything; for 1-bit images,
this means <a href="qt.html#GlobalColor-enum">Qt.color0</a>.</p>
<p>If the given <i>rectangle</i> is a null rectangle the entire
image is copied.</p>
<p><b>See also</b> <a href="qimage.html#QImage">QImage</a>().</p>


<h3 class="fn"><a name="copy-2" /><a href="qimage.html">QImage</a> QImage.copy (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><h3 class="fn"><a name="createAlphaMask" /><a href="qimage.html">QImage</a> QImage.createAlphaMask (<i>self</i>, <a href="qt-imageconversionflags.html">Qt.ImageConversionFlags</a>&#160;<i>flags</i>&#160;=&#160;Qt.AutoColor)</h3><p>Builds and returns a 1-bpp mask from the alpha buffer in this
image. Returns a null image if the image's format is <a href="qimage.html#Format-enum">QImage.Format_RGB32</a>.</p>
<p>The <i>flags</i> argument is a bitwise-OR of the <a href="qt.html#ImageConversionFlag-enum">Qt.ImageConversionFlags</a>,
and controls the conversion process. Passing 0 for flags sets all
the default options.</p>
<p>The returned image has little-endian bit order (i.e. the image's
format is <a href="qimage.html#Format-enum">QImage.Format_MonoLSB</a>), which you
can convert to big-endian (<a href="qimage.html#Format-enum">QImage.Format_Mono</a>) using the
<a href="qimage.html#convertToFormat">convertToFormat</a>()
function.</p>
<p><b>See also</b> <a href="qimage.html#createHeuristicMask">createHeuristicMask</a>() and
<a href="qimage.html#image-transformations">Image
Transformations</a>.</p>


<h3 class="fn"><a name="createHeuristicMask" /><a href="qimage.html">QImage</a> QImage.createHeuristicMask (<i>self</i>, bool&#160;<i>clipTight</i>&#160;=&#160;True)</h3><p>Creates and returns a 1-bpp heuristic mask for this image.</p>
<p>The function works by selecting a color from one of the corners,
then chipping away pixels of that color starting at all the edges.
The four corners vote for which color is to be masked away. In case
of a draw (this generally means that this function is not
applicable to the image), the result is arbitrary.</p>
<p>The returned image has little-endian bit order (i.e. the image's
format is <a href="qimage.html#Format-enum">QImage.Format_MonoLSB</a>), which you
can convert to big-endian (<a href="qimage.html#Format-enum">QImage.Format_Mono</a>) using the
<a href="qimage.html#convertToFormat">convertToFormat</a>()
function.</p>
<p>If <i>clipTight</i> is true (the default) the mask is just large
enough to cover the pixels; otherwise, the mask is larger than the
data pixels.</p>
<p>Note that this function disregards the alpha buffer.</p>
<p><b>See also</b> <a href="qimage.html#createAlphaMask">createAlphaMask</a>() and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="createMaskFromColor" /><a href="qimage.html">QImage</a> QImage.createMaskFromColor (<i>self</i>, int&#160;<i>color</i>, <a href="qt.html#MaskMode-enum">Qt.MaskMode</a>&#160;<i>mode</i>&#160;=&#160;Qt.MaskInColor)</h3><p>Creates and returns a mask for this image based on the given
<i>color</i> value. If the <i>mode</i> is MaskInColor (the default
value), all pixels matching <i>color</i> will be opaque pixels in
the mask. If <i>mode</i> is MaskOutColor, all pixels matching the
given color will be transparent.</p>
<p><b>See also</b> <a href="qimage.html#createAlphaMask">createAlphaMask</a>() and <a href="qimage.html#createHeuristicMask">createHeuristicMask</a>().</p>


<h3 class="fn"><a name="depth" />int QImage.depth (<i>self</i>)</h3><p>Returns the depth of the image.</p>
<p>The image depth is the number of bits used to store a single
pixel, also called bits per pixel (bpp).</p>
<p>The supported depths are 1, 8, 16, 24 and 32.</p>
<p><b>See also</b> <a href="qimage.html#bitPlaneCount">bitPlaneCount</a>(), <a href="qimage.html#convertToFormat">convertToFormat</a>(), <a href="qimage.html#image-formats">Image Formats</a>, and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="detach" />QImage.detach (<i>self</i>)</h3><h3 class="fn"><a name="devType" />int QImage.devType (<i>self</i>)</h3><h3 class="fn"><a name="dotsPerMeterX" />int QImage.dotsPerMeterX (<i>self</i>)</h3><p>Returns the number of pixels that fit horizontally in a physical
meter. Together with <a href="qimage.html#dotsPerMeterY">dotsPerMeterY</a>(), this number
defines the intended scale and aspect ratio of the image.</p>
<p><b>See also</b> <a href="qimage.html#setDotsPerMeterX">setDotsPerMeterX</a>() and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="dotsPerMeterY" />int QImage.dotsPerMeterY (<i>self</i>)</h3><p>Returns the number of pixels that fit vertically in a physical
meter. Together with <a href="qimage.html#dotsPerMeterX">dotsPerMeterX</a>(), this number
defines the intended scale and aspect ratio of the image.</p>
<p><b>See also</b> <a href="qimage.html#setDotsPerMeterY">setDotsPerMeterY</a>() and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="fill" />QImage.fill (<i>self</i>, <a href="qt.html#GlobalColor-enum">Qt.GlobalColor</a>&#160;<i>color</i>)</h3><p>Fills the entire image with the given <i>pixelValue</i>.</p>
<p>If the depth of this image is 1, only the lowest bit is used. If
you say fill(0), fill(2), etc., the image is filled with 0s. If you
say fill(1), fill(3), etc., the image is filled with 1s. If the
depth is 8, the lowest 8 bits are used and if the depth is 16 the
lowest 16 bits are used.</p>
<p>Note: <a href="qimage.html#pixel">QImage.pixel</a>() returns
the color of the pixel at the given coordinates while <a class="compat" href="qcolor-qt3.html#pixel">QColor.pixel</a>() returns
the pixel value of the underlying window system (essentially an
index value), so normally you will want to use <a href="qimage.html#pixel">QImage.pixel</a>() to use a color from an
existing image or <a href="qcolor.html#rgb">QColor.rgb</a>() to
use a specific color.</p>
<p><b>See also</b> <a href="qimage.html#depth">depth</a>() and
<a href="qimage.html#image-transformations">Image
Transformations</a>.</p>


<h3 class="fn"><a name="fill-2" />QImage.fill (<i>self</i>, <a href="qcolor.html">QColor</a>&#160;<i>color</i>)</h3><p>This is an overloaded function.</p>
<p>Fills the image with the given <i>color</i>, described as a
standard global color.</p>
<p>This function was introduced in Qt 4.8.</p>


<h3 class="fn"><a name="fill-3" />QImage.fill (<i>self</i>, int&#160;<i>pixel</i>)</h3><p>This is an overloaded function.</p>
<p>Fills the entire image with the given <i>color</i>.</p>
<p>If the depth of the image is 1, the image will be filled with 1
if <i>color</i> equals <a href="qt.html#GlobalColor-enum">Qt.color1</a>; it will otherwise be
filled with 0.</p>
<p>If the depth of the image is 8, the image will be filled with
the index corresponding the <i>color</i> in the color table if
present; it will otherwise be filled with 0.</p>
<p>This function was introduced in Qt 4.8.</p>


<h3 class="fn"><a name="format" /><a href="qimage.html#Format-enum">Format</a> QImage.format (<i>self</i>)</h3><p>Returns the format of the image.</p>
<p><b>See also</b> <a href="qimage.html#image-formats">Image
Formats</a>.</p>


<h3 class="fn"><a name="fromData" /><a href="qimage.html">QImage</a> QImage.fromData (str&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>Constructs a <a href="qimage.html">QImage</a> from the first
<i>size</i> bytes of the given binary <i>data</i>. The loader
attempts to read the image using the specified <i>format</i>. If
<i>format</i> is not specified (which is the default), the loader
probes the file for a header to guess the file format. binary
<i>data</i>. The loader attempts to read the image, either using
the optional image <i>format</i> specified or by determining the
image format from the data.</p>
<p>If <i>format</i> is not specified (which is the default), the
loader probes the file for a header to determine the file format.
If <i>format</i> is specified, it must be one of the values
returned by <a href="qimagereader.html#supportedImageFormats">QImageReader.supportedImageFormats</a>().</p>
<p>If the loading of the image fails, the image returned will be a
null image.</p>
<p><b>See also</b> <a href="qimage.html#load">load</a>(), <a href="qimage.html#save">save</a>(), and <a href="qimage.html#reading-and-writing-image-files">Reading and Writing
Image Files</a>.</p>


<h3 class="fn"><a name="fromData-2" /><a href="qimage.html">QImage</a> QImage.fromData (<a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p>Loads an image from the given <a href="qbytearray.html">QByteArray</a> <i>data</i>.</p>


<h3 class="fn"><a name="hasAlphaChannel" />bool QImage.hasAlphaChannel (<i>self</i>)</h3><p>Returns true if the image has a format that respects the alpha
channel, otherwise returns false.</p>
<p><b>See also</b> <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="height" />int QImage.height (<i>self</i>)</h3><p>Returns the height of the image.</p>
<p><b>See also</b> <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="invertPixels" />QImage.invertPixels (<i>self</i>, <a href="qimage.html#InvertMode-enum">InvertMode</a>&#160;<i>mode</i>&#160;=&#160;QImage.InvertRgb)</h3><p>Inverts all pixel values in the image.</p>
<p>The given invert <i>mode</i> only have a meaning when the
image's depth is 32. The default <i>mode</i> is <a href="qimage.html#InvertMode-enum">InvertRgb</a>, which leaves the alpha
channel unchanged. If the <i>mode</i> is <a href="qimage.html#InvertMode-enum">InvertRgba</a>, the alpha bits are
also inverted.</p>
<p>Inverting an 8-bit image means to replace all pixels using color
index <i>i</i> with a pixel using color index 255 minus <i>i</i>.
The same is the case for a 1-bit image. Note that the color table
is <i>not</i> changed.</p>
<p><b>See also</b> <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="isDetached" />bool QImage.isDetached (<i>self</i>)</h3><h3 class="fn"><a name="isGrayscale" />bool QImage.isGrayscale (<i>self</i>)</h3><p>For 32-bit images, this function is equivalent to <a href="qimage.html#allGray">allGray</a>().</p>
<p>For 8-bpp images, this function returns true if color(i) is
<a href="qcolor.html#QRgb-typedef">QRgb</a>(i, i, i) for all
indexes of the color table; otherwise returns false.</p>
<p><b>See also</b> <a href="qimage.html#allGray">allGray</a>() and
<a href="qimage.html#image-formats">Image Formats</a>.</p>


<h3 class="fn"><a name="isNull" />bool QImage.isNull (<i>self</i>)</h3><p>Returns true if it is a null image, otherwise returns false.</p>
<p>A null image has all parameters set to zero and no allocated
data.</p>


<h3 class="fn"><a name="load" />bool QImage.load (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>, str&#160;<i>format</i>)</h3><p>Loads an image from the file with the given <i>fileName</i>.
Returns true if the image was successfully loaded; otherwise
returns false.</p>
<p>The loader attempts to read the image using the specified
<i>format</i>, e.g., PNG or JPG. If <i>format</i> is not specified
(which is the default), the loader probes the file for a header to
guess the file format.</p>
<p>The file name can either refer to an actual file on disk or to
one of the application's embedded resources. See the <a href="resources.html">Resource System</a> overview for details on how to
embed images and other resource files in the application's
executable.</p>
<p><b>See also</b> <a href="qimage.html#reading-and-writing-image-files">Reading and Writing
Image Files</a>.</p>


<h3 class="fn"><a name="load-2" />bool QImage.load (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p>This function reads a <a href="qimage.html">QImage</a> from the
given <i>device</i>. This can, for example, be used to load an
image directly into a <a href="qbytearray.html">QByteArray</a>.</p>


<h3 class="fn"><a name="loadFromData" />bool QImage.loadFromData (<i>self</i>, str&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>Loads an image from the first <i>len</i> bytes of the given
binary <i>data</i>. Returns true if the image was successfully
loaded; otherwise returns false.</p>
<p>The loader attempts to read the image using the specified
<i>format</i>, e.g., PNG or JPG. If <i>format</i> is not specified
(which is the default), the loader probes the file for a header to
guess the file format.</p>
<p><b>See also</b> <a href="qimage.html#reading-and-writing-image-files">Reading and Writing
Image Files</a>.</p>


<h3 class="fn"><a name="loadFromData-2" />bool QImage.loadFromData (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>, str&#160;<i>format</i>&#160;=&#160;None)</h3><p>This is an overloaded function.</p>
<p>Loads an image from the given <a href="qbytearray.html">QByteArray</a> <i>data</i>.</p>


<h3 class="fn"><a name="metric" />int QImage.metric (<i>self</i>, <a href="qpaintdevice.html#PaintDeviceMetric-enum">QPaintDevice.PaintDeviceMetric</a>&#160;<i>metric</i>)</h3><h3 class="fn"><a name="mirrored" /><a href="qimage.html">QImage</a> QImage.mirrored (<i>self</i>, bool&#160;<i>horizontal</i>&#160;=&#160;False, bool&#160;<i>vertical</i>&#160;=&#160;True)</h3><p>Returns a mirror of the image, mirrored in the horizontal and/or
the vertical direction depending on whether <i>horizontal</i> and
<i>vertical</i> are set to true or false.</p>
<p>Note that the original image is not changed.</p>
<p><b>See also</b> <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="numBytes" />int QImage.numBytes (<i>self</i>)</h3><h3 class="fn"><a name="numColors" />int QImage.numColors (<i>self</i>)</h3><h3 class="fn"><a name="offset" /><a href="qpoint.html">QPoint</a> QImage.offset (<i>self</i>)</h3><p>Returns the number of pixels by which the image is intended to
be offset by when positioning relative to other images.</p>
<p><b>See also</b> <a href="qimage.html#setOffset">setOffset</a>()
and <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="paintEngine" /><a href="qpaintengine.html">QPaintEngine</a> QImage.paintEngine (<i>self</i>)</h3><h3 class="fn"><a name="pixel" />int QImage.pixel (<i>self</i>, <a href="qpoint.html">QPoint</a>&#160;<i>pt</i>)</h3><p>Returns the color of the pixel at the given <i>position</i>.</p>
<p>If the <i>position</i> is not valid, the results are
undefined.</p>
<p><b>Warning:</b> This function is expensive when used for massive
pixel manipulations.</p>
<p><b>See also</b> <a href="qimage.html#setPixel">setPixel</a>(),
<a href="qimage.html#valid">valid</a>(), and <a href="qimage.html#pixel-manipulation">Pixel Manipulation</a>.</p>


<h3 class="fn"><a name="pixel-2" />int QImage.pixel (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</h3><p>This is an overloaded function.</p>
<p>Returns the color of the pixel at coordinates (<i>x</i>,
<i>y</i>).</p>


<h3 class="fn"><a name="pixelIndex" />int QImage.pixelIndex (<i>self</i>, <a href="qpoint.html">QPoint</a>&#160;<i>pt</i>)</h3><p>Returns the pixel index at the given <i>position</i>.</p>
<p>If <i>position</i> is not valid, or if the image is not a
paletted image (<a href="qimage.html#depth">depth</a>() &gt; 8),
the results are undefined.</p>
<p><b>See also</b> <a href="qimage.html#valid">valid</a>(),
<a href="qimage.html#depth">depth</a>(), and <a href="qimage.html#pixel-manipulation">Pixel Manipulation</a>.</p>


<h3 class="fn"><a name="pixelIndex-2" />int QImage.pixelIndex (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</h3><p>This is an overloaded function.</p>
<p>Returns the pixel index at (<i>x</i>, <i>y</i>).</p>


<h3 class="fn"><a name="rect" /><a href="qrect.html">QRect</a> QImage.rect (<i>self</i>)</h3><p>Returns the enclosing rectangle (0, 0, <a href="qimage.html#width">width</a>(), <a href="qimage.html#height">height</a>()) of the image.</p>
<p><b>See also</b> <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="rgbSwapped" /><a href="qimage.html">QImage</a> QImage.rgbSwapped (<i>self</i>)</h3><p>Returns a <a href="qimage.html">QImage</a> in which the values
of the red and blue components of all pixels have been swapped,
effectively converting an RGB image to an BGR image.</p>
<p>The original <a href="qimage.html">QImage</a> is not
changed.</p>
<p><b>See also</b> <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="save" />bool QImage.save (<i>self</i>, QString&#160;<i>fileName</i>, str&#160;<i>format</i>&#160;=&#160;None, int&#160;<i>quality</i>&#160;=&#160;-1)</h3><p>Saves the image to the file with the given <i>fileName</i>,
using the given image file <i>format</i> and <i>quality</i> factor.
If <i>format</i> is 0, <a href="qimage.html">QImage</a> will
attempt to guess the format by looking at <i>fileName</i>'s
suffix.</p>
<p>The <i>quality</i> factor must be in the range 0 to 100 or -1.
Specify 0 to obtain small compressed files, 100 for large
uncompressed files, and -1 (the default) to use the default
settings.</p>
<p>Returns true if the image was successfully saved; otherwise
returns false.</p>
<p><b>See also</b> <a href="qimage.html#reading-and-writing-image-files">Reading and Writing
Image Files</a>.</p>


<h3 class="fn"><a name="save-2" />bool QImage.save (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>, str&#160;<i>format</i>&#160;=&#160;None, int&#160;<i>quality</i>&#160;=&#160;-1)</h3><p>This is an overloaded function.</p>
<p>This function writes a <a href="qimage.html">QImage</a> to the
given <i>device</i>.</p>
<p>This can, for example, be used to save an image directly into a
<a href="qbytearray.html">QByteArray</a>:</p>
<pre class="cpp">
         <span class="type"><a href="qimage.html">QImage</a></span> image;
         <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba;
         <span class="type"><a href="qbuffer.html">QBuffer</a></span> buffer(<span class="operator">&amp;</span>ba);
         buffer<span class="operator">.</span>open(<span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">.</span>WriteOnly);
         image<span class="operator">.</span>save(<span class="operator">&amp;</span>buffer<span class="operator">,</span> <span class="string">"PNG"</span>); <span class="comment">// writes image into ba in PNG format</span>
</pre>


<h3 class="fn"><a name="scaled" /><a href="qimage.html">QImage</a> QImage.scaled (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qt.html#AspectRatioMode-enum">Qt.AspectRatioMode</a>&#160;<i>aspectRatioMode</i>&#160;=&#160;Qt.IgnoreAspectRatio, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>transformMode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>Returns a copy of the image scaled to a rectangle defined by the
given <i>size</i> according to the given <i>aspectRatioMode</i> and
<i>transformMode</i>.</p>
<p class="centerAlign"><img alt="" src="images/qimage-scaling.png" /></p>
<ul>
<li>If <i>aspectRatioMode</i> is <a href="qt.html#AspectRatioMode-enum">Qt.IgnoreAspectRatio</a>, the image
is scaled to <i>size</i>.</li>
<li>If <i>aspectRatioMode</i> is <a href="qt.html#AspectRatioMode-enum">Qt.KeepAspectRatio</a>, the image
is scaled to a rectangle as large as possible inside <i>size</i>,
preserving the aspect ratio.</li>
<li>If <i>aspectRatioMode</i> is <a href="qt.html#AspectRatioMode-enum">Qt.KeepAspectRatioByExpanding</a>,
the image is scaled to a rectangle as small as possible outside
<i>size</i>, preserving the aspect ratio.</li>
</ul>
<p>If the given <i>size</i> is empty, this function returns a null
image.</p>
<p><b>See also</b> <a href="qimage.html#isNull">isNull</a>() and
<a href="qimage.html#image-transformations">Image
Transformations</a>.</p>


<h3 class="fn"><a name="scaled-2" /><a href="qimage.html">QImage</a> QImage.scaled (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qt.html#AspectRatioMode-enum">Qt.AspectRatioMode</a>&#160;<i>aspectRatioMode</i>&#160;=&#160;Qt.IgnoreAspectRatio, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>transformMode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>This is an overloaded function.</p>
<p>Returns a copy of the image scaled to a rectangle with the given
<i>width</i> and <i>height</i> according to the given
<i>aspectRatioMode</i> and <i>transformMode</i>.</p>
<p>If either the <i>width</i> or the <i>height</i> is zero or
negative, this function returns a null image.</p>


<h3 class="fn"><a name="scaledToHeight" /><a href="qimage.html">QImage</a> QImage.scaledToHeight (<i>self</i>, int&#160;<i>height</i>, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>Returns a scaled copy of the image. The returned image is scaled
to the given <i>height</i> using the specified transformation
<i>mode</i>.</p>
<p>This function automatically calculates the width of the image so
that the ratio of the image is preserved.</p>
<p>If the given <i>height</i> is 0 or negative, a null image is
returned.</p>
<p><b>See also</b> <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="scaledToWidth" /><a href="qimage.html">QImage</a> QImage.scaledToWidth (<i>self</i>, int&#160;<i>width</i>, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>Returns a scaled copy of the image. The returned image is scaled
to the given <i>width</i> using the specified transformation
<i>mode</i>.</p>
<p>This function automatically calculates the height of the image
so that its aspect ratio is preserved.</p>
<p>If the given <i>width</i> is 0 or negative, a null image is
returned.</p>
<p><b>See also</b> <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="scanLine" />sip.voidptr QImage.scanLine (<i>self</i>, int)</h3><p>Returns a pointer to the pixel data at the scanline with index
<i>i</i>. The first scanline is at index 0.</p>
<p>The scanline data is aligned on a 32-bit boundary.</p>
<p><b>Warning:</b> If you are accessing 32-bpp image data, cast the
returned pointer to <tt>QRgb*</tt> (<a href="qcolor.html#QRgb-typedef">QRgb</a> has a 32-bit size) and use it
to read/write the pixel value. You cannot use the <tt>uchar*</tt>
pointer directly, because the pixel format depends on the byte
order on the underlying platform. Use <a href="qtgui.html#qRed">qRed</a>(), <a href="qtgui.html#qGreen">qGreen</a>(), <a href="qtgui.html#qBlue">qBlue</a>(), and <a href="qtgui.html#qAlpha">qAlpha</a>() to access the pixels.</p>
<p><b>See also</b> <a href="qimage.html#bytesPerLine">bytesPerLine</a>(), <a href="qimage.html#bits">bits</a>(), <a href="qimage.html#pixel-manipulation">Pixel Manipulation</a>, and
<a href="qimage.html#constScanLine">constScanLine</a>().</p>


<h3 class="fn"><a name="serialNumber" />int QImage.serialNumber (<i>self</i>)</h3><h3 class="fn"><a name="setAlphaChannel" />QImage.setAlphaChannel (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>alphaChannel</i>)</h3><h3 class="fn"><a name="setColor" />QImage.setColor (<i>self</i>, int&#160;<i>i</i>, int&#160;<i>c</i>)</h3><p>Sets the color at the given <i>index</i> in the color table, to
the given to <i>colorValue</i>. The color value is an ARGB
quadruplet.</p>
<p>If <i>index</i> is outside the current size of the color table,
it is expanded with <a href="qimage.html#setColorCount">setColorCount</a>().</p>
<p><b>See also</b> <a href="qimage.html#color">color</a>(),
<a href="qimage.html#colorCount">colorCount</a>(), <a href="qimage.html#setColorTable">setColorTable</a>(), and <a href="qimage.html#pixel-manipulation">Pixel Manipulation</a>.</p>


<h3 class="fn"><a name="setColorCount" />QImage.setColorCount (<i>self</i>, int)</h3><p>Resizes the color table to contain <i>colorCount</i>
entries.</p>
<p>If the color table is expanded, all the extra colors will be set
to transparent (i.e qRgba(0, 0, 0, 0)).</p>
<p>When the image is used, the color table must be large enough to
have entries for all the pixel/index values present in the image,
otherwise the results are undefined.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qimage.html#colorCount">colorCount</a>(), <a href="qimage.html#colorTable">colorTable</a>(), <a href="qimage.html#setColor">setColor</a>(), and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="setColorTable" />QImage.setColorTable (<i>self</i>, list-of-int&#160;<i>colors</i>)</h3><p>Sets the color table used to translate color indexes to <a href="qcolor.html#QRgb-typedef">QRgb</a> values, to the specified
<i>colors</i>.</p>
<p>When the image is used, the color table must be large enough to
have entries for all the pixel/index values present in the image,
otherwise the results are undefined.</p>
<p><b>See also</b> <a href="qimage.html#colorTable">colorTable</a>(), <a href="qimage.html#setColor">setColor</a>(), and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="setDotsPerMeterX" />QImage.setDotsPerMeterX (<i>self</i>, int)</h3><p>Sets the number of pixels that fit horizontally in a physical
meter, to <i>x</i>.</p>
<p>Together with <a href="qimage.html#dotsPerMeterY">dotsPerMeterY</a>(), this number
defines the intended scale and aspect ratio of the image, and
determines the scale at which <a href="qpainter.html">QPainter</a>
will draw graphics on the image. It does not change the scale or
aspect ratio of the image when it is rendered on other paint
devices.</p>
<p><b>See also</b> <a href="qimage.html#dotsPerMeterX">dotsPerMeterX</a>() and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="setDotsPerMeterY" />QImage.setDotsPerMeterY (<i>self</i>, int)</h3><p>Sets the number of pixels that fit vertically in a physical
meter, to <i>y</i>.</p>
<p>Together with <a href="qimage.html#dotsPerMeterX">dotsPerMeterX</a>(), this number
defines the intended scale and aspect ratio of the image, and
determines the scale at which <a href="qpainter.html">QPainter</a>
will draw graphics on the image. It does not change the scale or
aspect ratio of the image when it is rendered on other paint
devices.</p>
<p><b>See also</b> <a href="qimage.html#dotsPerMeterY">dotsPerMeterY</a>() and <a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="setNumColors" />QImage.setNumColors (<i>self</i>, int)</h3><h3 class="fn"><a name="setOffset" />QImage.setOffset (<i>self</i>, <a href="qpoint.html">QPoint</a>)</h3><p>Sets the number of pixels by which the image is intended to be
offset by when positioning relative to other images, to
<i>offset</i>.</p>
<p><b>See also</b> <a href="qimage.html#offset">offset</a>() and
<a href="qimage.html#image-information">Image Information</a>.</p>


<h3 class="fn"><a name="setPixel" />QImage.setPixel (<i>self</i>, <a href="qpoint.html">QPoint</a>&#160;<i>pt</i>, int&#160;<i>index_or_rgb</i>)</h3><p>Sets the pixel index or color at the given <i>position</i> to
<i>index_or_rgb</i>.</p>
<p>If the image's format is either monochrome or 8-bit, the given
<i>index_or_rgb</i> value must be an index in the image's color
table, otherwise the parameter must be a <a href="qcolor.html#QRgb-typedef">QRgb</a> value.</p>
<p>If <i>position</i> is not a valid coordinate pair in the image,
or if <i>index_or_rgb</i> &gt;= <a href="qimage.html#colorCount">colorCount</a>() in the case of monochrome
and 8-bit images, the result is undefined.</p>
<p><b>Warning:</b> This function is expensive due to the call of
the internal <tt>detach()</tt> function called within; if
performance is a concern, we recommend the use of <a href="qimage.html#scanLine">scanLine()</a> to access pixel data
directly.</p>
<p><b>See also</b> <a href="qimage.html#pixel">pixel</a>() and
<a href="qimage.html#pixel-manipulation">Pixel
Manipulation</a>.</p>


<h3 class="fn"><a name="setPixel-2" />QImage.setPixel (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>, int&#160;<i>index_or_rgb</i>)</h3><p>This is an overloaded function.</p>
<p>Sets the pixel index or color at (<i>x</i>, <i>y</i>) to
<i>index_or_rgb</i>.</p>


<h3 class="fn"><a name="setText" />QImage.setText (<i>self</i>, QString&#160;<i>key</i>, QString&#160;<i>value</i>)</h3><p>Sets the image text to the given <i>text</i> and associate it
with the given <i>key</i>.</p>
<p>If you just want to store a single text block (i.e., a "comment"
or just a description), you can either pass an empty key, or use a
generic key like "Description".</p>
<p>The image text is embedded into the image data when you call
<a href="qimage.html#save">save</a>() or <a href="qimagewriter.html#write">QImageWriter.write</a>().</p>
<p>Not all image formats support embedded text. You can find out if
a specific image or format supports embedding text by using
<a href="qimagewriter.html#supportsOption">QImageWriter.supportsOption</a>().
We give an example:</p>
<pre class="cpp">
         <span class="type"><a href="qimagewriter.html">QImageWriter</a></span> writer;
         writer<span class="operator">.</span>setFormat(<span class="string">"png"</span>);
         <span class="keyword">if</span> (writer<span class="operator">.</span>supportsOption(<span class="type"><a href="qimageiohandler.html">QImageIOHandler</a></span><span class="operator">.</span>Description))
             <a href="qtcore.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Png supports embedded text"</span>;
</pre>
<p>You can use <a href="qimagewriter.html#supportedImageFormats">QImageWriter.supportedImageFormats</a>()
to find out which image formats are available to you.</p>
<p><b>See also</b> <a href="qimage.html#text">text</a>() and
<a href="qimage.html#textKeys">textKeys</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QImage.size (<i>self</i>)</h3><p>Returns the size of the image, i.e. its <a href="qimage.html#width">width</a>() and <a href="qimage.html#height">height</a>().</p>
<p><b>See also</b> <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="swap" />QImage.swap (<i>self</i>, <a href="qimage.html">QImage</a>&#160;<i>other</i>)</h3><p>Swaps image <i>other</i> with this image. This operation is very
fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>


<h3 class="fn"><a name="text" />QString QImage.text (<i>self</i>, QString&#160;<i>key</i>&#160;=&#160;QString())</h3><p>Returns the image text associated with the given <i>key</i>. If
the specified <i>key</i> is an empty string, the whole image text
is returned, with each key-text pair separated by a newline.</p>
<p><b>See also</b> <a href="qimage.html#setText">setText</a>() and
<a href="qimage.html#textKeys">textKeys</a>().</p>


<h3 class="fn"><a name="textKeys" />QStringList QImage.textKeys (<i>self</i>)</h3><p>Returns the text keys for this image.</p>
<p>You can use these keys with <a href="qimage.html#text">text</a>() to list the image text for a certain
key.</p>
<p><b>See also</b> <a href="qimage.html#text">text</a>().</p>


<h3 class="fn"><a name="transformed" /><a href="qimage.html">QImage</a> QImage.transformed (<i>self</i>, <a href="qmatrix.html">QMatrix</a>&#160;<i>matrix</i>, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>Returns a copy of the image that is transformed using the given
transformation <i>matrix</i> and transformation <i>mode</i>.</p>
<p>The transformation <i>matrix</i> is internally adjusted to
compensate for unwanted translation; i.e. the image produced is the
smallest image that contains all the transformed points of the
original image. Use the <a href="qimage.html#trueMatrix">trueMatrix</a>() function to retrieve the
actual matrix used for transforming an image.</p>
<p><b>See also</b> <a href="qimage.html#trueMatrix">trueMatrix</a>() and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="transformed-2" /><a href="qimage.html">QImage</a> QImage.transformed (<i>self</i>, <a href="qtransform.html">QTransform</a>&#160;<i>matrix</i>, <a href="qt.html#TransformationMode-enum">Qt.TransformationMode</a>&#160;<i>mode</i>&#160;=&#160;Qt.FastTransformation)</h3><p>Returns a copy of the image that is transformed using the given
transformation <i>matrix</i> and transformation <i>mode</i>.</p>
<p>The transformation <i>matrix</i> is internally adjusted to
compensate for unwanted translation; i.e. the image produced is the
smallest image that contains all the transformed points of the
original image. Use the <a href="qimage.html#trueMatrix">trueMatrix</a>() function to retrieve the
actual matrix used for transforming an image.</p>
<p>Unlike the other overload, this function can be used to perform
perspective transformations on images.</p>
<p><b>See also</b> <a href="qimage.html#trueMatrix">trueMatrix</a>() and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="trueMatrix" /><a href="qmatrix.html">QMatrix</a> QImage.trueMatrix (<a href="qmatrix.html">QMatrix</a>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><p>Returns the actual matrix used for transforming an image with
the given <i>width</i>, <i>height</i> and <i>matrix</i>.</p>
<p>When transforming an image using the <a href="qimage.html#transformed">transformed</a>() function, the
transformation matrix is internally adjusted to compensate for
unwanted translation, i.e. <a href="qimage.html#transformed">transformed</a>() returns the smallest
image containing all transformed points of the original image. This
function returns the modified matrix, which maps points correctly
from the original image into the new image.</p>
<p><b>See also</b> <a href="qimage.html#transformed">transformed</a>() and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="trueMatrix-2" /><a href="qtransform.html">QTransform</a> QImage.trueMatrix (<a href="qtransform.html">QTransform</a>, int&#160;<i>w</i>, int&#160;<i>h</i>)</h3><p>Returns the actual matrix used for transforming an image with
the given <i>width</i>, <i>height</i> and <i>matrix</i>.</p>
<p>When transforming an image using the <a href="qimage.html#transformed">transformed</a>() function, the
transformation matrix is internally adjusted to compensate for
unwanted translation, i.e. <a href="qimage.html#transformed">transformed</a>() returns the smallest
image containing all transformed points of the original image. This
function returns the modified matrix, which maps points correctly
from the original image into the new image.</p>
<p>Unlike the other overload, this function creates transformation
matrices that can be used to perform perspective transformations on
images.</p>
<p><b>See also</b> <a href="qimage.html#transformed">transformed</a>() and <a href="qimage.html#image-transformations">Image Transformations</a>.</p>


<h3 class="fn"><a name="valid" />bool QImage.valid (<i>self</i>, <a href="qpoint.html">QPoint</a>&#160;<i>pt</i>)</h3><p>Returns true if <i>pos</i> is a valid coordinate pair within the
image; otherwise returns false.</p>
<p><b>See also</b> <a href="qimage.html#rect">rect</a>() and
<a href="qrect.html#contains">QRect.contains</a>().</p>


<h3 class="fn"><a name="valid-2" />bool QImage.valid (<i>self</i>, int&#160;<i>x</i>, int&#160;<i>y</i>)</h3><p>This is an overloaded function.</p>
<p>Returns true if <a href="qpoint.html">QPoint</a>(<i>x</i>,
<i>y</i>) is a valid coordinate pair within the image; otherwise
returns false.</p>


<h3 class="fn"><a name="width" />int QImage.width (<i>self</i>)</h3><p>Returns the width of the image.</p>
<p><b>See also</b> <a href="qimage.html#image-information">Image
Information</a>.</p>


<h3 class="fn"><a name="__eq__" />bool QImage.__eq__ (<i>self</i>, <a href="qimage.html">QImage</a>)</h3><h3 class="fn"><a name="__ne__" />bool QImage.__ne__ (<i>self</i>, <a href="qimage.html">QImage</a>)</h3><address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>