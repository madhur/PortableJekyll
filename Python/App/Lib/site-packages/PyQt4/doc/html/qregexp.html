<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QRegExp Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QRegExp Class Reference<br /><sup><sup>[<a href="qtcore.html">QtCore</a> module]</sup></sup></h1><p>The QRegExp class provides pattern matching using regular
expressions. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qregexp.html#CaretMode-enum">CaretMode</a></b> { CaretAtZero, CaretAtOffset, CaretWontMatch }</li><li><div class="fn" />enum <b><a href="qregexp.html#PatternSyntax-enum">PatternSyntax</a></b> { RegExp, RegExp2, Wildcard, FixedString, WildcardUnix, W3CXmlSchema11 }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qregexp.html#QRegExp">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qregexp.html#QRegExp-2">__init__</a></b> (<i>self</i>, QString&#160;<i>pattern</i>, Qt.CaseSensitivity&#160;<i>cs</i>&#160;=&#160;Qt.CaseSensitive, PatternSyntax&#160;<i>syntax</i>&#160;=&#160;QRegExp.RegExp)</li><li><div class="fn" /><b><a href="qregexp.html#QRegExp-3">__init__</a></b> (<i>self</i>, QRegExp&#160;<i>rx</i>)</li><li><div class="fn" />QString <b><a href="qregexp.html#cap">cap</a></b> (<i>self</i>, int&#160;<i>nth</i>&#160;=&#160;0)</li><li><div class="fn" />int <b><a href="qregexp.html#captureCount">captureCount</a></b> (<i>self</i>)</li><li><div class="fn" />QStringList <b><a href="qregexp.html#capturedTexts">capturedTexts</a></b> (<i>self</i>)</li><li><div class="fn" />Qt.CaseSensitivity <b><a href="qregexp.html#caseSensitivity">caseSensitivity</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qregexp.html#errorString">errorString</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qregexp.html#exactMatch">exactMatch</a></b> (<i>self</i>, QString&#160;<i>str</i>)</li><li><div class="fn" />int <b><a href="qregexp.html#indexIn">indexIn</a></b> (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>offset</i>&#160;=&#160;0, CaretMode&#160;<i>caretMode</i>&#160;=&#160;QRegExp.CaretAtZero)</li><li><div class="fn" />bool <b><a href="qregexp.html#isEmpty">isEmpty</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qregexp.html#isMinimal">isMinimal</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qregexp.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qregexp.html#lastIndexIn">lastIndexIn</a></b> (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>offset</i>&#160;=&#160;-1, CaretMode&#160;<i>caretMode</i>&#160;=&#160;QRegExp.CaretAtZero)</li><li><div class="fn" />int <b><a href="qregexp.html#matchedLength">matchedLength</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qregexp.html#numCaptures">numCaptures</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qregexp.html#pattern">pattern</a></b> (<i>self</i>)</li><li><div class="fn" />PatternSyntax <b><a href="qregexp.html#patternSyntax">patternSyntax</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qregexp.html#pos">pos</a></b> (<i>self</i>, int&#160;<i>nth</i>&#160;=&#160;0)</li><li><div class="fn" /><b><a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a></b> (<i>self</i>, Qt.CaseSensitivity&#160;<i>cs</i>)</li><li><div class="fn" /><b><a href="qregexp.html#setMinimal">setMinimal</a></b> (<i>self</i>, bool&#160;<i>minimal</i>)</li><li><div class="fn" /><b><a href="qregexp.html#setPattern">setPattern</a></b> (<i>self</i>, QString&#160;<i>pattern</i>)</li><li><div class="fn" /><b><a href="qregexp.html#setPatternSyntax">setPatternSyntax</a></b> (<i>self</i>, PatternSyntax&#160;<i>syntax</i>)</li><li><div class="fn" /><b><a href="qregexp.html#swap">swap</a></b> (<i>self</i>, QRegExp&#160;<i>other</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" />QString <b><a href="qregexp.html#escape">escape</a></b> (QString&#160;<i>str</i>)</li></ul><h3>Special Methods</h3><ul><li><div class="fn" />bool <b><a href="qregexp.html#__eq__">__eq__</a></b> (<i>self</i>, QRegExp&#160;<i>rx</i>)</li><li><div class="fn" />bool <b><a href="qregexp.html#__ne__">__ne__</a></b> (<i>self</i>, QRegExp&#160;<i>rx</i>)</li><li><div class="fn" />str <b><a href="qregexp.html#__repr__">__repr__</a></b> (<i>self</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QRegExp class provides pattern matching using regular
expressions.</p>
<a id="regular-expression" name="regular-expression" />
<p>A regular expression, or "regexp", is a pattern for matching
substrings in a text. This is useful in many contexts, e.g.,</p>
<table class="generic">
<tr class="odd" valign="top">
<td>Validation</td>
<td>A regexp can test whether a substring meets some criteria, e.g.
is an integer or contains no whitespace.</td>
</tr>
<tr class="even" valign="top">
<td>Searching</td>
<td>A regexp provides more powerful pattern matching than simple
substring matching, e.g., match one of the words <i>mail</i>,
<i>letter</i> or <i>correspondence</i>, but none of the words
<i>email</i>, <i>mailman</i>, <i>mailer</i>, <i>letterbox</i>,
etc.</td>
</tr>
<tr class="odd" valign="top">
<td>Search and Replace</td>
<td>A regexp can replace all occurrences of a substring with a
different substring, e.g., replace all occurrences of <i>&amp;</i>
with <i>&amp;amp;</i> except where the <i>&amp;</i> is already
followed by an <i>amp;</i>.</td>
</tr>
<tr class="even" valign="top">
<td>String Splitting</td>
<td>A regexp can be used to identify where a string should be split
apart, e.g. splitting tab-delimited strings.</td>
</tr>
</table>
<p>A brief introduction to regexps is presented, a description of
Qt's regexp language, some examples, and the function documentation
itself. QRegExp is modeled on Perl's regexp language. It fully
supports Unicode. QRegExp can also be used in a simpler,
<i>wildcard mode</i> that is similar to the functionality found in
command shells. The syntax rules used by QRegExp can be changed
with <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(). In
particular, the pattern syntax can be set to <a href="qregexp.html#PatternSyntax-enum">QRegExp.FixedString</a>, which
means the pattern to be matched is interpreted as a plain string,
i.e., special characters (e.g., backslash) are not escaped.</p>
<p>A good text on regexps is <i>Mastering Regular Expressions</i>
(Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4.</p>
<a id="introduction" name="introduction" />
<h3>Introduction</h3>
<p>Regexps are built up from expressions, quantifiers, and
assertions. The simplest expression is a character, e.g. <b>x</b>
or <b>5</b>. An expression can also be a set of characters enclosed
in square brackets. <b>[ABCD]</b> will match an <b>A</b> or a
<b>B</b> or a <b>C</b> or a <b>D</b>. We can write this same
expression as <b>[A-D]</b>, and an experession to match any
captital letter in the English alphabet is written as
<b>[A-Z]</b>.</p>
<p>A quantifier specifies the number of occurrences of an
expression that must be matched. <b>x{1,1}</b> means match one and
only one <b>x</b>. <b>x{1,5}</b> means match a sequence of <b>x</b>
characters that contains at least one <b>x</b> but no more than
five.</p>
<p>Note that in general regexps cannot be used to check for
balanced brackets or tags. For example, a regexp can be written to
match an opening html <tt>&lt;b&gt;</tt> and its closing
<tt>&lt;/b&gt;</tt>, if the <tt>&lt;b&gt;</tt> tags are not nested,
but if the <tt>&lt;b&gt;</tt> tags are nested, that same regexp
will match an opening <tt>&lt;b&gt;</tt> tag with the wrong closing
<tt>&lt;/b&gt;</tt>. For the fragment <tt>&lt;b&gt;bold
&lt;b&gt;bolder&lt;/b&gt;&lt;/b&gt;</tt>, the first
<tt>&lt;b&gt;</tt> would be matched with the first
<tt>&lt;/b&gt;</tt>, which is not correct. However, it is possible
to write a regexp that will match nested brackets or tags
correctly, but only if the number of nesting levels is fixed and
known. If the number of nesting levels is not fixed and known, it
is impossible to write a regexp that will not fail.</p>
<p>Suppose we want a regexp to match integers in the range 0 to 99.
At least one digit is required, so we start with the expression
<b>[0-9]{1,1}</b>, which matches a single digit exactly once. This
regexp matches integers in the range 0 to 9. To match integers up
to 99, increase the maximum number of occurrences to 2, so the
regexp becomes <b>[0-9]{1,2}</b>. This regexp satisfies the
original requirement to match integers from 0 to 99, but it will
also match integers that occur in the middle of strings. If we want
the matched integer to be the whole string, we must use the anchor
assertions, <b>^</b> (caret) and <b>$</b> (dollar). When <b>^</b>
is the first character in a regexp, it means the regexp must match
from the beginning of the string. When <b>$</b> is the last
character of the regexp, it means the regexp must match to the end
of the string. The regexp becomes <b>^[0-9]{1,2}$</b>. Note that
assertions, e.g. <b>^</b> and <b>$</b>, do not match characters but
locations in the string.</p>
<p>If you have seen regexps described elsewhere, they may have
looked different from the ones shown here. This is because some
sets of characters and some quantifiers are so common that they
have been given special symbols to represent them. <b>[0-9]</b> can
be replaced with the symbol <b>\d</b>. The quantifier to match
exactly one occurrence, <b>{1,1}</b>, can be replaced with the
expression itself, i.e. <b>x{1,1}</b> is the same as <b>x</b>. So
our 0 to 99 matcher could be written as <b>^\d{1,2}$</b>. It can
also be written <b>^\d\d{0,1}$</b>, i.e. <i>From the start of the
string, match a digit, followed immediately by 0 or 1 digits</i>.
In practice, it would be written as <b>^\d\d?$</b>. The <b>?</b> is
shorthand for the quantifier <b>{0,1}</b>, i.e. 0 or 1 occurrences.
<b>?</b> makes an expression optional. The regexp <b>^\d\d?$</b>
means <i>From the beginning of the string, match one digit,
followed immediately by 0 or 1 more digit, followed immediately by
end of string</i>.</p>
<p>To write a regexp that matches one of the words 'mail' <i>or</i>
'letter' <i>or</i> 'correspondence' but does not match words that
contain these words, e.g., 'email', 'mailman', 'mailer', and
'letterbox', start with a regexp that matches 'mail'. Expressed
fully, the regexp is <b>m{1,1}a{1,1}i{1,1}l{1,1}</b>, but because a
character expression is automatically quantified by <b>{1,1}</b>,
we can simplify the regexp to <b>mail</b>, i.e., an 'm' followed by
an 'a' followed by an 'i' followed by an 'l'. Now we can use the
vertical bar <b>|</b>, which means <b>or</b>, to include the other
two words, so our regexp for matching any of the three words
becomes <b>mail|letter|correspondence</b>. Match 'mail' <b>or</b>
'letter' <b>or</b> 'correspondence'. While this regexp will match
one of the three words we want to match, it will also match words
we don't want to match, e.g., 'email'. To prevent the regexp from
matching unwanted words, we must tell it to begin and end the match
at word boundaries. First we enclose our regexp in parentheses,
<b>(mail|letter|correspondence)</b>. Parentheses group expressions
together, and they identify a part of the regexp that we wish to
<a href="#capturing-text">capture</a>. Enclosing the expression in
parentheses allows us to use it as a component in more complex
regexps. It also allows us to examine which of the three words was
actually matched. To force the match to begin and end on word
boundaries, we enclose the regexp in <b>\b</b> <i>word boundary</i>
assertions: <b>\b(mail|letter|correspondence)\b</b>. Now the regexp
means: <i>Match a word boundary, followed by the regexp in
parentheses, followed by a word boundary</i>. The <b>\b</b>
assertion matches a <i>position</i> in the regexp, not a
<i>character</i>. A word boundary is any non-word character, e.g.,
a space, newline, or the beginning or ending of a string.</p>
<p>If we want to replace ampersand characters with the HTML entity
<b>&amp;amp;</b>, the regexp to match is simply <b>&amp;</b>. But
this regexp will also match ampersands that have already been
converted to HTML entities. We want to replace only ampersands that
are not already followed by <b>amp;</b>. For this, we need the
negative lookahead assertion, <b>(?!</b><a href="index.html">__</a><b>)</b>. The regexp can then be written as
<b>&amp;(?!amp;)</b>, i.e. <i>Match an ampersand that is</i>
<b>not</b> <i>followed by</i> <b>amp;</b>.</p>
<p>If we want to count all the occurrences of 'Eric' and 'Eirik' in
a string, two valid solutions are <b>\b(Eric|Eirik)\b</b> and
<b>\bEi?ri[ck]\b</b>. The word boundary assertion '\b' is required
to avoid matching words that contain either name, e.g. 'Ericsson'.
Note that the second regexp matches more spellings than we want:
'Eric', 'Erik', 'Eiric' and 'Eirik'.</p>
<p>Some of the examples discussed above are implemented in the
<a href="#code-examples">code examples</a> section.</p>
<a id="characters-and-abbreviations-for-sets-of-characters" name="characters-and-abbreviations-for-sets-of-characters" /><a id="characters-and-abbreviations-for-sets-of-characters" name="characters-and-abbreviations-for-sets-of-characters" />
<h3>Characters and Abbreviations for Sets of Characters</h3>
<table class="generic">
<thead>
<tr class="qt-style">
<th>Element</th>
<th>Meaning</th>
</tr>
</thead>
<tr class="odd" valign="top">
<td><b>c</b></td>
<td>A character represents itself unless it has a special regexp
meaning. e.g. <b>c</b> matches the character <i>c</i>.</td>
</tr>
<tr class="even" valign="top">
<td><b>\c</b></td>
<td>A character that follows a backslash matches the character
itself, except as specified below. e.g., To match a literal caret
at the beginning of a string, write <b>\^</b>.</td>
</tr>
<tr class="odd" valign="top">
<td><b>\a</b></td>
<td>Matches the ASCII bell (BEL, 0x07).</td>
</tr>
<tr class="even" valign="top">
<td><b>\f</b></td>
<td>Matches the ASCII form feed (FF, 0x0C).</td>
</tr>
<tr class="odd" valign="top">
<td><b>\n</b></td>
<td>Matches the ASCII line feed (LF, 0x0A, Unix newline).</td>
</tr>
<tr class="even" valign="top">
<td><b>\r</b></td>
<td>Matches the ASCII carriage return (CR, 0x0D).</td>
</tr>
<tr class="odd" valign="top">
<td><b>\t</b></td>
<td>Matches the ASCII horizontal tab (HT, 0x09).</td>
</tr>
<tr class="even" valign="top">
<td><b>\v</b></td>
<td>Matches the ASCII vertical tab (VT, 0x0B).</td>
</tr>
<tr class="odd" valign="top">
<td><b>\x<i>hhhh</i></b></td>
<td>Matches the Unicode character corresponding to the hexadecimal
number <i>hhhh</i> (between 0x0000 and 0xFFFF).</td>
</tr>
<tr class="even" valign="top">
<td><b>\0<i>ooo</i></b> (i.e., \zero <i>ooo</i>)</td>
<td>matches the ASCII/Latin1 character for the octal number
<i>ooo</i> (between 0 and 0377).</td>
</tr>
<tr class="odd" valign="top">
<td><b>. (dot)</b></td>
<td>Matches any character (including newline).</td>
</tr>
<tr class="even" valign="top">
<td><b>\d</b></td>
<td>Matches a digit (<a href="qchar.html#isDigit">QChar.isDigit</a>()).</td>
</tr>
<tr class="odd" valign="top">
<td><b>\D</b></td>
<td>Matches a non-digit.</td>
</tr>
<tr class="even" valign="top">
<td><b>\s</b></td>
<td>Matches a whitespace character (<a href="qchar.html#isSpace">QChar.isSpace</a>()).</td>
</tr>
<tr class="odd" valign="top">
<td><b>\S</b></td>
<td>Matches a non-whitespace character.</td>
</tr>
<tr class="even" valign="top">
<td><b>\w</b></td>
<td>Matches a word character (<a href="qchar.html#isLetterOrNumber">QChar.isLetterOrNumber</a>(),
<a href="qchar.html#isMark">QChar.isMark</a>(), or '<a href="index.html">_</a>').</td>
</tr>
<tr class="odd" valign="top">
<td><b>\W</b></td>
<td>Matches a non-word character.</td>
</tr>
<tr class="even" valign="top">
<td><b>\<i>n</i></b></td>
<td>The <i>n</i>-th <a href="#backreferences">backreference</a>,
e.g. \1, \2, etc.</td>
</tr>
</table>
<p><b>Note:</b> The C++ compiler transforms backslashes in strings.
To include a <b>\</b> in a regexp, enter it twice, i.e.
<tt>\\</tt>. To match the backslash character itself, enter it four
times, i.e. <tt>\\\\</tt>.</p>
<a id="sets-of-characters" name="sets-of-characters" /><a id="sets-of-characters" name="sets-of-characters" />
<h3>Sets of Characters</h3>
<p>Square brackets mean match any character contained in the square
brackets. The character set abbreviations described above can
appear in a character set in square brackets. Except for the
character set abbreviations and the following two exceptions,
characters do not have special meanings in square brackets.</p>
<table class="generic">
<tr class="odd" valign="top">
<td><b>^</b></td>
<td>The caret negates the character set if it occurs as the first
character (i.e. immediately after the opening square bracket).
<b>[abc]</b> matches 'a' or 'b' or 'c', but <b>[^abc]</b> matches
anything <i>but</i> 'a' or 'b' or 'c'.</td>
</tr>
<tr class="even" valign="top">
<td><b>-</b></td>
<td>The dash indicates a range of characters. <b>[W-Z]</b> matches
'W' or 'X' or 'Y' or 'Z'.</td>
</tr>
</table>
<p>Using the predefined character set abbreviations is more
portable than using character ranges across platforms and
languages. For example, <b>[0-9]</b> matches a digit in Western
alphabets but <b>\d</b> matches a digit in <i>any</i> alphabet.</p>
<p>Note: In other regexp documentation, sets of characters are
often called "character classes".</p>
<a id="quantifiers" name="quantifiers" /><a id="quantifiers" name="quantifiers" />
<h3>Quantifiers</h3>
<p>By default, an expression is automatically quantified by
<b>{1,1}</b>, i.e. it should occur exactly once. In the following
list, <b><i>E</i></b> stands for expression. An expression is a
character, or an abbreviation for a set of characters, or a set of
characters in square brackets, or an expression in parentheses.</p>
<table class="generic">
<tr class="odd" valign="top">
<td><b><i>E</i>?</b></td>
<td>Matches zero or one occurrences of <i>E</i>. This quantifier
means <i>The previous expression is optional</i>, because it will
match whether or not the expression is found. <b><i>E</i>?</b> is
the same as <b><i>E</i>{0,1}</b>. e.g., <b>dents?</b> matches
'dent' or 'dents'.</td>
</tr>
<tr class="even" valign="top">
<td><b><i>E</i>+</b></td>
<td>Matches one or more occurrences of <i>E</i>. <b><i>E</i>+</b>
is the same as <b><i>E</i>{1,}</b>. e.g., <b>0+</b> matches '0',
'00', '000', etc.</td>
</tr>
<tr class="odd" valign="top">
<td><b><i>E</i>*</b></td>
<td>Matches zero or more occurrences of <i>E</i>. It is the same as
<b><i>E</i>{0,}</b>. The <b>*</b> quantifier is often used in error
where <b>+</b> should be used. For example, if <b>\s*$</b> is used
in an expression to match strings that end in whitespace, it will
match every string because <b>\s*$</b> means <i>Match zero or more
whitespaces followed by end of string</i>. The correct regexp to
match strings that have at least one trailing whitespace character
is <b>\s+$</b>.</td>
</tr>
<tr class="even" valign="top">
<td><b><i>E</i>{n}</b></td>
<td>Matches exactly <i>n</i> occurrences of <i>E</i>.
<b><i>E</i>{n}</b> is the same as repeating <i>E</i> <i>n</i>
times. For example, <b>x{5}</b> is the same as <b>xxxxx</b>. It is
also the same as <b><i>E</i>{n,n}</b>, e.g. <b>x{5,5}</b>.</td>
</tr>
<tr class="odd" valign="top">
<td><b><i>E</i>{n,}</b></td>
<td>Matches at least <i>n</i> occurrences of <i>E</i>.</td>
</tr>
<tr class="even" valign="top">
<td><b><i>E</i>{,m}</b></td>
<td>Matches at most <i>m</i> occurrences of <i>E</i>.
<b><i>E</i>{,m}</b> is the same as <b><i>E</i>{0,m}</b>.</td>
</tr>
<tr class="odd" valign="top">
<td><b><i>E</i>{n,m}</b></td>
<td>Matches at least <i>n</i> and at most <i>m</i> occurrences of
<i>E</i>.</td>
</tr>
</table>
<p>To apply a quantifier to more than just the preceding character,
use parentheses to group characters together in an expression. For
example, <b>tag+</b> matches a 't' followed by an 'a' followed by
at least one 'g', whereas <b>(tag)+</b> matches at least one
occurrence of 'tag'.</p>
<p>Note: Quantifiers are normally "greedy". They always match as
much text as they can. For example, <b>0+</b> matches the first
zero it finds and all the consecutive zeros after the first zero.
Applied to '20005', it matches'2<u>000</u>5'. Quantifiers can be
made non-greedy, see <a href="qregexp.html#setMinimal">setMinimal</a>().</p>
<a id="capturing-parentheses" name="capturing-parentheses" /><a id="backreferences" name="backreferences" /><a id="capturing-text" name="capturing-text" />
<h3>Capturing Text</h3>
<p>Parentheses allow us to group elements together so that we can
quantify and capture them. For example if we have the expression
<b>mail|letter|correspondence</b> that matches a string we know
that <i>one</i> of the words matched but not which one. Using
parentheses allows us to "capture" whatever is matched within their
bounds, so if we used <b>(mail|letter|correspondence)</b> and
matched this regexp against the string "I sent you some email" we
can use the <a href="qregexp.html#cap">cap</a>() or <a href="qregexp.html#capturedTexts">capturedTexts</a>() functions to
extract the matched characters, in this case 'mail'.</p>
<p>We can use captured text within the regexp itself. To refer to
the captured text we use <i>backreferences</i> which are indexed
from 1, the same as for <a href="qregexp.html#cap">cap</a>(). For
example we could search for duplicate words in a string using
<b>\b(\w+)\W+\1\b</b> which means match a word boundary followed by
one or more word characters followed by one or more non-word
characters followed by the same text as the first parenthesized
expression followed by a word boundary.</p>
<p>If we want to use parentheses purely for grouping and not for
capturing we can use the non-capturing syntax, e.g.
<b>(?:green|blue)</b>. Non-capturing parentheses begin '(?:' and
end ')'. In this example we match either 'green' or 'blue' but we
do not capture the match so we only know whether or not we matched
but not which color we actually found. Using non-capturing
parentheses is more efficient than using capturing parentheses
since the regexp engine has to do less book-keeping.</p>
<p>Both capturing and non-capturing parentheses may be nested.</p>
<a id="greedy-quantifiers" name="greedy-quantifiers" />
<p>For historical reasons, quantifiers (e.g. <b>*</b>) that apply
to capturing parentheses are more "greedy" than other quantifiers.
For example, <b>a*(a*)</b> will match "aaa" with cap(1) == "aaa".
This behavior is different from what other regexp engines do
(notably, Perl). To obtain a more intuitive capturing behavior,
specify <a href="qregexp.html#PatternSyntax-enum">QRegExp.RegExp2</a> to the
QRegExp constructor or call setPatternSyntax(<a href="qregexp.html#PatternSyntax-enum">QRegExp.RegExp2</a>).</p>
<a id="cap-in-a-loop" name="cap-in-a-loop" />
<p>When the number of matches cannot be determined in advance, a
common idiom is to use <a href="qregexp.html#cap">cap</a>() in a
loop. For example:</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"(\\d+)"</span>);
 <span class="type"><a href="qstring.html">QString</a></span> str <span class="operator">=</span> <span class="string">"Offsets: 12 14 99 231 7"</span>;
 <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;

 <span class="keyword">while</span> ((pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     list <span class="operator">&lt;</span><span class="operator">&lt;</span> rx<span class="operator">.</span>cap(<span class="number">1</span>);
     pos <span class="operator">+</span><span class="operator">=</span> rx<span class="operator">.</span>matchedLength();
 }
 <span class="comment">// list: ["12", "14", "99", "231", "7"]</span>
</pre>
<a id="assertions" name="assertions" /><a id="assertions" name="assertions" />
<h3>Assertions</h3>
<p>Assertions make some statement about the text at the point where
they occur in the regexp but they do not match any characters. In
the following list <b><i>E</i></b> stands for any expression.</p>
<table class="generic">
<tr class="odd" valign="top">
<td><b>^</b></td>
<td>The caret signifies the beginning of the string. If you wish to
match a literal <tt>^</tt> you must escape it by writing
<tt>\\^</tt>. For example, <b>^#include</b> will only match strings
which <i>begin</i> with the characters '#include'. (When the caret
is the first character of a character set it has a special meaning,
see <a href="#sets-of-characters">Sets of Characters</a>.)</td>
</tr>
<tr class="even" valign="top">
<td><b>$</b></td>
<td>The dollar signifies the end of the string. For example
<b>\d\s*$</b> will match strings which end with a digit optionally
followed by whitespace. If you wish to match a literal <tt>$</tt>
you must escape it by writing <tt>\\$</tt>.</td>
</tr>
<tr class="odd" valign="top">
<td><b>\b</b></td>
<td>A word boundary. For example the regexp <b>\bOK\b</b> means
match immediately after a word boundary (e.g. start of string or
whitespace) the letter 'O' then the letter 'K' immediately before
another word boundary (e.g. end of string or whitespace). But note
that the assertion does not actually match any whitespace so if we
write <b>(\bOK\b)</b> and we have a match it will only contain 'OK'
even if the string is "It's <u>OK</u> now".</td>
</tr>
<tr class="even" valign="top">
<td><b>\B</b></td>
<td>A non-word boundary. This assertion is true wherever <b>\b</b>
is false. For example if we searched for <b>\Bon\B</b> in "Left on"
the match would fail (space and end of string aren't non-word
boundaries), but it would match in "t<u>on</u>ne".</td>
</tr>
<tr class="odd" valign="top">
<td><b>(?=<i>E</i>)</b></td>
<td>Positive lookahead. This assertion is true if the expression
matches at this point in the regexp. For example,
<b>const(?=\s+char)</b> matches 'const' whenever it is followed by
'char', as in 'static <u>const</u> char *'. (Compare with
<b>const\s+char</b>, which matches 'static <u>const char</u>
*'.)</td>
</tr>
<tr class="even" valign="top">
<td><b>(?!<i>E</i>)</b></td>
<td>Negative lookahead. This assertion is true if the expression
does not match at this point in the regexp. For example,
<b>const(?!\s+char)</b> matches 'const' <i>except</i> when it is
followed by 'char'.</td>
</tr>
</table>
<a id="qregexp-wildcard-matching" name="qregexp-wildcard-matching" /><a id="wildcard-matching" name="wildcard-matching" />
<h3>Wildcard Matching</h3>
<p>Most command shells such as <i>bash</i> or <i>cmd.exe</i>
support "file globbing", the ability to identify a group of files
by using wildcards. The <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>() function is
used to switch between regexp and wildcard mode. Wildcard matching
is much simpler than full regexps and has only four features:</p>
<table class="generic">
<tr class="odd" valign="top">
<td><b>c</b></td>
<td>Any character represents itself apart from those mentioned
below. Thus <b>c</b> matches the character <i>c</i>.</td>
</tr>
<tr class="even" valign="top">
<td><b>?</b></td>
<td>Matches any single character. It is the same as <b>.</b> in
full regexps.</td>
</tr>
<tr class="odd" valign="top">
<td><b>*</b></td>
<td>Matches zero or more of any characters. It is the same as
<b>.*</b> in full regexps.</td>
</tr>
<tr class="even" valign="top">
<td><b>[...]</b></td>
<td>Sets of characters can be represented in square brackets,
similar to full regexps. Within the character class, like outside,
backslash has no special meaning.</td>
</tr>
</table>
<p>In the mode Wildcard, the wildcard characters cannot be escaped.
In the mode <a href="qregexp.html#PatternSyntax-enum">WildcardUnix</a>, the character
'\' escapes the wildcard.</p>
<p>For example if we are in wildcard mode and have strings which
contain filenames we could identify HTML files with <b>*.html</b>.
This will match zero or more characters followed by a dot followed
by 'h', 't', 'm' and 'l'.</p>
<p>To test a string against a wildcard expression, use <a href="qregexp.html#exactMatch">exactMatch</a>(). For example:</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"*.txt"</span>);
 rx<span class="operator">.</span><a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(<span class="type">QRegExp</span><span class="operator">.</span>Wildcard);
 rx<span class="operator">.</span><a href="qregexp.html#exactMatch">exactMatch</a>(<span class="string">"README.txt"</span>);        <span class="comment">// returns true</span>
 rx<span class="operator">.</span><a href="qregexp.html#exactMatch">exactMatch</a>(<span class="string">"welcome.txt.bak"</span>);   <span class="comment">// returns false</span>
</pre>
<a id="perl-users" name="perl-users" /><a id="notes-for-perl-users" name="notes-for-perl-users" />
<h3>Notes for Perl Users</h3>
<p>Most of the character class abbreviations supported by Perl are
supported by QRegExp, see <a href="#characters-and-abbreviations-for-sets-of-characters">characters
and abbreviations for sets of characters</a>.</p>
<p>In QRegExp, apart from within character classes, <tt>^</tt>
always signifies the start of the string, so carets must always be
escaped unless used for that purpose. In Perl the meaning of caret
varies automagically depending on where it occurs so escaping it is
rarely necessary. The same applies to <tt>$</tt> which in QRegExp
always signifies the end of the string.</p>
<p>QRegExp's quantifiers are the same as Perl's greedy quantifiers
(but see the <a href="#greedy-quantifiers">note above</a>).
Non-greedy matching cannot be applied to individual quantifiers,
but can be applied to all the quantifiers in the pattern. For
example, to match the Perl regexp <b>ro+?m</b> requires:</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"ro+m"</span>);
 rx<span class="operator">.</span><a href="qregexp.html#setMinimal">setMinimal</a>(<span class="keyword">true</span>);
</pre>
<p>The equivalent of Perl's <tt>/i</tt> option is
setCaseSensitivity(<a href="qt.html#CaseSensitivity-enum">Qt.CaseInsensitive</a>).</p>
<p>Perl's <tt>/g</tt> option can be emulated using a <a href="#cap-in-a-loop">loop</a>.</p>
<p>In QRegExp <b>.</b> matches any character, therefore all QRegExp
regexps have the equivalent of Perl's <tt>/s</tt> option. QRegExp
does not have an equivalent to Perl's <tt>/m</tt> option, but this
can be emulated in various ways for example by splitting the input
into lines or by looping with a regexp that searches for
newlines.</p>
<p>Because QRegExp is string oriented, there are no \A, \Z, or \z
assertions. The \G assertion is not supported but can be emulated
in a loop.</p>
<p>Perl's $&amp; is cap(0) or <a href="qregexp.html#capturedTexts">capturedTexts</a>()[0]. There are no
QRegExp equivalents for $`, $' or $+. Perl's capturing variables,
$1, $2, ... correspond to cap(1) or <a href="qregexp.html#capturedTexts">capturedTexts</a>()[1], cap(2) or
<a href="qregexp.html#capturedTexts">capturedTexts</a>()[2],
etc.</p>
<p>To substitute a pattern use <a href="qstring.html#replace">QString.replace</a>().</p>
<p>Perl's extended <tt>/x</tt> syntax is not supported, nor are
directives, e.g. (?i), or regexp comments, e.g. (?#comment). On the
other hand, C++'s rules for literal strings can be used to achieve
the same:</p>
<pre class="cpp">
 <span class="type">QRegExp</span> mark(<span class="string">"\\b"</span>      <span class="comment">// word boundary</span>
               <span class="string">"[Mm]ark"</span> <span class="comment">// the word we want to match</span>
             );
</pre>
<p>Both zero-width positive and zero-width negative lookahead
assertions (?=pattern) and (?!pattern) are supported with the same
syntax as Perl. Perl's lookbehind assertions, "independent"
subexpressions and conditional expressions are not supported.</p>
<p>Non-capturing parentheses are also supported, with the same
(?:pattern) syntax.</p>
<p>See <a href="qstring.html#split">QString.split</a>() and
<a href="qstringlist.html#join">QStringList.join</a>() for
equivalents to Perl's split and join functions.</p>
<p>Note: because C++ transforms \'s they must be written
<i>twice</i> in code, e.g. <b>\b</b> must be written
<b>\\b</b>.</p>
<a id="code-examples" name="code-examples" /><a id="code-examples" name="code-examples" />
<h3>Code Examples</h3>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"^\\d\\d?$"</span>);    <span class="comment">// match integers 0 to 99</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"123"</span>);          <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"-6"</span>);           <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"6"</span>);            <span class="comment">// returns 0 (matched as position 0)</span>
</pre>
<p>The third string matches '<u>6</u>'. This is a simple validation
regexp for integers in the range 0 to 99.</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"^\\S+$"</span>);       <span class="comment">// match strings without whitespace</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Hello world"</span>);  <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"This_is-OK"</span>);   <span class="comment">// returns 0 (matched at position 0)</span>
</pre>
<p>The second string matches '<u>This_is-OK</u>'. We've used the
character set abbreviation '\S' (non-whitespace) and the anchors to
match strings which contain no whitespace.</p>
<p>In the following example we match strings containing 'mail' or
'letter' or 'correspondence' but only match whole words i.e. not
'email'</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"\\b(mail|letter|correspondence)\\b"</span>);
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"I sent you an email"</span>);     <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Please write the letter"</span>); <span class="comment">// returns 17</span>
</pre>
<p>The second string matches "Please write the <u>letter</u>". The
word 'letter' is also captured (because of the parentheses). We can
see what text we've captured like this:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> captured <span class="operator">=</span> rx<span class="operator">.</span><a href="qregexp.html#cap">cap</a>(<span class="number">1</span>); <span class="comment">// captured == "letter"</span>
</pre>
<p>This will capture the text from the first set of capturing
parentheses (counting capturing left parentheses from left to
right). The parentheses are counted from 1 since cap(0) is the
whole matched regexp (equivalent to '&amp;' in most regexp
engines).</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"&amp;(?!amp;)"</span>);      <span class="comment">// match ampersands but not &amp;amp;</span>
 <span class="type"><a href="qstring.html">QString</a></span> line1 <span class="operator">=</span> <span class="string">"This &amp; that"</span>;
 line1<span class="operator">.</span>replace(rx<span class="operator">,</span> <span class="string">"&amp;amp;"</span>);
 <span class="comment">// line1 == "This &amp;amp; that"</span>
 <span class="type"><a href="qstring.html">QString</a></span> line2 <span class="operator">=</span> <span class="string">"His &amp;amp; hers &amp; theirs"</span>;
 line2<span class="operator">.</span>replace(rx<span class="operator">,</span> <span class="string">"&amp;amp;"</span>);
 <span class="comment">// line2 == "His &amp;amp; hers &amp;amp; theirs"</span>
</pre>
<p>Here we've passed the QRegExp to <a href="qstring.html">QString</a>'s replace() function to replace the
matched text with new text.</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> str <span class="operator">=</span> <span class="string">"One Eric another Eirik, and an Ericsson. "</span>
               <span class="string">"How many Eiriks, Eric?"</span>;
 <span class="type">QRegExp</span> rx(<span class="string">"\\b(Eric|Eirik)\\b"</span>); <span class="comment">// match Eric or Eirik</span>
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// where we are in the string</span>
 <span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// how many Eric and Eirik's we've counted</span>
 <span class="keyword">while</span> (pos <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>) {
     pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos);
     <span class="keyword">if</span> (pos <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="operator">+</span><span class="operator">+</span>pos;      <span class="comment">// move along in str</span>
         <span class="operator">+</span><span class="operator">+</span>count;    <span class="comment">// count our Eric or Eirik</span>
     }
 }
</pre>
<p>We've used the <a href="qregexp.html#indexIn">indexIn</a>()
function to repeatedly match the regexp in the string. Note that
instead of moving forward by one character at a time <tt>pos++</tt>
we could have written <tt>pos += rx.matchedLength()</tt> to skip
over the already matched string. The count will equal 3, matching
'One <u>Eric</u> another <u>Eirik</u>, and an Ericsson. How many
Eiriks, <u>Eric</u>?'; it doesn't match 'Ericsson' or 'Eiriks'
because they are not bounded by non-word boundaries.</p>
<p>One common use of regexps is to split lines of delimited data
into their component fields.</p>
<pre class="cpp">
 str <span class="operator">=</span> <span class="string">"Nokia Corporation\tqt.nokia.com\tNorway"</span>;
 <span class="type"><a href="qstring.html">QString</a></span> company<span class="operator">,</span> web<span class="operator">,</span> country;
 rx<span class="operator">.</span><a href="qregexp.html#setPattern">setPattern</a>(<span class="string">"^([^\t]+)\t([^\t]+)\t([^\t]+)$"</span>);
 <span class="keyword">if</span> (rx<span class="operator">.</span>indexIn(str) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     company <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">1</span>);
     web <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">2</span>);
     country <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">3</span>);
 }
</pre>
<p>In this example our input lines have the format company name,
web address and country. Unfortunately the regexp is rather long
and not very versatile -- the code will break if we add any more
fields. A simpler and better solution is to look for the separator,
'\t' in this case, and take the surrounding text. The <a href="qstring.html#split">QString.split</a>() function can take a
separator string or regexp as an argument and split a string
accordingly.</p>
<pre class="cpp">
 <span class="type"><a href="qstringlist.html">QStringList</a></span> field <span class="operator">=</span> str<span class="operator">.</span>split(<span class="string">"\t"</span>);
</pre>
<p>Here field[0] is the company, field[1] the web address and so
on.</p>
<p>To imitate the matching of a shell we can use wildcard mode.</p>
<pre class="cpp">
 <span class="type">QRegExp</span> rx(<span class="string">"*.html"</span>);
 rx<span class="operator">.</span><a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(<span class="type">QRegExp</span><span class="operator">.</span>Wildcard);
 rx<span class="operator">.</span><a href="qregexp.html#exactMatch">exactMatch</a>(<span class="string">"index.html"</span>);                <span class="comment">// returns true</span>
 rx<span class="operator">.</span><a href="qregexp.html#exactMatch">exactMatch</a>(<span class="string">"default.htm"</span>);               <span class="comment">// returns false</span>
 rx<span class="operator">.</span><a href="qregexp.html#exactMatch">exactMatch</a>(<span class="string">"readme.txt"</span>);                <span class="comment">// returns false</span>
</pre>
<p>Wildcard matching can be convenient because of its simplicity,
but any wildcard regexp can be defined using full regexps, e.g.
<b>.*\.html$</b>. Notice that we can't match both <tt>.html</tt>
and <tt>.htm</tt> files with a wildcard unless we use <b>*.htm*</b>
which will also match 'test.html.bak'. A full regexp gives us the
precision we need, <b>.*\.html?$</b>.</p>
<p>QRegExp can match case insensitively using <a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(), and can
use non-greedy matching, see <a href="qregexp.html#setMinimal">setMinimal</a>(). By default QRegExp uses
full regexps but this can be changed with <a class="compat" href="qregexp-qt3.html#setWildcard">setWildcard</a>().
Searching can be forward with <a href="qregexp.html#indexIn">indexIn</a>() or backward with <a href="qregexp.html#lastIndexIn">lastIndexIn</a>(). Captured text can be
accessed using <a href="qregexp.html#capturedTexts">capturedTexts</a>() which returns a
string list of all captured strings, or using <a href="qregexp.html#cap">cap</a>() which returns the captured string for
the given index. The <a href="qregexp.html#pos">pos</a>() function
takes a match index and returns the position in the string where
the match was made (or -1 if there was no match).</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="CaretMode-enum" />QRegExp.CaretMode</h3><p>The CaretMode enum defines the different meanings of the caret
(<b>^</b>) in a regular expression. The possible values are:</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.CaretAtZero</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The caret corresponds to index 0 in the
searched string.</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.CaretAtOffset</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The caret corresponds to the start offset of
the search.</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.CaretWontMatch</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The caret never matches.</td>
</tr>
</table>


<h3 class="fn"><a name="PatternSyntax-enum" />QRegExp.PatternSyntax</h3><p>The syntax used to interpret the meaning of the pattern.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.RegExp</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">A rich Perl-like pattern matching syntax. This
is the default.</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.RegExp2</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">Like RegExp, but with <a href="qregexp.html#greedy-quantifiers">greedy quantifiers</a>. This will
be the default in Qt 5. (Introduced in Qt 4.2.)</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.Wildcard</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">This provides a simple pattern matching syntax
similar to that used by shells (command interpreters) for "file
globbing". See <a href="qregexp.html#wildcard-matching">Wildcard
Matching</a>.</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.WildcardUnix</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">This is similar to Wildcard but with the
behavior of a Unix shell. The wildcard characters can be escaped
with the character "\".</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.FixedString</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The pattern is a fixed string. This is
equivalent to using the RegExp pattern on a string in which all
metacharacters are escaped using <a href="qregexp.html#escape">escape</a>().</td>
</tr>
<tr>
<td class="topAlign"><tt>QRegExp.W3CXmlSchema11</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The pattern is a regular expression as defined
by the W3C XML Schema 1.1 specification.</td>
</tr>
</table>
<p><b>See also</b> <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QRegExp" />QRegExp.__init__ (<i>self</i>)</h3><p>Constructs an empty regexp.</p>
<p><b>See also</b> <a href="qregexp.html#isValid">isValid</a>() and
<a href="qregexp.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="QRegExp-2" />QRegExp.__init__ (<i>self</i>, QString&#160;<i>pattern</i>, <a href="qt.html#CaseSensitivity-enum">Qt.CaseSensitivity</a>&#160;<i>cs</i>&#160;=&#160;Qt.CaseSensitive, <a href="qregexp.html#PatternSyntax-enum">PatternSyntax</a>&#160;<i>syntax</i>&#160;=&#160;QRegExp.RegExp)</h3><p>Constructs a regular expression object for the given
<i>pattern</i> string. The pattern must be given using wildcard
notation if <i>syntax</i> is <a href="qregexp.html#PatternSyntax-enum">Wildcard</a>; the default is
<a href="qregexp.html#PatternSyntax-enum">RegExp</a>. The pattern
is case sensitive, unless <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt.CaseInsensitive</a>. Matching is
greedy (maximal), but can be changed by calling <a href="qregexp.html#setMinimal">setMinimal</a>().</p>
<p><b>See also</b> <a href="qregexp.html#setPattern">setPattern</a>(), <a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(), and
<a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>().</p>


<h3 class="fn"><a name="QRegExp-3" />QRegExp.__init__ (<i>self</i>, <a href="qregexp.html">QRegExp</a>&#160;<i>rx</i>)</h3><p>Constructs a regular expression as a copy of <i>rx</i>.</p>
<p><b>See also</b> <a href="qregexp.html#operator-eq">operator=</a>().</p>


<h3 class="fn"><a name="cap" />QString QRegExp.cap (<i>self</i>, int&#160;<i>nth</i>&#160;=&#160;0)</h3><p>Returns the text captured by the <i>nth</i> subexpression. The
entire match has index 0 and the parenthesized subexpressions have
indexes starting from 1 (excluding non-capturing parentheses).</p>
<pre class="cpp">
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rxlen(<span class="string">"(\\d+)(?:\\s*)(cm|inch)"</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rxlen<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Length: 189cm"</span>);
 <span class="keyword">if</span> (pos <span class="operator">&gt;</span> <span class="operator">-</span><span class="number">1</span>) {
     <span class="type"><a href="qstring.html">QString</a></span> value <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">1</span>); <span class="comment">// "189"</span>
     <span class="type"><a href="qstring.html">QString</a></span> unit <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">2</span>);  <span class="comment">// "cm"</span>
     <span class="comment">// ...</span>
 }
</pre>
<p>The order of elements matched by cap() is as follows. The first
element, cap(0), is the entire matching string. Each subsequent
element corresponds to the next capturing open left parentheses.
Thus cap(1) is the text of the first capturing parentheses, cap(2)
is the text of the second, and so on.</p>
<p><b>See also</b> <a href="qregexp.html#capturedTexts">capturedTexts</a>() and <a href="qregexp.html#pos">pos</a>().</p>


<h3 class="fn"><a name="captureCount" />int QRegExp.captureCount (<i>self</i>)</h3><p>Returns the number of captures contained in the regular
expression.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="capturedTexts" />QStringList QRegExp.capturedTexts (<i>self</i>)</h3><p>Returns a list of the captured text strings.</p>
<p>The first string in the list is the entire matched string. Each
subsequent list element contains a string that matched a
(capturing) subexpression of the regexp.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rx(<span class="string">"(\\d+)(\\s*)(cm|inch(es)?)"</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Length: 36 inches"</span>);
 <span class="type"><a href="qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="comment">// list is now ("36 inches", "36", " ", "inches", "es")</span>
</pre>
<p>The above example also captures elements that may be present but
which we have no interest in. This problem can be solved by using
non-capturing parentheses:</p>
<pre class="cpp">
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rx(<span class="string">"(\\d+)(?:\\s*)(cm|inch(?:es)?)"</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Length: 36 inches"</span>);
 <span class="type"><a href="qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="comment">// list is now ("36 inches", "36", "inches")</span>
</pre>
<p>Note that if you want to iterate over the list, you should
iterate over a copy, e.g.</p>
<pre class="cpp">
 <span class="type"><a href="qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">.</span>iterator it <span class="operator">=</span> list<span class="operator">.</span>begin();
 <span class="keyword">while</span> (it <span class="operator">!</span><span class="operator">=</span> list<span class="operator">.</span>end()) {
     myProcessing(<span class="operator">*</span>it);
     <span class="operator">+</span><span class="operator">+</span>it;
 }
</pre>
<p>Some regexps can match an indeterminate number of times. For
example if the input string is "Offsets: 12 14 99 231 7" and the
regexp, <tt>rx</tt>, is <b>(\d+)+</b>, we would hope to get a list
of all the numbers matched. However, after calling
<tt>rx.indexIn(str)</tt>, capturedTexts() will return the list
("12", "12"), i.e. the entire match was "12" and the first
subexpression matched was "12". The correct approach is to use
<a href="qregexp.html#cap">cap</a>() in a <a href="qregexp.html#cap-in-a-loop">loop</a>.</p>
<p>The order of elements in the string list is as follows. The
first element is the entire matching string. Each subsequent
element corresponds to the next capturing open left parentheses.
Thus capturedTexts()[1] is the text of the first capturing
parentheses, capturedTexts()[2] is the text of the second and so on
(corresponding to $1, $2, etc., in some other regexp
languages).</p>
<p><b>See also</b> <a href="qregexp.html#cap">cap</a>() and
<a href="qregexp.html#pos">pos</a>().</p>


<h3 class="fn"><a name="caseSensitivity" /><a href="qt.html#CaseSensitivity-enum">Qt.CaseSensitivity</a> QRegExp.caseSensitivity (<i>self</i>)</h3><p>Returns <a href="qt.html#CaseSensitivity-enum">Qt.CaseSensitive</a> if the regexp
is matched case sensitively; otherwise returns <a href="qt.html#CaseSensitivity-enum">Qt.CaseInsensitive</a>.</p>
<p><b>See also</b> <a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(),
<a href="qregexp.html#patternSyntax">patternSyntax</a>(), <a href="qregexp.html#pattern">pattern</a>(), and <a href="qregexp.html#isMinimal">isMinimal</a>().</p>


<h3 class="fn"><a name="errorString" />QString QRegExp.errorString (<i>self</i>)</h3><p>Returns a text string that explains why a regexp pattern is
invalid the case being; otherwise returns "no error occurred".</p>
<p><b>See also</b> <a href="qregexp.html#isValid">isValid</a>().</p>


<h3 class="fn"><a name="escape" />QString QRegExp.escape (QString&#160;<i>str</i>)</h3><p>Returns the string <i>str</i> with every regexp special
character escaped with a backslash. The special characters are $,
(,), *, +, ., ?, [, ,], ^, {, | and }.</p>
<p>Example:</p>
<pre class="cpp">
 s1 <span class="operator">=</span> <span class="type"><a href="qregexp.html">QRegExp</a></span><span class="operator">.</span>escape(<span class="string">"bingo"</span>);   <span class="comment">// s1 == "bingo"</span>
 s2 <span class="operator">=</span> <span class="type"><a href="qregexp.html">QRegExp</a></span><span class="operator">.</span>escape(<span class="string">"f(x)"</span>);    <span class="comment">// s2 == "f\\(x\\)"</span>
</pre>
<p>This function is useful to construct regexp patterns
dynamically:</p>
<pre class="cpp">
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rx(<span class="string">"("</span> <span class="operator">+</span> <span class="type"><a href="qregexp.html">QRegExp</a></span><span class="operator">.</span>escape(name) <span class="operator">+</span>
            <span class="string">"|"</span> <span class="operator">+</span> <span class="type"><a href="qregexp.html">QRegExp</a></span><span class="operator">.</span>escape(alias) <span class="operator">+</span> <span class="string">")"</span>);
</pre>
<p><b>See also</b> <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>().</p>


<h3 class="fn"><a name="exactMatch" />bool QRegExp.exactMatch (<i>self</i>, QString&#160;<i>str</i>)</h3><p>Returns true if <i>str</i> is matched exactly by this regular
expression; otherwise returns false. You can determine how much of
the string was matched by calling <a href="qregexp.html#matchedLength">matchedLength</a>().</p>
<p>For a given regexp string R, exactMatch("R") is the equivalent
of indexIn("^R$") since exactMatch() effectively encloses the
regexp in the start of string and end of string anchors, except
that it sets <a href="qregexp.html#matchedLength">matchedLength</a>() differently.</p>
<p>For example, if the regular expression is <b>blue</b>, then
exactMatch() returns true only for input <tt>blue</tt>. For inputs
<tt>bluebell</tt>, <tt>blutak</tt> and <tt>lightblue</tt>,
exactMatch() returns false and <a href="qregexp.html#matchedLength">matchedLength</a>() will return 4, 3
and 0 respectively.</p>
<p>Although const, this function sets <a href="qregexp.html#matchedLength">matchedLength</a>(), <a href="qregexp.html#capturedTexts">capturedTexts</a>(), and <a href="qregexp.html#pos">pos</a>().</p>
<p><b>See also</b> <a href="qregexp.html#indexIn">indexIn</a>() and
<a href="qregexp.html#lastIndexIn">lastIndexIn</a>().</p>


<h3 class="fn"><a name="indexIn" />int QRegExp.indexIn (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>offset</i>&#160;=&#160;0, <a href="qregexp.html#CaretMode-enum">CaretMode</a>&#160;<i>caretMode</i>&#160;=&#160;QRegExp.CaretAtZero)</h3><p>Attempts to find a match in <i>str</i> from position
<i>offset</i> (0 by default). If <i>offset</i> is -1, the search
starts at the last character; if -2, at the next to last character;
etc.</p>
<p>Returns the position of the first match, or -1 if there was no
match.</p>
<p>The <i>caretMode</i> parameter can be used to instruct whether
<b>^</b> should match at index 0 or at <i>offset</i>.</p>
<p>You might prefer to use <a href="qstring.html#indexOf">QString.indexOf</a>(), <a href="qstring.html#contains">QString.contains</a>(), or even <a href="qstringlist.html#filter">QStringList.filter</a>(). To replace
matches use <a href="qstring.html#replace">QString.replace</a>().</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> str <span class="operator">=</span> <span class="string">"offsets: 1.23 .50 71.00 6.00"</span>;
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rx(<span class="string">"\\d*\\.\\d+"</span>);    <span class="comment">// primitive floating point matching</span>
 <span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">while</span> ((pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     <span class="operator">+</span><span class="operator">+</span>count;
     pos <span class="operator">+</span><span class="operator">=</span> rx<span class="operator">.</span>matchedLength();
 }
 <span class="comment">// pos will be 9, 14, 18 and finally 24; count will end up as 4</span>
</pre>
<p>Although const, this function sets <a href="qregexp.html#matchedLength">matchedLength</a>(), <a href="qregexp.html#capturedTexts">capturedTexts</a>() and <a href="qregexp.html#pos">pos</a>().</p>
<p>If the <a href="qregexp.html">QRegExp</a> is a wildcard
expression (see <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>()) and want to
test a string against the whole wildcard expression, use <a href="qregexp.html#exactMatch">exactMatch</a>() instead of this
function.</p>
<p><b>See also</b> <a href="qregexp.html#lastIndexIn">lastIndexIn</a>() and <a href="qregexp.html#exactMatch">exactMatch</a>().</p>


<h3 class="fn"><a name="isEmpty" />bool QRegExp.isEmpty (<i>self</i>)</h3><p>Returns true if the pattern string is empty; otherwise returns
false.</p>
<p>If you call <a href="qregexp.html#exactMatch">exactMatch</a>()
with an empty pattern on an empty string it will return true;
otherwise it returns false since it operates over the whole string.
If you call <a href="qregexp.html#indexIn">indexIn</a>() with an
empty pattern on <i>any</i> string it will return the start offset
(0 by default) because the empty pattern matches the 'emptiness' at
the start of the string. In this case the length of the match
returned by <a href="qregexp.html#matchedLength">matchedLength</a>() will be 0.</p>
<p>See <a href="qstring.html#isEmpty">QString.isEmpty</a>().</p>


<h3 class="fn"><a name="isMinimal" />bool QRegExp.isMinimal (<i>self</i>)</h3><p>Returns true if minimal (non-greedy) matching is enabled;
otherwise returns false.</p>
<p><b>See also</b> <a href="qregexp.html#caseSensitivity">caseSensitivity</a>() and <a href="qregexp.html#setMinimal">setMinimal</a>().</p>


<h3 class="fn"><a name="isValid" />bool QRegExp.isValid (<i>self</i>)</h3><p>Returns true if the regular expression is valid; otherwise
returns false. An invalid regular expression never matches.</p>
<p>The pattern <b>[a-z</b> is an example of an invalid pattern,
since it lacks a closing square bracket.</p>
<p>Note that the validity of a regexp may also depend on the
setting of the wildcard flag, for example <b>*.html</b> is a valid
wildcard regexp but an invalid full regexp.</p>
<p><b>See also</b> <a href="qregexp.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="lastIndexIn" />int QRegExp.lastIndexIn (<i>self</i>, QString&#160;<i>str</i>, int&#160;<i>offset</i>&#160;=&#160;-1, <a href="qregexp.html#CaretMode-enum">CaretMode</a>&#160;<i>caretMode</i>&#160;=&#160;QRegExp.CaretAtZero)</h3><p>Attempts to find a match backwards in <i>str</i> from position
<i>offset</i>. If <i>offset</i> is -1 (the default), the search
starts at the last character; if -2, at the next to last character;
etc.</p>
<p>Returns the position of the first match, or -1 if there was no
match.</p>
<p>The <i>caretMode</i> parameter can be used to instruct whether
<b>^</b> should match at index 0 or at <i>offset</i>.</p>
<p>Although const, this function sets <a href="qregexp.html#matchedLength">matchedLength</a>(), <a href="qregexp.html#capturedTexts">capturedTexts</a>() and <a href="qregexp.html#pos">pos</a>().</p>
<p><b>Warning:</b> Searching backwards is much slower than
searching forwards.</p>
<p><b>See also</b> <a href="qregexp.html#indexIn">indexIn</a>() and
<a href="qregexp.html#exactMatch">exactMatch</a>().</p>


<h3 class="fn"><a name="matchedLength" />int QRegExp.matchedLength (<i>self</i>)</h3><p>Returns the length of the last matched string, or -1 if there
was no match.</p>
<p><b>See also</b> <a href="qregexp.html#exactMatch">exactMatch</a>(), <a href="qregexp.html#indexIn">indexIn</a>(), and <a href="qregexp.html#lastIndexIn">lastIndexIn</a>().</p>


<h3 class="fn"><a name="numCaptures" />int QRegExp.numCaptures (<i>self</i>)</h3><h3 class="fn"><a name="pattern" />QString QRegExp.pattern (<i>self</i>)</h3><p>Returns the pattern string of the regular expression. The
pattern has either regular expression syntax or wildcard syntax,
depending on <a href="qregexp.html#patternSyntax">patternSyntax</a>().</p>
<p><b>See also</b> <a href="qregexp.html#setPattern">setPattern</a>(), <a href="qregexp.html#patternSyntax">patternSyntax</a>(), and <a href="qregexp.html#caseSensitivity">caseSensitivity</a>().</p>


<h3 class="fn"><a name="patternSyntax" /><a href="qregexp.html#PatternSyntax-enum">PatternSyntax</a> QRegExp.patternSyntax (<i>self</i>)</h3><p>Returns the syntax used by the regular expression. The default
is <a href="qregexp.html#PatternSyntax-enum">QRegExp.RegExp</a>.</p>
<p><b>See also</b> <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(), <a href="qregexp.html#pattern">pattern</a>(), and <a href="qregexp.html#caseSensitivity">caseSensitivity</a>().</p>


<h3 class="fn"><a name="pos" />int QRegExp.pos (<i>self</i>, int&#160;<i>nth</i>&#160;=&#160;0)</h3><p>Returns the position of the <i>nth</i> captured text in the
searched string. If <i>nth</i> is 0 (the default), pos() returns
the position of the whole match.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qregexp.html">QRegExp</a></span> rx(<span class="string">"/([a-z]+)/([a-z]+)"</span>);
 rx<span class="operator">.</span><a href="qregexp.html#indexIn">indexIn</a>(<span class="string">"Output /dev/null"</span>);   <span class="comment">// returns 7 (position of /dev/null)</span>
 rx<span class="operator">.</span>pos(<span class="number">0</span>);                        <span class="comment">// returns 7 (position of /dev/null)</span>
 rx<span class="operator">.</span>pos(<span class="number">1</span>);                        <span class="comment">// returns 8 (position of dev)</span>
 rx<span class="operator">.</span>pos(<span class="number">2</span>);                        <span class="comment">// returns 12 (position of null)</span>
</pre>
<p>For zero-length matches, pos() always returns -1. (For example,
if cap(4) would return an empty string, pos(4) returns -1.) This is
a feature of the implementation.</p>
<p><b>See also</b> <a href="qregexp.html#cap">cap</a>() and
<a href="qregexp.html#capturedTexts">capturedTexts</a>().</p>


<h3 class="fn"><a name="setCaseSensitivity" />QRegExp.setCaseSensitivity (<i>self</i>, <a href="qt.html#CaseSensitivity-enum">Qt.CaseSensitivity</a>&#160;<i>cs</i>)</h3><p>Sets case sensitive matching to <i>cs</i>.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt.CaseSensitive</a>, <b>\.txt$</b>
matches <tt>readme.txt</tt> but not <tt>README.TXT</tt>.</p>
<p><b>See also</b> <a href="qregexp.html#caseSensitivity">caseSensitivity</a>(), <a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(), <a href="qregexp.html#setPattern">setPattern</a>(), and <a href="qregexp.html#setMinimal">setMinimal</a>().</p>


<h3 class="fn"><a name="setMinimal" />QRegExp.setMinimal (<i>self</i>, bool&#160;<i>minimal</i>)</h3><p>Enables or disables minimal matching. If <i>minimal</i> is
false, matching is greedy (maximal) which is the default.</p>
<p>For example, suppose we have the input string "We must be
&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;!" and the
pattern <b>&lt;b&gt;.*&lt;/b&gt;</b>. With the default greedy
(maximal) matching, the match is "We must be
<u>&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;</u>!". But
with minimal (non-greedy) matching, the first match is: "We must be
<u>&lt;b&gt;bold&lt;/b&gt;</u>, very &lt;b&gt;bold&lt;/b&gt;!" and
the second match is "We must be &lt;b&gt;bold&lt;/b&gt;, very
<u>&lt;b&gt;bold&lt;/b&gt;</u>!". In practice we might use the
pattern <b>&lt;b&gt;[^&lt;]*&lt;/b&gt;</b> instead, although this
will still fail for nested tags.</p>
<p><b>See also</b> <a class="compat" href="qregexp-qt3.html#minimal">minimal</a>() and <a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>().</p>


<h3 class="fn"><a name="setPattern" />QRegExp.setPattern (<i>self</i>, QString&#160;<i>pattern</i>)</h3><p>Sets the pattern string to <i>pattern</i>. The case sensitivity,
wildcard, and minimal matching options are not changed.</p>
<p><b>See also</b> <a href="qregexp.html#pattern">pattern</a>(),
<a href="qregexp.html#setPatternSyntax">setPatternSyntax</a>(), and
<a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>().</p>


<h3 class="fn"><a name="setPatternSyntax" />QRegExp.setPatternSyntax (<i>self</i>, <a href="qregexp.html#PatternSyntax-enum">PatternSyntax</a>&#160;<i>syntax</i>)</h3><p>Sets the syntax mode for the regular expression. The default is
<a href="qregexp.html#PatternSyntax-enum">QRegExp.RegExp</a>.</p>
<p>Setting <i>syntax</i> to <a href="qregexp.html#PatternSyntax-enum">QRegExp.Wildcard</a> enables
simple shell-like <a href="qregexp.html#wildcard-matching">wildcard
matching</a>. For example, <b>r*.txt</b> matches the string
<tt>readme.txt</tt> in wildcard mode, but does not match
<tt>readme</tt>.</p>
<p>Setting <i>syntax</i> to <a href="qregexp.html#PatternSyntax-enum">QRegExp.FixedString</a> means
that the pattern is interpreted as a plain string. Special
characters (e.g., backslash) don't need to be escaped then.</p>
<p><b>See also</b> <a href="qregexp.html#patternSyntax">patternSyntax</a>(), <a href="qregexp.html#setPattern">setPattern</a>(), <a href="qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(), and
<a href="qregexp.html#escape">escape</a>().</p>


<h3 class="fn"><a name="swap" />QRegExp.swap (<i>self</i>, <a href="qregexp.html">QRegExp</a>&#160;<i>other</i>)</h3><p>Swaps regular expression <i>other</i> with this regular
expression. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>


<h3 class="fn"><a name="__eq__" />bool QRegExp.__eq__ (<i>self</i>, <a href="qregexp.html">QRegExp</a>&#160;<i>rx</i>)</h3><h3 class="fn"><a name="__ne__" />bool QRegExp.__ne__ (<i>self</i>, <a href="qregexp.html">QRegExp</a>&#160;<i>rx</i>)</h3><h3 class="fn"><a name="__repr__" />str QRegExp.__repr__ (<i>self</i>)</h3><address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>