<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QUdpSocket Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QUdpSocket Class Reference<br /><sup><sup>[<a href="qtnetwork.html">QtNetwork</a> module]</sup></sup></h1><p>The QUdpSocket class provides a UDP socket. <a href="#details">More...</a></p>

<p>Inherits <a href="qabstractsocket.html">QAbstractSocket</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qudpsocket.html#BindFlag-enum">BindFlag</a></b> { DefaultForPlatform, ShareAddress, DontShareAddress, ReuseAddressHint }</li><li><div class="fn" />class <b><a href="qudpsocket-bindmode.html">BindMode</a></b></li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qudpsocket.html#QUdpSocket">__init__</a></b> (<i>self</i>, QObject&#160;<i>parent</i>&#160;=&#160;None)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#bind">bind</a></b> (<i>self</i>, QHostAddress&#160;<i>address</i>, int&#160;<i>port</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#bind-2">bind</a></b> (<i>self</i>, int&#160;<i>port</i>&#160;=&#160;0)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#bind-3">bind</a></b> (<i>self</i>, QHostAddress&#160;<i>address</i>, int&#160;<i>port</i>, BindMode&#160;<i>mode</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#bind-4">bind</a></b> (<i>self</i>, int&#160;<i>port</i>, BindMode&#160;<i>mode</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#hasPendingDatagrams">hasPendingDatagrams</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#joinMulticastGroup">joinMulticastGroup</a></b> (<i>self</i>, QHostAddress&#160;<i>groupAddress</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#joinMulticastGroup-2">joinMulticastGroup</a></b> (<i>self</i>, QHostAddress&#160;<i>groupAddress</i>, QNetworkInterface&#160;<i>iface</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#leaveMulticastGroup">leaveMulticastGroup</a></b> (<i>self</i>, QHostAddress&#160;<i>groupAddress</i>)</li><li><div class="fn" />bool <b><a href="qudpsocket.html#leaveMulticastGroup-2">leaveMulticastGroup</a></b> (<i>self</i>, QHostAddress&#160;<i>groupAddress</i>, QNetworkInterface&#160;<i>iface</i>)</li><li><div class="fn" />QNetworkInterface <b><a href="qudpsocket.html#multicastInterface">multicastInterface</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qudpsocket.html#pendingDatagramSize">pendingDatagramSize</a></b> (<i>self</i>)</li><li><div class="fn" />(str, QHostAddress&#160;<i>host</i>, int&#160;<i>port</i>) <b><a href="qudpsocket.html#readDatagram">readDatagram</a></b> (<i>self</i>, int&#160;<i>maxlen</i>)</li><li><div class="fn" /><b><a href="qudpsocket.html#setMulticastInterface">setMulticastInterface</a></b> (<i>self</i>, QNetworkInterface&#160;<i>iface</i>)</li><li><div class="fn" />int <b><a href="qudpsocket.html#writeDatagram">writeDatagram</a></b> (<i>self</i>, str&#160;<i>data</i>, QHostAddress&#160;<i>host</i>, int&#160;<i>port</i>)</li><li><div class="fn" />int <b><a href="qudpsocket.html#writeDatagram-2">writeDatagram</a></b> (<i>self</i>, QByteArray&#160;<i>datagram</i>, QHostAddress&#160;<i>host</i>, int&#160;<i>port</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QUdpSocket class provides a UDP socket.</p>
<p>UDP (User Datagram Protocol) is a lightweight, unreliable,
datagram-oriented, connectionless protocol. It can be used when
reliability isn't important. QUdpSocket is a subclass of <a href="qabstractsocket.html">QAbstractSocket</a> that allows you to send
and receive UDP datagrams.</p>
<p>The most common way to use this class is to bind to an address
and port using <a href="qudpsocket.html#bind">bind</a>(), then call
<a href="qudpsocket.html#writeDatagram">writeDatagram</a>() and
<a href="qudpsocket.html#readDatagram">readDatagram</a>() to
transfer data. If you want to use the standard <a href="qiodevice.html">QIODevice</a> functions <a href="qiodevice.html#read">read</a>(), <a href="qiodevice.html#readLine">readLine</a>(), <a href="qiodevice.html#write">write</a>(), etc., you must first connect
the socket directly to a peer by calling <a href="qabstractsocket.html#connectToHost">connectToHost</a>().</p>
<p>The socket emits the <a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal every time
a datagram is written to the network. If you just want to send
datagrams, you don't need to call <a href="qudpsocket.html#bind">bind</a>().</p>
<p>The <a href="qiodevice.html#readyRead">readyRead</a>() signal is
emitted whenever datagrams arrive. In that case, <a href="qudpsocket.html#hasPendingDatagrams">hasPendingDatagrams</a>()
returns true. Call <a href="qudpsocket.html#pendingDatagramSize">pendingDatagramSize</a>() to
obtain the size of the first pending datagram, and <a href="qudpsocket.html#readDatagram">readDatagram</a>() to read it.</p>
<p><b>Note:</b> An incoming datagram should be read when you
receive the <a href="qiodevice.html#readyRead">readyRead</a>()
signal, otherwise this signal will not be emitted for the next
datagram.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type">void</span> Server<span class="operator">.</span>initSocket()
 {
     udpSocket <span class="operator">=</span> <span class="keyword">new</span> <span class="type">QUdpSocket</span>(<span class="keyword">this</span>);
     udpSocket<span class="operator">-</span><span class="operator">&gt;</span>bind(<span class="type"><a href="qhostaddress.html">QHostAddress</a></span><span class="operator">.</span>LocalHost<span class="operator">,</span> <span class="number">7755</span>);

     connect(udpSocket<span class="operator">,</span> SIGNAL(readyRead())<span class="operator">,</span>
             <span class="keyword">this</span><span class="operator">,</span> SLOT(readPendingDatagrams()));
 }

 <span class="type">void</span> Server<span class="operator">.</span>readPendingDatagrams()
 {
     <span class="keyword">while</span> (udpSocket<span class="operator">-</span><span class="operator">&gt;</span>hasPendingDatagrams()) {
         <span class="type"><a href="qbytearray.html">QByteArray</a></span> datagram;
         datagram<span class="operator">.</span>resize(udpSocket<span class="operator">-</span><span class="operator">&gt;</span>pendingDatagramSize());
         <span class="type"><a href="qhostaddress.html">QHostAddress</a></span> sender;
         <span class="type"><a href="qtcore.html#quint16-typedef">quint16</a></span> senderPort;

         udpSocket<span class="operator">-</span><span class="operator">&gt;</span>readDatagram(datagram<span class="operator">.</span>data()<span class="operator">,</span> datagram<span class="operator">.</span>size()<span class="operator">,</span>
                                 <span class="operator">&amp;</span>sender<span class="operator">,</span> <span class="operator">&amp;</span>senderPort);

         processTheDatagram(datagram);
     }
 }
</pre>
<p>QUdpSocket also supports UDP multicast. Use <a href="qudpsocket.html#joinMulticastGroup">joinMulticastGroup</a>() and
<a href="qudpsocket.html#leaveMulticastGroup">leaveMulticastGroup</a>() to
control group membership, and <a href="qabstractsocket.html#SocketOption-enum">QAbstractSocket.MulticastTtlOption</a>
and <a href="qabstractsocket.html#SocketOption-enum">QAbstractSocket.MulticastLoopbackOption</a>
to set the TTL and loopback socket options. Use <a href="qudpsocket.html#setMulticastInterface">setMulticastInterface</a>()
to control the outgoing interface for multicast datagrams, and
<a href="qudpsocket.html#multicastInterface">multicastInterface</a>() to
query it.</p>
<p>With QUdpSocket, you can also establish a virtual connection to
a UDP server using <a href="qabstractsocket.html#connectToHost">connectToHost</a>() and then
use <a href="qiodevice.html#read">read</a>() and <a href="qiodevice.html#write">write</a>() to exchange datagrams without
specifying the receiver for each datagram.</p>
<p>The <a href="network-broadcastsender.html">Broadcast Sender</a>,
<a href="network-broadcastreceiver.html">Broadcast Receiver</a>,
<a href="network-multicastsender.html">Multicast Sender</a>, and
<a href="network-multicastreceiver.html">Multicast Receiver</a>
examples illustrate how to use QUdpSocket in applications.</p>
<a id="symbian-platform-security-requirements" name="symbian-platform-security-requirements" />
<h3>Symbian Platform Security Requirements</h3>
<p>On Symbian, processes which use this class must have the
<tt>NetworkServices</tt> platform security capability. If the
client process lacks this capability, operations will result in a
panic.</p>
<p>Platform security capabilities are added via the <a href="qmake-variable-reference.html#target-capability">TARGET.CAPABILITY</a>
qmake variable.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="BindFlag-enum" />QUdpSocket.BindFlag</h3><p>This enum describes the different flags you can pass to modify
the behavior of <a href="qudpsocket.html#bind">QUdpSocket.bind</a>().</p>
<p><b>Note:</b> On Symbian OS bind flags behaviour depends on
process capabilties. If process has NetworkControl capability, the
bind attempt with ReuseAddressHint will always succeed even if the
address and port is already bound by another socket with any flags.
If process does not have NetworkControl capability, the bind
attempt to address and port already bound by another socket will
always fail.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QUdpSocket.ShareAddress</tt></td>
<td class="topAlign"><tt>0x1</tt></td>
<td class="topAlign">Allow other services to bind to the same
address and port. This is useful when multiple processes share the
load of a single service by listening to the same address and port
(e.g., a web server with several pre-forked listeners can greatly
improve response time). However, because any service is allowed to
rebind, this option is subject to certain security considerations.
Note that by combining this option with ReuseAddressHint, you will
also allow your service to rebind an existing shared address. On
Unix, this is equivalent to the SO_REUSEADDR socket option. On
Windows, this option is ignored.</td>
</tr>
<tr>
<td class="topAlign"><tt>QUdpSocket.DontShareAddress</tt></td>
<td class="topAlign"><tt>0x2</tt></td>
<td class="topAlign">Bind the address and port exclusively, so that
no other services are allowed to rebind. By passing this option to
<a href="qudpsocket.html#bind">QUdpSocket.bind</a>(), you are
guaranteed that on successs, your service is the only one that
listens to the address and port. No services are allowed to rebind,
even if they pass ReuseAddressHint. This option provides more
security than ShareAddress, but on certain operating systems, it
requires you to run the server with administrator privileges. On
Unix and Mac OS X, not sharing is the default behavior for binding
an address and port, so this option is ignored. On Windows, this
option uses the SO_EXCLUSIVEADDRUSE socket option.</td>
</tr>
<tr>
<td class="topAlign"><tt>QUdpSocket.ReuseAddressHint</tt></td>
<td class="topAlign"><tt>0x4</tt></td>
<td class="topAlign">Provides a hint to <a href="qudpsocket.html">QUdpSocket</a> that it should try to rebind the
service even if the address and port are already bound by another
socket. On Windows, this is equivalent to the SO_REUSEADDR socket
option. On Unix, this option is ignored.</td>
</tr>
<tr>
<td class="topAlign"><tt>QUdpSocket.DefaultForPlatform</tt></td>
<td class="topAlign"><tt>0x0</tt></td>
<td class="topAlign">The default option for the current platform.
On Unix and Mac OS X, this is equivalent to (DontShareAddress +
ReuseAddressHint), and on Windows, its equivalent to
ShareAddress.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.1.</p>
<p>The BindMode type is a typedef for <a href="qflags.html">QFlags</a>&lt;BindFlag&gt;. It stores an OR
combination of BindFlag values.</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QUdpSocket" />QUdpSocket.__init__ (<i>self</i>, <a href="qobject.html">QObject</a>&#160;<i>parent</i>&#160;=&#160;None)</h3><p>The <i>parent</i> argument, if not None, causes <i>self</i> to be owned by Qt instead of PyQt.</p><p>Creates a <a href="qudpsocket.html">QUdpSocket</a> object.</p>
<p><i>parent</i> is passed to the <a href="qobject.html">QObject</a> constructor.</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketType">socketType</a>().</p>


<h3 class="fn"><a name="bind" />bool QUdpSocket.bind (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>address</i>, int&#160;<i>port</i>)</h3><p>Binds this socket to the address <i>address</i> and the port
<i>port</i>. When bound, the signal <a href="qiodevice.html#readyRead">readyRead</a>() is emitted whenever a
UDP datagram arrives on the specified address and port. This
function is useful to write UDP servers.</p>
<p>On success, the functions returns true and the socket enters
<a href="qabstractsocket.html#SocketState-enum">BoundState</a>;
otherwise it returns false.</p>
<p>The socket is bound using the <a href="qudpsocket.html#BindFlag-enum">DefaultForPlatform</a> <a href="qudpsocket.html#BindFlag-enum">BindMode</a>.</p>
<p><b>See also</b> <a href="qudpsocket.html#readDatagram">readDatagram</a>().</p>


<h3 class="fn"><a name="bind-2" />bool QUdpSocket.bind (<i>self</i>, int&#160;<i>port</i>&#160;=&#160;0)</h3><p>This is an overloaded function.</p>
<p>Binds to <i>address</i> on port <i>port</i>, using the <a href="qudpsocket.html#BindFlag-enum">BindMode</a> <i>mode</i>.</p>
<p>This function was introduced in Qt 4.1.</p>


<h3 class="fn"><a name="bind-3" />bool QUdpSocket.bind (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>address</i>, int&#160;<i>port</i>, <a href="qudpsocket-bindmode.html">BindMode</a>&#160;<i>mode</i>)</h3><p>This is an overloaded function.</p>
<p>Binds to <a href="qhostaddress.html">QHostAddress</a>:Any on
port <i>port</i>.</p>


<h3 class="fn"><a name="bind-4" />bool QUdpSocket.bind (<i>self</i>, int&#160;<i>port</i>, <a href="qudpsocket-bindmode.html">BindMode</a>&#160;<i>mode</i>)</h3><p>This is an overloaded function.</p>
<p>Binds to <a href="qhostaddress.html">QHostAddress</a>:Any on
port <i>port</i>, using the <a href="qudpsocket.html#BindFlag-enum">BindMode</a> <i>mode</i>.</p>
<p>This function was introduced in Qt 4.1.</p>


<h3 class="fn"><a name="hasPendingDatagrams" />bool QUdpSocket.hasPendingDatagrams (<i>self</i>)</h3><p>Returns true if at least one datagram is waiting to be read;
otherwise returns false.</p>
<p><b>See also</b> <a href="qudpsocket.html#pendingDatagramSize">pendingDatagramSize</a>() and
<a href="qudpsocket.html#readDatagram">readDatagram</a>().</p>


<h3 class="fn"><a name="joinMulticastGroup" />bool QUdpSocket.joinMulticastGroup (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>groupAddress</i>)</h3><p>Joins the the multicast group specified by <i>groupAddress</i>
on the default interface chosen by the operating system. The socket
must be in <a href="qabstractsocket.html#SocketState-enum">BoundState</a>, otherwise
an error occurs.</p>
<p>This function returns true if successful; otherwise it returns
false and sets the socket error accordingly.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#leaveMulticastGroup">leaveMulticastGroup</a>().</p>


<h3 class="fn"><a name="joinMulticastGroup-2" />bool QUdpSocket.joinMulticastGroup (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>groupAddress</i>, <a href="qnetworkinterface.html">QNetworkInterface</a>&#160;<i>iface</i>)</h3><p>This is an overloaded function.</p>
<p>Joins the multicast group address <i>groupAddress</i> on the
interface <i>iface</i>.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#leaveMulticastGroup">leaveMulticastGroup</a>().</p>


<h3 class="fn"><a name="leaveMulticastGroup" />bool QUdpSocket.leaveMulticastGroup (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>groupAddress</i>)</h3><p>Leaves the multicast group specified by <i>groupAddress</i> on
the default interface chosen by the operating system. The socket
must be in <a href="qabstractsocket.html#SocketState-enum">BoundState</a>, otherwise
an error occurs.</p>
<p>This function returns true if successful; otherwise it returns
false and sets the socket error accordingly.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#joinMulticastGroup">joinMulticastGroup</a>().</p>


<h3 class="fn"><a name="leaveMulticastGroup-2" />bool QUdpSocket.leaveMulticastGroup (<i>self</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>groupAddress</i>, <a href="qnetworkinterface.html">QNetworkInterface</a>&#160;<i>iface</i>)</h3><p>This is an overloaded function.</p>
<p>Leaves the multicast group specified by <i>groupAddress</i> on
the interface <i>iface</i>.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#joinMulticastGroup">joinMulticastGroup</a>().</p>


<h3 class="fn"><a name="multicastInterface" /><a href="qnetworkinterface.html">QNetworkInterface</a> QUdpSocket.multicastInterface (<i>self</i>)</h3><p>Returns the interface for the outgoing interface for multicast
datagrams. This corresponds to the IP_MULTICAST_IF socket option
for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6
sockets. If no interface has been previously set, this function
returns an invalid <a href="qnetworkinterface.html">QNetworkInterface</a>. The socket must be
in <a href="qabstractsocket.html#SocketState-enum">BoundState</a>,
otherwise an invalid <a href="qnetworkinterface.html">QNetworkInterface</a> is returned.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#setMulticastInterface">setMulticastInterface</a>().</p>


<h3 class="fn"><a name="pendingDatagramSize" />int QUdpSocket.pendingDatagramSize (<i>self</i>)</h3><p>Returns the size of the first pending UDP datagram. If there is
no datagram available, this function returns -1.</p>
<p><b>See also</b> <a href="qudpsocket.html#hasPendingDatagrams">hasPendingDatagrams</a>() and
<a href="qudpsocket.html#readDatagram">readDatagram</a>().</p>


<h3 class="fn"><a name="readDatagram" />(str, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>host</i>, int&#160;<i>port</i>) QUdpSocket.readDatagram (<i>self</i>, int&#160;<i>maxlen</i>)</h3><p>Receives a datagram no larger than <i>maxSize</i> bytes and
stores it in <i>data</i>. The sender's host address and port is
stored in *<i>address</i> and *<i>port</i> (unless the pointers are
0).</p>
<p>Returns the size of the datagram on success; otherwise returns
-1.</p>
<p>If <i>maxSize</i> is too small, the rest of the datagram will be
lost. To avoid loss of data, call <a href="qudpsocket.html#pendingDatagramSize">pendingDatagramSize</a>() to
determine the size of the pending datagram before attempting to
read it. If <i>maxSize</i> is 0, the datagram will be
discarded.</p>
<p><b>See also</b> <a href="qudpsocket.html#writeDatagram">writeDatagram</a>(), <a href="qudpsocket.html#hasPendingDatagrams">hasPendingDatagrams</a>(),
and <a href="qudpsocket.html#pendingDatagramSize">pendingDatagramSize</a>().</p>


<h3 class="fn"><a name="setMulticastInterface" />QUdpSocket.setMulticastInterface (<i>self</i>, <a href="qnetworkinterface.html">QNetworkInterface</a>&#160;<i>iface</i>)</h3><p>Sets the outgoing interface for multicast datagrams to the
interface <i>iface</i>. This corresponds to the IP_MULTICAST_IF
socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket
option for IPv6 sockets. The socket must be in <a href="qabstractsocket.html#SocketState-enum">BoundState</a>, otherwise
this function does nothing.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also</b> <a href="qudpsocket.html#multicastInterface">multicastInterface</a>(),
<a href="qudpsocket.html#joinMulticastGroup">joinMulticastGroup</a>(), and
<a href="qudpsocket.html#leaveMulticastGroup">leaveMulticastGroup</a>().</p>


<h3 class="fn"><a name="writeDatagram" />int QUdpSocket.writeDatagram (<i>self</i>, str&#160;<i>data</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>host</i>, int&#160;<i>port</i>)</h3><p>Sends the datagram at <i>data</i> of size <i>size</i> to the
host address <i>address</i> at port <i>port</i>. Returns the number
of bytes sent on success; otherwise returns -1.</p>
<p>Datagrams are always written as one block. The maximum size of a
datagram is highly platform-dependent, but can be as low as 8192
bytes. If the datagram is too large, this function will return -1
and <a href="qabstractsocket.html#error">error</a>() will return
<a href="qabstractsocket.html#SocketError-enum">DatagramTooLargeError</a>.</p>
<p>Sending datagrams larger than 512 bytes is in general
disadvised, as even if they are sent successfully, they are likely
to be fragmented by the IP layer before arriving at their final
destination.</p>
<p><b>Warning:</b> In S60 5.0 and earlier versions, the
writeDatagram return value is not reliable for large datagrams.</p>
<p><b>Warning:</b> Calling this function on a connected UDP socket
may result in an error and no packet being sent. If you are using a
connected socket, use <a href="qiodevice.html#write">write</a>() to
send datagrams.</p>
<p><b>See also</b> <a href="qudpsocket.html#readDatagram">readDatagram</a>() and <a href="qiodevice.html#write">write</a>().</p>


<h3 class="fn"><a name="writeDatagram-2" />int QUdpSocket.writeDatagram (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>datagram</i>, <a href="qhostaddress.html">QHostAddress</a>&#160;<i>host</i>, int&#160;<i>port</i>)</h3><p>This is an overloaded function.</p>
<p>Sends the datagram <i>datagram</i> to the host address
<i>host</i> and at port <i>port</i>.</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>