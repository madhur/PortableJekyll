<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QXmlStreamReader Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QXmlStreamReader Class Reference<br /><sup><sup>[<a href="qtcore.html">QtCore</a> module]</sup></sup></h1><p>The QXmlStreamReader class provides a fast parser for reading
well-formed XML via a simple streaming API. <a href="#details">More...</a></p>

<h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qxmlstreamreader.html#Error-enum">Error</a></b> { NoError, UnexpectedElementError, CustomError, NotWellFormedError, PrematureEndOfDocumentError }</li><li><div class="fn" />enum <b><a href="qxmlstreamreader.html#ReadElementTextBehaviour-enum">ReadElementTextBehaviour</a></b> { ErrorOnUnexpectedElement, IncludeChildElements, SkipChildElements }</li><li><div class="fn" />enum <b><a href="qxmlstreamreader.html#TokenType-enum">TokenType</a></b> { NoToken, Invalid, StartDocument, EndDocument, ..., ProcessingInstruction }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qxmlstreamreader.html#QXmlStreamReader">__init__</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#QXmlStreamReader-2">__init__</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#QXmlStreamReader-3">__init__</a></b> (<i>self</i>, QByteArray&#160;<i>data</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#QXmlStreamReader-4">__init__</a></b> (<i>self</i>, QString&#160;<i>data</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#addData">addData</a></b> (<i>self</i>, QByteArray&#160;<i>data</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#addData-2">addData</a></b> (<i>self</i>, QString&#160;<i>data</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#addExtraNamespaceDeclaration">addExtraNamespaceDeclaration</a></b> (<i>self</i>, QXmlStreamNamespaceDeclaration&#160;<i>extraNamespaceDeclaraction</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#addExtraNamespaceDeclarations">addExtraNamespaceDeclarations</a></b> (<i>self</i>, list-of-QXmlStreamNamespaceDeclaration&#160;<i>extraNamespaceDeclaractions</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#atEnd">atEnd</a></b> (<i>self</i>)</li><li><div class="fn" />QXmlStreamAttributes <b><a href="qxmlstreamreader.html#attributes">attributes</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qxmlstreamreader.html#characterOffset">characterOffset</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#clear">clear</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qxmlstreamreader.html#columnNumber">columnNumber</a></b> (<i>self</i>)</li><li><div class="fn" />QIODevice <b><a href="qxmlstreamreader.html#device">device</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#documentEncoding">documentEncoding</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#documentVersion">documentVersion</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#dtdName">dtdName</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#dtdPublicId">dtdPublicId</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#dtdSystemId">dtdSystemId</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-QXmlStreamEntityDeclaration <b><a href="qxmlstreamreader.html#entityDeclarations">entityDeclarations</a></b> (<i>self</i>)</li><li><div class="fn" />QXmlStreamEntityResolver <b><a href="qxmlstreamreader.html#entityResolver">entityResolver</a></b> (<i>self</i>)</li><li><div class="fn" />Error <b><a href="qxmlstreamreader.html#error">error</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qxmlstreamreader.html#errorString">errorString</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#hasError">hasError</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isCDATA">isCDATA</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isCharacters">isCharacters</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isComment">isComment</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isDTD">isDTD</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isEndDocument">isEndDocument</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isEndElement">isEndElement</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isEntityReference">isEntityReference</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isProcessingInstruction">isProcessingInstruction</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isStandaloneDocument">isStandaloneDocument</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isStartDocument">isStartDocument</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isStartElement">isStartElement</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#isWhitespace">isWhitespace</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qxmlstreamreader.html#lineNumber">lineNumber</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#name">name</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-QXmlStreamNamespaceDeclaration <b><a href="qxmlstreamreader.html#namespaceDeclarations">namespaceDeclarations</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#namespaceProcessing">namespaceProcessing</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a></b> (<i>self</i>)</li><li><div class="fn" />list-of-QXmlStreamNotationDeclaration <b><a href="qxmlstreamreader.html#notationDeclarations">notationDeclarations</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#prefix">prefix</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#processingInstructionData">processingInstructionData</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#processingInstructionTarget">processingInstructionTarget</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#raiseError">raiseError</a></b> (<i>self</i>, QString&#160;<i>message</i>&#160;=&#160;QString())</li><li><div class="fn" />QString <b><a href="qxmlstreamreader.html#readElementText">readElementText</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qxmlstreamreader.html#readElementText-2">readElementText</a></b> (<i>self</i>, ReadElementTextBehaviour&#160;<i>behaviour</i>)</li><li><div class="fn" />TokenType <b><a href="qxmlstreamreader.html#readNext">readNext</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qxmlstreamreader.html#readNextStartElement">readNextStartElement</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#setDevice">setDevice</a></b> (<i>self</i>, QIODevice&#160;<i>device</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#setEntityResolver">setEntityResolver</a></b> (<i>self</i>, QXmlStreamEntityResolver&#160;<i>resolver</i>)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#setNamespaceProcessing">setNamespaceProcessing</a></b> (<i>self</i>, bool)</li><li><div class="fn" /><b><a href="qxmlstreamreader.html#skipCurrentElement">skipCurrentElement</a></b> (<i>self</i>)</li><li><div class="fn" />QStringRef <b><a href="qxmlstreamreader.html#text">text</a></b> (<i>self</i>)</li><li><div class="fn" />QString <b><a href="qxmlstreamreader.html#tokenString">tokenString</a></b> (<i>self</i>)</li><li><div class="fn" />TokenType <b><a href="qxmlstreamreader.html#tokenType">tokenType</a></b> (<i>self</i>)</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QXmlStreamReader class provides a fast parser for reading
well-formed XML via a simple streaming API.</p>
<p>QXmlStreamReader is a faster and more convenient replacement for
Qt's own SAX parser (see <a href="qxmlsimplereader.html">QXmlSimpleReader</a>). In some cases it
might also be a faster and more convenient alternative for use in
applications that would otherwise use a DOM tree (see <a href="qdomdocument.html">QDomDocument</a>). QXmlStreamReader reads data
either from a <a href="qiodevice.html">QIODevice</a> (see <a href="qxmlstreamreader.html#setDevice">setDevice</a>()), or from a raw
<a href="qbytearray.html">QByteArray</a> (see <a href="qxmlstreamreader.html#addData">addData</a>()).</p>
<p>Qt provides <a href="qxmlstreamwriter.html">QXmlStreamWriter</a>
for writing XML.</p>
<p>The basic concept of a stream reader is to report an XML
document as a stream of tokens, similar to SAX. The main difference
between QXmlStreamReader and SAX is <i>how</i> these XML tokens are
reported. With SAX, the application must provide handlers (callback
functions) that receive so-called XML <i>events</i> from the parser
at the parser's convenience. With QXmlStreamReader, the application
code itself drives the loop and pulls <i>tokens</i> from the
reader, one after another, as it needs them. This is done by
calling <a href="qxmlstreamreader.html#readNext">readNext</a>(),
where the reader reads from the input stream until it completes the
next token, at which point it returns the <a href="qxmlstreamreader.html#tokenType">tokenType</a>(). A set of
convenient functions including <a href="qxmlstreamreader.html#isStartElement">isStartElement</a>() and
<a href="qxmlstreamreader.html#text">text</a>() can then be used to
examine the token to obtain information about what has been read.
The big advantage of this <i>pulling</i> approach is the
possibility to build recursive descent parsers with it, meaning you
can split your XML parsing code easily into different methods or
classes. This makes it easy to keep track of the application's own
state when parsing XML.</p>
<p>A typical loop with QXmlStreamReader looks like this:</p>
<pre class="cpp">
   <span class="type">QXmlStreamReader</span> xml;
   <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
   <span class="keyword">while</span> (<span class="operator">!</span>xml<span class="operator">.</span>atEnd()) {
         xml<span class="operator">.</span>readNext();
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> <span class="comment">// do processing</span>
   }
   <span class="keyword">if</span> (xml<span class="operator">.</span>hasError()) {
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> <span class="comment">// do error handling</span>
   }
</pre>
<p>QXmlStreamReader is a well-formed XML 1.0 parser that does
<i>not</i> include external parsed entities. As long as no error
occurs, the application code can thus be assured that the data
provided by the stream reader satisfies the W3C's criteria for
well-formed XML. For example, you can be certain that all tags are
indeed nested and closed properly, that references to internal
entities have been replaced with the correct replacement text, and
that attributes have been normalized or added according to the
internal subset of the DTD.</p>
<p>If an error occurs while parsing, <a href="qxmlstreamreader.html#atEnd">atEnd</a>() and <a href="qxmlstreamreader.html#hasError">hasError</a>() return true, and
<a href="qxmlstreamreader.html#error">error</a>() returns the error
that occurred. The functions <a href="qxmlstreamreader.html#errorString">errorString</a>(), <a href="qxmlstreamreader.html#lineNumber">lineNumber</a>(), <a href="qxmlstreamreader.html#columnNumber">columnNumber</a>(), and
<a href="qxmlstreamreader.html#characterOffset">characterOffset</a>() are
for constructing an appropriate error or warning message. To
simplify application code, QXmlStreamReader contains a <a href="qxmlstreamreader.html#raiseError">raiseError</a>() mechanism that
lets you raise custom errors that trigger the same error handling
described.</p>
<p>The <a href="xml-streambookmarks.html">QXmlStream Bookmarks
Example</a> illustrates how to use the recursive descent technique
to read an XML bookmark file (XBEL) with a stream reader.</p>
<a id="namespaces" name="namespaces" />
<h3>Namespaces</h3>
<p>QXmlStream understands and resolves XML namespaces. E.g. in case
of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>, <a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>() returns the
namespace the element is in, and <a href="qxmlstreamreader.html#name">name</a>() returns the element's
<i>local</i> name. The combination of namespaceUri and name
uniquely identifies an element. If a namespace prefix was not
declared in the XML entities parsed by the reader, the namespaceUri
is empty.</p>
<p>If you parse XML data that does not utilize namespaces according
to the XML specification or doesn't use namespaces at all, you can
use the element's <a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a>() instead.
A qualified name is the element's <a href="qxmlstreamreader.html#prefix">prefix</a>() followed by colon
followed by the element's local <a href="qxmlstreamreader.html#name">name</a>() - exactly like the element
appears in the raw XML data. Since the mapping namespaceUri to
prefix is neither unique nor universal, <a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a>() should be
avoided for namespace-compliant XML data.</p>
<p>In order to parse standalone documents that do use undeclared
namespace prefixes, you can turn off namespace processing
completely with the <a href="qxmlstreamreader.html#namespaceProcessing-prop">namespaceProcessing</a>
property.</p>
<a id="incremental-parsing" name="incremental-parsing" />
<h3>Incremental parsing</h3>
<p>QXmlStreamReader is an incremental parser. It can handle the
case where the document can't be parsed all at once because it
arrives in chunks (e.g. from multiple files, or over a network
connection). When the reader runs out of data before the complete
document has been parsed, it reports a <a href="qxmlstreamreader.html#Error-enum">PrematureEndOfDocumentError</a>.
When more data arrives, either because of a call to <a href="qxmlstreamreader.html#addData">addData</a>() or because more data
is available through the network <a href="qxmlstreamreader.html#device">device</a>(), the reader recovers
from the <a href="qxmlstreamreader.html#Error-enum">PrematureEndOfDocumentError</a>
error and continues parsing the new data with the next call to
<a href="qxmlstreamreader.html#readNext">readNext</a>().</p>
<p>For example, if your application reads data from the network
using a <a href="qnetworkaccessmanager.html">network access
manager</a>, you would issue a <a href="qnetworkrequest.html">network request</a> to the manager and
receive a <a href="qnetworkreply.html">network reply</a> in return.
Since a <a href="qnetworkreply.html">QNetworkReply</a> is a
<a href="qiodevice.html">QIODevice</a>, you connect its <a href="qiodevice.html#readyRead">readyRead()</a> signal to a custom slot,
e.g. <tt>slotReadyRead()</tt> in the code snippet shown in the
discussion for <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. In this
slot, you read all available data with <a href="qiodevice.html#readAll">readAll()</a> and pass it to the XML
stream reader using <a href="qxmlstreamreader.html#addData">addData</a>(). Then you call your
custom parsing function that reads the XML events from the
reader.</p>
<a id="performance-and-memory-consumption" name="performance-and-memory-consumption" />
<h3>Performance and memory consumption</h3>
<p>QXmlStreamReader is memory-conservative by design, since it
doesn't store the entire XML document tree in memory, but only the
current token at the time it is reported. In addition,
QXmlStreamReader avoids the many small string allocations that it
normally takes to map an XML document to a convenient and Qt-ish
API. It does this by reporting all string data as <a href="qstringref.html">QStringRef</a> rather than real <a href="qstring.html">QString</a> objects. <a href="qstringref.html">QStringRef</a> is a thin wrapper around <a href="qstring.html">QString</a> substrings that provides a subset of the
<a href="qstring.html">QString</a> API without the memory
allocation and reference-counting overhead. Calling <a href="qstringref.html#toString">toString()</a> on any of those objects
returns an equivalent real <a href="qstring.html">QString</a>
object.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="Error-enum" />QXmlStreamReader.Error</h3><p>This enum specifies different error cases</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.NoError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">No error has occurred.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.CustomError</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">A custom error has been raised with <a href="qxmlstreamreader.html#raiseError">raiseError</a>()</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.NotWellFormedError</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The parser internally raised an error due to
the read XML not being well-formed.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.PrematureEndOfDocumentError</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The input stream ended before a well-formed
XML document was parsed. Recovery from this error is possible if
more XML arrives in the stream, either by calling <a href="qxmlstreamreader.html#addData">addData</a>() or by waiting for it
to arrive on the <a href="qxmlstreamreader.html#device">device</a>().</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.UnexpectedElementError</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">The parser encountered an element that was
different to those it expected.</td>
</tr>
</table>


<h3 class="fn"><a name="ReadElementTextBehaviour-enum" />QXmlStreamReader.ReadElementTextBehaviour</h3><p>This enum specifies the different behaviours of <a href="qxmlstreamreader.html#readElementText">readElementText</a>().</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.ErrorOnUnexpectedElement</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">Raise an <a href="qxmlstreamreader.html#Error-enum">UnexpectedElementError</a> and
return what was read so far when a child element is
encountered.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.IncludeChildElements</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">Recursively include the text from child
elements.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.SkipChildElements</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">Skip child elements.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.6.</p>


<h3 class="fn"><a name="TokenType-enum" />QXmlStreamReader.TokenType</h3><p>This enum specifies the type of token the reader just read.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.NoToken</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">The reader has not yet read anything.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.Invalid</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">An error has occurred, reported in <a href="qxmlstreamreader.html#error">error</a>() and <a href="qxmlstreamreader.html#errorString">errorString</a>().</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.StartDocument</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">The reader reports the XML version number in
<a href="qxmlstreamreader.html#documentVersion">documentVersion</a>(), and
the encoding as specified in the XML document in <a href="qxmlstreamreader.html#documentEncoding">documentEncoding</a>(). If
the document is declared standalone, <a href="qxmlstreamreader.html#isStandaloneDocument">isStandaloneDocument</a>()
returns true; otherwise it returns false.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.EndDocument</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">The reader reports the end of the
document.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.StartElement</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">The reader reports the start of an element
with <a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>() and
<a href="qxmlstreamreader.html#name">name</a>(). Empty elements are
also reported as StartElement, followed directly by EndElement. The
convenience function <a href="qxmlstreamreader.html#readElementText">readElementText</a>() can
be called to concatenate all content until the corresponding
EndElement. Attributes are reported in <a href="qxmlstreamreader.html#attributes">attributes</a>(), namespace
declarations in <a href="qxmlstreamreader.html#namespaceDeclarations">namespaceDeclarations</a>().</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.EndElement</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">The reader reports the end of an element with
<a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>() and
<a href="qxmlstreamreader.html#name">name</a>().</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.Characters</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">The reader reports characters in <a href="qxmlstreamreader.html#text">text</a>(). If the characters are all
white-space, <a href="qxmlstreamreader.html#isWhitespace">isWhitespace</a>() returns
true. If the characters stem from a CDATA section, <a href="qxmlstreamreader.html#isCDATA">isCDATA</a>() returns true.</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.Comment</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">The reader reports a comment in <a href="qxmlstreamreader.html#text">text</a>().</td>
</tr>
<tr>
<td class="topAlign"><tt>QXmlStreamReader.DTD</tt></td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">The reader reports a DTD in <a href="qxmlstreamreader.html#text">text</a>(), notation declarations in
<a href="qxmlstreamreader.html#notationDeclarations">notationDeclarations</a>(),
and entity declarations in <a href="qxmlstreamreader.html#entityDeclarations">entityDeclarations</a>().
Details of the DTD declaration are reported in in <a href="qxmlstreamreader.html#dtdName">dtdName</a>(), <a href="qxmlstreamreader.html#dtdPublicId">dtdPublicId</a>(), and <a href="qxmlstreamreader.html#dtdSystemId">dtdSystemId</a>().</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.EntityReference</tt></td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">The reader reports an entity reference that
could not be resolved. The name of the reference is reported in
<a href="qxmlstreamreader.html#name">name</a>(), the replacement
text in <a href="qxmlstreamreader.html#text">text</a>().</td>
</tr>
<tr>
<td class="topAlign">
<tt>QXmlStreamReader.ProcessingInstruction</tt></td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">The reader reports a processing instruction in
<a href="qxmlstreamreader.html#processingInstructionTarget">processingInstructionTarget</a>()
and <a href="qxmlstreamreader.html#processingInstructionData">processingInstructionData</a>().</td>
</tr>
</table>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QXmlStreamReader" />QXmlStreamReader.__init__ (<i>self</i>)</h3><p>Constructs a stream reader.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#setDevice">setDevice</a>() and <a href="qxmlstreamreader.html#addData">addData</a>().</p>


<h3 class="fn"><a name="QXmlStreamReader-2" />QXmlStreamReader.__init__ (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>)</h3><p>Creates a new stream reader that reads from <i>device</i>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#setDevice">setDevice</a>() and <a href="qxmlstreamreader.html#clear">clear</a>().</p>


<h3 class="fn"><a name="QXmlStreamReader-3" />QXmlStreamReader.__init__ (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>)</h3><p>Creates a new stream reader that reads from <i>data</i>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#addData">addData</a>(), <a href="qxmlstreamreader.html#clear">clear</a>(), and <a href="qxmlstreamreader.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="QXmlStreamReader-4" />QXmlStreamReader.__init__ (<i>self</i>, QString&#160;<i>data</i>)</h3><p>Creates a new stream reader that reads from <i>data</i>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#addData">addData</a>(), <a href="qxmlstreamreader.html#clear">clear</a>(), and <a href="qxmlstreamreader.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="addData" />QXmlStreamReader.addData (<i>self</i>, <a href="qbytearray.html">QByteArray</a>&#160;<i>data</i>)</h3><p>Adds more <i>data</i> for the reader to read. This function does
nothing if the reader has a <a href="qxmlstreamreader.html#device">device</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#readNext">readNext</a>() and <a href="qxmlstreamreader.html#clear">clear</a>().</p>


<h3 class="fn"><a name="addData-2" />QXmlStreamReader.addData (<i>self</i>, QString&#160;<i>data</i>)</h3><p>Adds more <i>data</i> for the reader to read. This function does
nothing if the reader has a <a href="qxmlstreamreader.html#device">device</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#readNext">readNext</a>() and <a href="qxmlstreamreader.html#clear">clear</a>().</p>


<h3 class="fn"><a name="addExtraNamespaceDeclaration" />QXmlStreamReader.addExtraNamespaceDeclaration (<i>self</i>, <a href="qxmlstreamnamespacedeclaration.html">QXmlStreamNamespaceDeclaration</a>&#160;<i>extraNamespaceDeclaraction</i>)</h3><p>Adds an <i>extraNamespaceDeclaration</i>. The declaration will
be valid for children of the current element, or - should the
function be called before any elements are read - for the entire
XML document.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#namespaceDeclarations">namespaceDeclarations</a>(),
<a href="qxmlstreamreader.html#addExtraNamespaceDeclarations">addExtraNamespaceDeclarations</a>(),
and <a href="qxmlstreamreader.html#namespaceProcessing-prop">setNamespaceProcessing</a>().</p>


<h3 class="fn"><a name="addExtraNamespaceDeclarations" />QXmlStreamReader.addExtraNamespaceDeclarations (<i>self</i>, list-of-QXmlStreamNamespaceDeclaration&#160;<i>extraNamespaceDeclaractions</i>)</h3><p>Adds a vector of declarations specified by
<i>extraNamespaceDeclarations</i>.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#namespaceDeclarations">namespaceDeclarations</a>()
and <a href="qxmlstreamreader.html#addExtraNamespaceDeclaration">addExtraNamespaceDeclaration</a>().</p>


<h3 class="fn"><a name="atEnd" />bool QXmlStreamReader.atEnd (<i>self</i>)</h3><p>Returns true if the reader has read until the end of the XML
document, or if an <a href="qxmlstreamreader.html#error">error</a>() has occurred and reading
has been aborted. Otherwise, it returns false.</p>
<p>When atEnd() and <a href="qxmlstreamreader.html#hasError">hasError</a>() return true and
<a href="qxmlstreamreader.html#error">error</a>() returns <a href="qxmlstreamreader.html#Error-enum">PrematureEndOfDocumentError</a>,
it means the XML has been well-formed so far, but a complete XML
document has not been parsed. The next chunk of XML can be added
with <a href="qxmlstreamreader.html#addData">addData</a>(), if the
XML is being read from a <a href="qbytearray.html">QByteArray</a>,
or by waiting for more data to arrive if the XML is being read from
a <a href="qiodevice.html">QIODevice</a>. Either way, atEnd() will
return false once more data is available.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#hasError">hasError</a>(), <a href="qxmlstreamreader.html#error">error</a>(), <a href="qxmlstreamreader.html#device">device</a>(), and <a href="qiodevice.html#atEnd">QIODevice.atEnd</a>().</p>


<h3 class="fn"><a name="attributes" /><a href="qxmlstreamattributes.html">QXmlStreamAttributes</a> QXmlStreamReader.attributes (<i>self</i>)</h3><p>Returns the attributes of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>.</p>


<h3 class="fn"><a name="characterOffset" />int QXmlStreamReader.characterOffset (<i>self</i>)</h3><p>Returns the current character offset, starting with 0.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#lineNumber">lineNumber</a>() and <a href="qxmlstreamreader.html#columnNumber">columnNumber</a>().</p>


<h3 class="fn"><a name="clear" />QXmlStreamReader.clear (<i>self</i>)</h3><p>Removes any <a href="qxmlstreamreader.html#device">device</a>()
or data from the reader and resets its internal state to the
initial state.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#addData">addData</a>().</p>


<h3 class="fn"><a name="columnNumber" />int QXmlStreamReader.columnNumber (<i>self</i>)</h3><p>Returns the current column number, starting with 0.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#lineNumber">lineNumber</a>() and <a href="qxmlstreamreader.html#characterOffset">characterOffset</a>().</p>


<h3 class="fn"><a name="device" /><a href="qiodevice.html">QIODevice</a> QXmlStreamReader.device (<i>self</i>)</h3><p>Returns the current device associated with the <a href="qxmlstreamreader.html">QXmlStreamReader</a>, or 0 if no device has
been assigned.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#setDevice">setDevice</a>().</p>


<h3 class="fn"><a name="documentEncoding" />QStringRef QXmlStreamReader.documentEncoding (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">StartDocument</a>, this
function returns the encoding string as specified in the XML
declaration. Otherwise an empty string is returned.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="documentVersion" />QStringRef QXmlStreamReader.documentVersion (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">StartDocument</a>, this
function returns the version string as specified in the XML
declaration. Otherwise an empty string is returned.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="dtdName" />QStringRef QXmlStreamReader.dtdName (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, this function
returns the DTD's name. Otherwise an empty string is returned.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="dtdPublicId" />QStringRef QXmlStreamReader.dtdPublicId (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, this function
returns the DTD's public identifier. Otherwise an empty string is
returned.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="dtdSystemId" />QStringRef QXmlStreamReader.dtdSystemId (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, this function
returns the DTD's system identifier. Otherwise an empty string is
returned.</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="entityDeclarations" />list-of-QXmlStreamEntityDeclaration QXmlStreamReader.entityDeclarations (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, this function
returns the DTD's unparsed (external) entity declarations.
Otherwise an empty vector is returned.</p>
<p>The <a href="qxmlstreamentitydeclaration.html#QXmlStreamEntityDeclarations-typedef">
QXmlStreamEntityDeclarations</a> class is defined to be a <a href="qvector.html">QVector</a> of <a href="qxmlstreamentitydeclaration.html">QXmlStreamEntityDeclaration</a>.</p>


<h3 class="fn"><a name="entityResolver" /><a href="qxmlstreamentityresolver.html">QXmlStreamEntityResolver</a> QXmlStreamReader.entityResolver (<i>self</i>)</h3><p>Returns the entity resolver, or 0 if there is no entity
resolver.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#setEntityResolver">setEntityResolver</a>().</p>


<h3 class="fn"><a name="error" /><a href="qxmlstreamreader.html#Error-enum">Error</a> QXmlStreamReader.error (<i>self</i>)</h3><p>Returns the type of the current error, or <a href="qxmlstreamreader.html#Error-enum">NoError</a> if no error
occurred.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#errorString">errorString</a>() and <a href="qxmlstreamreader.html#raiseError">raiseError</a>().</p>


<h3 class="fn"><a name="errorString" />QString QXmlStreamReader.errorString (<i>self</i>)</h3><p>Returns the error message that was set with <a href="qxmlstreamreader.html#raiseError">raiseError</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#error">error</a>(), <a href="qxmlstreamreader.html#lineNumber">lineNumber</a>(), <a href="qxmlstreamreader.html#columnNumber">columnNumber</a>(), and
<a href="qxmlstreamreader.html#characterOffset">characterOffset</a>().</p>


<h3 class="fn"><a name="hasError" />bool QXmlStreamReader.hasError (<i>self</i>)</h3><p>Returns <tt>true</tt> if an error has occurred, otherwise
<tt>false</tt>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#errorString">errorString</a>() and <a href="qxmlstreamreader.html#error">error</a>().</p>


<h3 class="fn"><a name="isCDATA" />bool QXmlStreamReader.isCDATA (<i>self</i>)</h3><p>Returns true if the reader reports characters that stem from a
CDATA section; otherwise returns false.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#isCharacters">isCharacters</a>() and
<a href="qxmlstreamreader.html#text">text</a>().</p>


<h3 class="fn"><a name="isCharacters" />bool QXmlStreamReader.isCharacters (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">Characters</a>; otherwise
returns false.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#isWhitespace">isWhitespace</a>() and
<a href="qxmlstreamreader.html#isCDATA">isCDATA</a>().</p>


<h3 class="fn"><a name="isComment" />bool QXmlStreamReader.isComment (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">Comment</a>; otherwise
returns false.</p>


<h3 class="fn"><a name="isDTD" />bool QXmlStreamReader.isDTD (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>; otherwise returns
false.</p>


<h3 class="fn"><a name="isEndDocument" />bool QXmlStreamReader.isEndDocument (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">EndDocument</a>; otherwise
returns false.</p>


<h3 class="fn"><a name="isEndElement" />bool QXmlStreamReader.isEndElement (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>; otherwise
returns false.</p>


<h3 class="fn"><a name="isEntityReference" />bool QXmlStreamReader.isEntityReference (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">EntityReference</a>;
otherwise returns false.</p>


<h3 class="fn"><a name="isProcessingInstruction" />bool QXmlStreamReader.isProcessingInstruction (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">ProcessingInstruction</a>;
otherwise returns false.</p>


<h3 class="fn"><a name="isStandaloneDocument" />bool QXmlStreamReader.isStandaloneDocument (<i>self</i>)</h3><p>Returns true if this document has been declared standalone in
the XML declaration; otherwise returns false.</p>
<p>If no XML declaration has been parsed, this function returns
false.</p>


<h3 class="fn"><a name="isStartDocument" />bool QXmlStreamReader.isStartDocument (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">StartDocument</a>; otherwise
returns false.</p>


<h3 class="fn"><a name="isStartElement" />bool QXmlStreamReader.isStartElement (<i>self</i>)</h3><p>Returns true if <a href="qxmlstreamreader.html#tokenType">tokenType</a>() equals <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>; otherwise
returns false.</p>


<h3 class="fn"><a name="isWhitespace" />bool QXmlStreamReader.isWhitespace (<i>self</i>)</h3><p>Returns true if the reader reports characters that only consist
of white-space; otherwise returns false.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#isCharacters">isCharacters</a>() and
<a href="qxmlstreamreader.html#text">text</a>().</p>


<h3 class="fn"><a name="lineNumber" />int QXmlStreamReader.lineNumber (<i>self</i>)</h3><p>Returns the current line number, starting with 1.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#columnNumber">columnNumber</a>() and
<a href="qxmlstreamreader.html#characterOffset">characterOffset</a>().</p>


<h3 class="fn"><a name="name" />QStringRef QXmlStreamReader.name (<i>self</i>)</h3><p>Returns the local name of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>, <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>, or an
<a href="qxmlstreamreader.html#TokenType-enum">EntityReference</a>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>() and
<a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a>().</p>


<h3 class="fn"><a name="namespaceDeclarations" />list-of-QXmlStreamNamespaceDeclaration QXmlStreamReader.namespaceDeclarations (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>, this
function returns the element's namespace declarations. Otherwise an
empty vector is returned.</p>
<p>The <a href="qxmlstreamnamespacedeclaration.html">QXmlStreamNamespaceDeclaration</a>
class is defined to be a <a href="qvector.html">QVector</a> of
<a href="qxmlstreamnamespacedeclaration.html">QXmlStreamNamespaceDeclaration</a>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#addExtraNamespaceDeclaration">addExtraNamespaceDeclaration</a>()
and <a href="qxmlstreamreader.html#addExtraNamespaceDeclarations">addExtraNamespaceDeclarations</a>().</p>


<h3 class="fn"><a name="namespaceProcessing" />bool QXmlStreamReader.namespaceProcessing (<i>self</i>)</h3><h3 class="fn"><a name="namespaceUri" />QStringRef QXmlStreamReader.namespaceUri (<i>self</i>)</h3><p>Returns the namespaceUri of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a> or <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#name">name</a>()
and <a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a>().</p>


<h3 class="fn"><a name="notationDeclarations" />list-of-QXmlStreamNotationDeclaration QXmlStreamReader.notationDeclarations (<i>self</i>)</h3><p>If the state() is <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, this function
returns the DTD's notation declarations. Otherwise an empty vector
is returned.</p>
<p>The <a href="qxmlstreamnotationdeclaration.html#QXmlStreamNotationDeclarations-typedef">
QXmlStreamNotationDeclarations</a> class is defined to be a
<a href="qvector.html">QVector</a> of <a href="qxmlstreamnotationdeclaration.html">QXmlStreamNotationDeclaration</a>.</p>


<h3 class="fn"><a name="prefix" />QStringRef QXmlStreamReader.prefix (<i>self</i>)</h3><p>Returns the prefix of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a> or <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#name">name</a>()
and <a href="qxmlstreamreader.html#qualifiedName">qualifiedName</a>().</p>


<h3 class="fn"><a name="processingInstructionData" />QStringRef QXmlStreamReader.processingInstructionData (<i>self</i>)</h3><p>Returns the data of a <a href="qxmlstreamreader.html#TokenType-enum">ProcessingInstruction</a>.</p>


<h3 class="fn"><a name="processingInstructionTarget" />QStringRef QXmlStreamReader.processingInstructionTarget (<i>self</i>)</h3><p>Returns the target of a <a href="qxmlstreamreader.html#TokenType-enum">ProcessingInstruction</a>.</p>


<h3 class="fn"><a name="qualifiedName" />QStringRef QXmlStreamReader.qualifiedName (<i>self</i>)</h3><p>Returns the qualified name of a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a> or <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>;</p>
<p>A qualified name is the raw name of an element in the XML data.
It consists of the namespace prefix, followed by colon, followed by
the element's local name. Since the namespace prefix is not unique
(the same prefix can point to different namespaces and different
prefixes can point to the same namespace), you shouldn't use
qualifiedName(), but the resolved <a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>() and the
attribute's local <a href="qxmlstreamreader.html#name">name</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#name">name</a>(),
<a href="qxmlstreamreader.html#prefix">prefix</a>(), and <a href="qxmlstreamreader.html#namespaceUri">namespaceUri</a>().</p>


<h3 class="fn"><a name="raiseError" />QXmlStreamReader.raiseError (<i>self</i>, QString&#160;<i>message</i>&#160;=&#160;QString())</h3><p>Raises a custom error with an optional error <i>message</i>.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#error">error</a>() and <a href="qxmlstreamreader.html#errorString">errorString</a>().</p>


<h3 class="fn"><a name="readElementText" />QString QXmlStreamReader.readElementText (<i>self</i>)</h3><p>Convenience function to be called in case a <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a> was read.
Reads until the corresponding <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a> and returns
all text in-between. In case of no error, the current token (see
<a href="qxmlstreamreader.html#tokenType">tokenType</a>()) after
having called this function is <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>.</p>
<p>The function concatenates <a href="qxmlstreamreader.html#text">text</a>() when it reads either
<a href="qxmlstreamreader.html#TokenType-enum">Characters</a> or
<a href="qxmlstreamreader.html#TokenType-enum">EntityReference</a>
tokens, but skips <a href="qxmlstreamreader.html#TokenType-enum">ProcessingInstruction</a>
and <a href="qxmlstreamreader.html#TokenType-enum">Comment</a>. If
the current token is not <a href="qxmlstreamreader.html#TokenType-enum">StartElement</a>, an empty
string is returned.</p>
<p>The <i>behaviour</i> defines what happens in case anything else
is read before reaching <a href="qxmlstreamreader.html#TokenType-enum">EndElement</a>. The function
can include the text from child elements (useful for example for
HTML), ignore child elements, or raise an <a href="qxmlstreamreader.html#Error-enum">UnexpectedElementError</a> and
return what was read so far.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="readElementText-2" />QString QXmlStreamReader.readElementText (<i>self</i>, <a href="qxmlstreamreader.html#ReadElementTextBehaviour-enum">ReadElementTextBehaviour</a>&#160;<i>behaviour</i>)</h3><p>This function overloads <a href="qxmlstreamreader.html#readElementText">readElementText</a>().</p>
<p>Calling this function is equivalent to calling
readElementText(<a href="qxmlstreamreader.html#ReadElementTextBehaviour-enum">ErrorOnUnexpectedElement</a>).</p>


<h3 class="fn"><a name="readNext" /><a href="qxmlstreamreader.html#TokenType-enum">TokenType</a> QXmlStreamReader.readNext (<i>self</i>)</h3><p>Reads the next token and returns its type.</p>
<p>With one exception, once an <a href="qxmlstreamreader.html#error">error</a>() is reported by
readNext(), further reading of the XML stream is not possible. Then
<a href="qxmlstreamreader.html#atEnd">atEnd</a>() returns true,
<a href="qxmlstreamreader.html#hasError">hasError</a>() returns
true, and this function returns <a href="qxmlstreamreader.html#TokenType-enum">QXmlStreamReader.Invalid</a>.</p>
<p>The exception is when <a href="qxmlstreamreader.html#error">error</a>() returns <a href="qxmlstreamreader.html#Error-enum">PrematureEndOfDocumentError</a>.
This error is reported when the end of an otherwise well-formed
chunk of XML is reached, but the chunk doesn't represent a complete
XML document. In that case, parsing <i>can</i> be resumed by
calling <a href="qxmlstreamreader.html#addData">addData</a>() to
add the next chunk of XML, when the stream is being read from a
<a href="qbytearray.html">QByteArray</a>, or by waiting for more
data to arrive when the stream is being read from a <a href="qxmlstreamreader.html#device">device</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#tokenType">tokenType</a>() and <a href="qxmlstreamreader.html#tokenString">tokenString</a>().</p>


<h3 class="fn"><a name="readNextStartElement" />bool QXmlStreamReader.readNextStartElement (<i>self</i>)</h3><p>Reads until the next start element within the current element.
Returns true when a start element was reached. When the end element
was reached, or when an error occurred, false is returned.</p>
<p>The current element is the element matching the most recently
parsed start element of which a matching end element has not yet
been reached. When the parser has reached the end element, the
current element becomes the parent element.</p>
<p>You can traverse a document by repeatedly calling this function
while ensuring that the stream reader is not at the end of the
document:</p>
<pre class="cpp">
 <span class="type"><a href="qxmlstreamreader.html">QXmlStreamReader</a></span> xs(<span class="operator">&amp;</span>file);
 <span class="keyword">while</span> (<span class="operator">!</span>xs<span class="operator">.</span>atEnd()) {
     <span class="keyword">if</span> (xs<span class="operator">.</span>readNextStartElement())
         std<span class="operator">.</span>cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <a href="qtcore.html#qPrintable">qPrintable</a>(xs<span class="operator">.</span>name()<span class="operator">.</span>toString()) <span class="operator">&lt;</span><span class="operator">&lt;</span> std<span class="operator">.</span>endl;
 }
</pre>
<p>This is a convenience function for when you're only concerned
with parsing XML elements. The <a href="xml-streambookmarks.html">QXmlStream Bookmarks Example</a> makes
extensive use of this function.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#readNext">readNext</a>().</p>


<h3 class="fn"><a name="setDevice" />QXmlStreamReader.setDevice (<i>self</i>, <a href="qiodevice.html">QIODevice</a>&#160;<i>device</i>)</h3><p>Sets the current device to <i>device</i>. Setting the device
resets the stream to its initial state.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#device">device</a>() and <a href="qxmlstreamreader.html#clear">clear</a>().</p>


<h3 class="fn"><a name="setEntityResolver" />QXmlStreamReader.setEntityResolver (<i>self</i>, <a href="qxmlstreamentityresolver.html">QXmlStreamEntityResolver</a>&#160;<i>resolver</i>)</h3><p>Makes <i>resolver</i> the new <a href="qxmlstreamreader.html#entityResolver">entityResolver</a>().</p>
<p>The stream reader does <i>not</i> take ownership of the
resolver. It's the callers responsibility to ensure that the
resolver is valid during the entire life-time of the stream reader
object, or until another resolver or 0 is set.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#entityResolver">entityResolver</a>().</p>


<h3 class="fn"><a name="setNamespaceProcessing" />QXmlStreamReader.setNamespaceProcessing (<i>self</i>, bool)</h3><h3 class="fn"><a name="skipCurrentElement" />QXmlStreamReader.skipCurrentElement (<i>self</i>)</h3><p>Reads until the end of the current element, skipping any child
nodes. This function is useful for skipping unknown elements.</p>
<p>The current element is the element matching the most recently
parsed start element of which a matching end element has not yet
been reached. When the parser has reached the end element, the
current element becomes the parent element.</p>
<p>This function was introduced in Qt 4.6.</p>


<h3 class="fn"><a name="text" />QStringRef QXmlStreamReader.text (<i>self</i>)</h3><p>Returns the text of <a href="qxmlstreamreader.html#TokenType-enum">Characters</a>, <a href="qxmlstreamreader.html#TokenType-enum">Comment</a>, <a href="qxmlstreamreader.html#TokenType-enum">DTD</a>, or <a href="qxmlstreamreader.html#TokenType-enum">EntityReference</a>.</p>


<h3 class="fn"><a name="tokenString" />QString QXmlStreamReader.tokenString (<i>self</i>)</h3><p>Returns the reader's current token as string.</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#tokenType">tokenType</a>().</p>


<h3 class="fn"><a name="tokenType" /><a href="qxmlstreamreader.html#TokenType-enum">TokenType</a> QXmlStreamReader.tokenType (<i>self</i>)</h3><p>Returns the type of the current token.</p>
<p>The current token can also be queried with the convenience
functions <a href="qxmlstreamreader.html#isStartDocument">isStartDocument</a>(),
<a href="qxmlstreamreader.html#isEndDocument">isEndDocument</a>(),
<a href="qxmlstreamreader.html#isStartElement">isStartElement</a>(),
<a href="qxmlstreamreader.html#isEndElement">isEndElement</a>(),
<a href="qxmlstreamreader.html#isCharacters">isCharacters</a>(),
<a href="qxmlstreamreader.html#isComment">isComment</a>(), <a href="qxmlstreamreader.html#isDTD">isDTD</a>(), <a href="qxmlstreamreader.html#isEntityReference">isEntityReference</a>(),
and <a href="qxmlstreamreader.html#isProcessingInstruction">isProcessingInstruction</a>().</p>
<p><b>See also</b> <a href="qxmlstreamreader.html#tokenString">tokenString</a>().</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>