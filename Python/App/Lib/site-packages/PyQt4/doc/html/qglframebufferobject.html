<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html><head><title>QGLFramebufferObject Class Reference</title><style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style></head><body><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr /><td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" width="32" /></td><td width="1">&#160;&#160;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&#160;&#183; <a href="classes.html"><font color="#004faf">All Classes</font></a>&#160;&#183; <a href="modules.html"><font color="#004faf">Modules</font></a></td></table><h1 align="center">QGLFramebufferObject Class Reference<br /><sup><sup>[<a href="qtopengl.html">QtOpenGL</a> module]</sup></sup></h1><p>The QGLFramebufferObject class encapsulates an OpenGL
framebuffer object. <a href="#details">More...</a></p>

<p>Inherits <a href="qpaintdevice.html">QPaintDevice</a>.</p><h3>Types</h3><ul><li><div class="fn" />enum <b><a href="qglframebufferobject.html#Attachment-enum">Attachment</a></b> { NoAttachment, CombinedDepthStencil, Depth }</li></ul><h3>Methods</h3><ul><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject">__init__</a></b> (<i>self</i>, QSize&#160;<i>size</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject-2">__init__</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject-3">__init__</a></b> (<i>self</i>, QSize&#160;<i>size</i>, Attachment&#160;<i>attachment</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>internalFormat</i>&#160;=&#160;GL_RGBA8)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject-4">__init__</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, Attachment&#160;<i>attachment</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>internalFormat</i>&#160;=&#160;GL_RGBA8)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject-5">__init__</a></b> (<i>self</i>, QSize&#160;<i>size</i>, QGLFramebufferObjectFormat&#160;<i>format</i>)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#QGLFramebufferObject-6">__init__</a></b> (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, QGLFramebufferObjectFormat&#160;<i>format</i>)</li><li><div class="fn" />Attachment <b><a href="qglframebufferobject.html#attachment">attachment</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#bind">bind</a></b> (<i>self</i>)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#drawTexture">drawTexture</a></b> (<i>self</i>, QRectF&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" /><b><a href="qglframebufferobject.html#drawTexture-2">drawTexture</a></b> (<i>self</i>, QPointF&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</li><li><div class="fn" />QGLFramebufferObjectFormat <b><a href="qglframebufferobject.html#format">format</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglframebufferobject.html#handle">handle</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#isBound">isBound</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#isValid">isValid</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglframebufferobject.html#metric">metric</a></b> (<i>self</i>, QPaintDevice.PaintDeviceMetric&#160;<i>metric</i>)</li><li><div class="fn" />QPaintEngine <b><a href="qglframebufferobject.html#paintEngine">paintEngine</a></b> (<i>self</i>)</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#release">release</a></b> (<i>self</i>)</li><li><div class="fn" />QSize <b><a href="qglframebufferobject.html#size">size</a></b> (<i>self</i>)</li><li><div class="fn" />int <b><a href="qglframebufferobject.html#texture">texture</a></b> (<i>self</i>)</li><li><div class="fn" />QImage <b><a href="qglframebufferobject.html#toImage">toImage</a></b> (<i>self</i>)</li></ul><h3>Static Methods</h3><ul><li><div class="fn" /><b><a href="qglframebufferobject.html#blitFramebuffer">blitFramebuffer</a></b> (QGLFramebufferObject&#160;<i>target</i>, QRect&#160;<i>targetRect</i>, QGLFramebufferObject&#160;<i>source</i>, QRect&#160;<i>sourceRect</i>, int&#160;<i>buffers</i>&#160;=&#160;GL_COLOR_BUFFER_BIT, int&#160;<i>filter</i>&#160;=&#160;GL_NEAREST)</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#hasOpenGLFramebufferBlit">hasOpenGLFramebufferBlit</a></b> ()</li><li><div class="fn" />bool <b><a href="qglframebufferobject.html#hasOpenGLFramebufferObjects">hasOpenGLFramebufferObjects</a></b> ()</li></ul><a name="details" /><hr /><h2>Detailed Description</h2><p>The QGLFramebufferObject class encapsulates an OpenGL
framebuffer object.</p>
<p>The QGLFramebufferObject class encapsulates an OpenGL
framebuffer object, defined by the
<tt>GL_EXT_framebuffer_object</tt> extension. In addition it
provides a rendering surface that can be painted on with a <a href="qpainter.html">QPainter</a>, rendered to using native GL calls, or
both. This surface can be bound and used as a regular texture in
your own GL drawing code. By default, the QGLFramebufferObject
class generates a 2D GL texture (using the <tt>GL_TEXTURE_2D</tt>
target), which is used as the internal rendering target.</p>
<p><b>It is important to have a current GL context when creating a
QGLFramebufferObject, otherwise initialization will fail.</b></p>
<p>OpenGL framebuffer objects and pbuffers (see <a href="qglpixelbuffer.html">QGLPixelBuffer</a>) can both be used to
render to offscreen surfaces, but there are a number of advantages
with using framebuffer objects instead of pbuffers:</p>
<ol class="1">
<li>A framebuffer object does not require a separate rendering
context, so no context switching will occur when switching
rendering targets. There is an overhead involved in switching
targets, but in general it is cheaper than a context switch to a
pbuffer.</li>
<li>Rendering to dynamic textures (i.e. render-to-texture
functionality) works on all platforms. No need to do explicit copy
calls from a render buffer into a texture, as was necessary on
systems that did not support the <tt>render_texture</tt>
extension.</li>
<li>It is possible to attach several rendering buffers (or texture
objects) to the same framebuffer object, and render to all of them
without doing a context switch.</li>
<li>The OpenGL framebuffer extension is a pure GL extension with no
system dependant WGL, CGL, or GLX parts. This makes using
framebuffer objects more portable.</li>
</ol>
<p>When using a <a href="qpainter.html">QPainter</a> to paint to a
QGLFramebufferObject you should take care that the
QGLFramebufferObject is created with the <a href="qglframebufferobject.html#Attachment-enum">CombinedDepthStencil</a>
attachment for <a href="qpainter.html">QPainter</a> to be able to
render correctly. Note that you need to create a
QGLFramebufferObject with more than one sample per pixel for
primitives to be antialiased when drawing using a <a href="qpainter.html">QPainter</a>. To create a multisample framebuffer
object you should use one of the constructors that take a
QGLFramebufferObject parameter, and set the
QGLFramebufferObject.samples() property to a non-zero value.</p>
<p>When painting to a QGLFramebufferObject using <a href="qpainter.html">QPainter</a>, the state of the current GL context
will be altered by the paint engine to reflect its needs.
Applications should not rely upon the GL state being reset to its
original conditions, particularly the current shader program, GL
viewport, texture units, and drawing modes.</p>
<p>For multisample framebuffer objects a color render buffer is
created, otherwise a texture with the specified texture target is
created. The color render buffer or texture will have the specified
internal format, and will be bound to the
<tt>GL_COLOR_ATTACHMENT0</tt> attachment in the framebuffer
object.</p>
<p>If you want to use a framebuffer object with multisampling
enabled as a texture, you first need to copy from it to a regular
framebuffer object using QGLContext.blitFramebuffer().</p>
<a id="threading" name="threading" />
<h3>Threading</h3>
<p>As of Qt 4.8, it's possible to draw into a QGLFramebufferObject
using a <a href="qpainter.html">QPainter</a> in a separate thread.
Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.
Also, under X11, it's necessary to set the <a href="qt.html#ApplicationAttribute-enum">Qt.AA_X11InitThreads</a>
application attribute.</p>
<hr /><h2>Type Documentation</h2><h3 class="fn"><a name="Attachment-enum" />QGLFramebufferObject.Attachment</h3><p>This enum type is used to configure the depth and stencil
buffers attached to the framebuffer object when it is created.</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QGLFramebufferObject.NoAttachment</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">No attachment is added to the framebuffer
object. Note that the OpenGL depth and stencil tests won't work
when rendering to a framebuffer object without any depth or stencil
buffers. This is the default value.</td>
</tr>
<tr>
<td class="topAlign">
<tt>QGLFramebufferObject.CombinedDepthStencil</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">If the <tt>GL_EXT_packed_depth_stencil</tt>
extension is present, a combined depth and stencil buffer is
attached. If the extension is not present, only a depth buffer is
attached.</td>
</tr>
<tr>
<td class="topAlign"><tt>QGLFramebufferObject.Depth</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">A depth buffer is attached to the framebuffer
object.</td>
</tr>
</table>
<p>This enum was introduced or modified in Qt 4.3.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#attachment">attachment</a>().</p>
<hr /><h2>Method Documentation</h2><h3 class="fn"><a name="QGLFramebufferObject" />QGLFramebufferObject.__init__ (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Constructs an OpenGL framebuffer object and binds a 2D GL
texture to the buffer of the size <i>size</i>. The texture is bound
to the <tt>GL_COLOR_ATTACHMENT0</tt> target in the framebuffer
object.</p>
<p>The <i>target</i> parameter is used to specify the GL texture
target. The default target is <tt>GL_TEXTURE_2D</tt>. Keep in mind
that <tt>GL_TEXTURE_2D</tt> textures must have a power of 2 width
and height (e.g. 256x512), unless you are using OpenGL 2.0 or
higher.</p>
<p>By default, no depth and stencil buffers are attached. This
behavior can be toggled using one of the overloaded
constructors.</p>
<p>The default internal texture format is <tt>GL_RGBA8</tt> for
desktop OpenGL, and <tt>GL_RGBA</tt> for OpenGL/ES.</p>
<p>It is important that you have a current GL context set when
creating the <a href="qglframebufferobject.html">QGLFramebufferObject</a>, otherwise the
initialization will fail.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#size">size</a>(), <a href="qglframebufferobject.html#texture">texture</a>(), and <a href="qglframebufferobject.html#attachment">attachment</a>().</p>


<h3 class="fn"><a name="QGLFramebufferObject-2" />QGLFramebufferObject.__init__ (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a 2D GL
texture to the buffer of the given <i>width</i> and
<i>height</i>.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#size">size</a>() and <a href="qglframebufferobject.html#texture">texture</a>().</p>


<h3 class="fn"><a name="QGLFramebufferObject-3" />QGLFramebufferObject.__init__ (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qglframebufferobject.html#Attachment-enum">Attachment</a>&#160;<i>attachment</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>internalFormat</i>&#160;=&#160;GL_RGBA8)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object of the given <i>size</i>
based on the supplied <i>format</i>.</p>


<h3 class="fn"><a name="QGLFramebufferObject-4" />QGLFramebufferObject.__init__ (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qglframebufferobject.html#Attachment-enum">Attachment</a>&#160;<i>attachment</i>, int&#160;<i>target</i>&#160;=&#160;GL_TEXTURE_2D, int&#160;<i>internalFormat</i>&#160;=&#160;GL_RGBA8)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object of the given
<i>width</i> and <i>height</i> based on the supplied
<i>format</i>.</p>


<h3 class="fn"><a name="QGLFramebufferObject-5" />QGLFramebufferObject.__init__ (<i>self</i>, <a href="qsize.html">QSize</a>&#160;<i>size</i>, <a href="qglframebufferobjectformat.html">QGLFramebufferObjectFormat</a>&#160;<i>format</i>)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a texture to
the buffer of the given <i>width</i> and <i>height</i>.</p>
<p>The <i>attachment</i> parameter describes the depth/stencil
buffer configuration, <i>target</i> the texture target and
<i>internal_format</i> the internal texture format. The default
texture target is <tt>GL_TEXTURE_2D</tt>, while the default
internal format is <tt>GL_RGBA8</tt> for desktop OpenGL and
<tt>GL_RGBA</tt> for OpenGL/ES.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#size">size</a>(), <a href="qglframebufferobject.html#texture">texture</a>(), and <a href="qglframebufferobject.html#attachment">attachment</a>().</p>


<h3 class="fn"><a name="QGLFramebufferObject-6" />QGLFramebufferObject.__init__ (<i>self</i>, int&#160;<i>width</i>, int&#160;<i>height</i>, <a href="qglframebufferobjectformat.html">QGLFramebufferObjectFormat</a>&#160;<i>format</i>)</h3><p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a texture to
the buffer of the given <i>size</i>.</p>
<p>The <i>attachment</i> parameter describes the depth/stencil
buffer configuration, <i>target</i> the texture target and
<i>internal_format</i> the internal texture format. The default
texture target is <tt>GL_TEXTURE_2D</tt>, while the default
internal format is <tt>GL_RGBA8</tt> for desktop OpenGL and
<tt>GL_RGBA</tt> for OpenGL/ES.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#size">size</a>(), <a href="qglframebufferobject.html#texture">texture</a>(), and <a href="qglframebufferobject.html#attachment">attachment</a>().</p>


<h3 class="fn"><a name="attachment" /><a href="qglframebufferobject.html#Attachment-enum">Attachment</a> QGLFramebufferObject.attachment (<i>self</i>)</h3><p>Returns the status of the depth and stencil buffers attached to
this framebuffer object.</p>


<h3 class="fn"><a name="bind" />bool QGLFramebufferObject.bind (<i>self</i>)</h3><p>Switches rendering from the default, windowing system provided
framebuffer to this framebuffer object. Returns true upon success,
false otherwise.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#release">release</a>().</p>


<h3 class="fn"><a name="blitFramebuffer" />QGLFramebufferObject.blitFramebuffer (<a href="qglframebufferobject.html">QGLFramebufferObject</a>&#160;<i>target</i>, <a href="qrect.html">QRect</a>&#160;<i>targetRect</i>, <a href="qglframebufferobject.html">QGLFramebufferObject</a>&#160;<i>source</i>, <a href="qrect.html">QRect</a>&#160;<i>sourceRect</i>, int&#160;<i>buffers</i>&#160;=&#160;GL_COLOR_BUFFER_BIT, int&#160;<i>filter</i>&#160;=&#160;GL_NEAREST)</h3><p>Blits from the <i>sourceRect</i> rectangle in the <i>source</i>
framebuffer object to the <i>targetRect</i> rectangle in the
<i>target</i> framebuffer object.</p>
<p>If <i>source</i> or <i>target</i> is 0, the default framebuffer
will be used instead of a framebuffer object as source or target
respectively.</p>
<p>The <i>buffers</i> parameter should be a mask consisting of any
combination of <tt>GL_COLOR_BUFFER_BIT</tt>,
<tt>GL_DEPTH_BUFFER_BIT</tt>, and <tt>GL_STENCIL_BUFFER_BIT</tt>.
Any buffer type that is not present both in the source and target
buffers is ignored.</p>
<p>The <i>sourceRect</i> and <i>targetRect</i> rectangles may have
different sizes; in this case <i>buffers</i> should not contain
<tt>GL_DEPTH_BUFFER_BIT</tt> or <tt>GL_STENCIL_BUFFER_BIT</tt>. The
<i>filter</i> parameter should be set to <tt>GL_LINEAR</tt> or
<tt>GL_NEAREST</tt>, and specifies whether linear or nearest
interpolation should be used when scaling is performed.</p>
<p>If <i>source</i> equals <i>target</i> a copy is performed within
the same buffer. Results are undefined if the source and target
rectangles overlap and have different sizes. The sizes must also be
the same if any of the framebuffer objects are multisample
framebuffers.</p>
<p>Note that the scissor test will restrict the blit area if
enabled.</p>
<p>This function will have no effect unless <a href="qglframebufferobject.html#hasOpenGLFramebufferBlit">hasOpenGLFramebufferBlit</a>()
returns true.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#hasOpenGLFramebufferBlit">hasOpenGLFramebufferBlit</a>().</p>


<h3 class="fn"><a name="drawTexture" />QGLFramebufferObject.drawTexture (<i>self</i>, <a href="qrectf.html">QRectF</a>&#160;<i>target</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Draws the given texture, <i>textureId</i>, to the given target
rectangle, <i>target</i>, in OpenGL model space. The
<i>textureTarget</i> should be a 2D texture target.</p>
<p>The framebuffer object should be bound when calling this
function.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="drawTexture-2" />QGLFramebufferObject.drawTexture (<i>self</i>, <a href="qpointf.html">QPointF</a>&#160;<i>point</i>, int&#160;<i>textureId</i>, int&#160;<i>textureTarget</i>&#160;=&#160;GL_TEXTURE_2D)</h3><p>Draws the given texture, <i>textureId</i>, at the given
<i>point</i> in OpenGL model space. The <i>textureTarget</i> should
be a 2D texture target.</p>
<p>The framebuffer object should be bound when calling this
function.</p>
<p>Equivalent to the corresponding <a href="qglcontext.html#drawTexture">QGLContext.drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>


<h3 class="fn"><a name="format" /><a href="qglframebufferobjectformat.html">QGLFramebufferObjectFormat</a> QGLFramebufferObject.format (<i>self</i>)</h3><p>Returns the format of this framebuffer object.</p>


<h3 class="fn"><a name="handle" />int QGLFramebufferObject.handle (<i>self</i>)</h3><p>Returns the GL framebuffer object handle for this framebuffer
object (returned by the <tt>glGenFrameBuffersEXT()</tt> function).
This handle can be used to attach new images or buffers to the
framebuffer. The user is responsible for cleaning up and destroying
these objects.</p>


<h3 class="fn"><a name="hasOpenGLFramebufferBlit" />bool QGLFramebufferObject.hasOpenGLFramebufferBlit ()</h3><p>Returns true if the OpenGL <tt>GL_EXT_framebuffer_blit</tt>
extension is present on this system; otherwise returns false.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#blitFramebuffer">blitFramebuffer</a>().</p>


<h3 class="fn"><a name="hasOpenGLFramebufferObjects" />bool QGLFramebufferObject.hasOpenGLFramebufferObjects ()</h3><p>Returns true if the OpenGL <tt>GL_EXT_framebuffer_object</tt>
extension is present on this system; otherwise returns false.</p>


<h3 class="fn"><a name="isBound" />bool QGLFramebufferObject.isBound (<i>self</i>)</h3><p>Returns true if the framebuffer object is currently bound to a
context, otherwise false is returned.</p>
<p>This function was introduced in Qt 4.5.</p>


<h3 class="fn"><a name="isValid" />bool QGLFramebufferObject.isValid (<i>self</i>)</h3><p>Returns true if the framebuffer object is valid.</p>
<p>The framebuffer can become invalid if the initialization process
fails, the user attaches an invalid buffer to the framebuffer
object, or a non-power of two width/height is specified as the
texture size if the texture target is <tt>GL_TEXTURE_2D</tt>. The
non-power of two limitation does not apply if the OpenGL version is
2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension
is present.</p>
<p>The framebuffer can also become invalid if the <a href="qglcontext.html">QGLContext</a> that the framebuffer was created
within is destroyed and there are no other shared contexts that can
take over ownership of the framebuffer.</p>


<h3 class="fn"><a name="metric" />int QGLFramebufferObject.metric (<i>self</i>, <a href="qpaintdevice.html#PaintDeviceMetric-enum">QPaintDevice.PaintDeviceMetric</a>&#160;<i>metric</i>)</h3><p>Reimplemented from <a href="qpaintdevice.html#metric">QPaintDevice.metric</a>().</p>


<h3 class="fn"><a name="paintEngine" /><a href="qpaintengine.html">QPaintEngine</a> QGLFramebufferObject.paintEngine (<i>self</i>)</h3><p>Reimplemented from <a href="qpaintdevice.html#paintEngine">QPaintDevice.paintEngine</a>().</p>


<h3 class="fn"><a name="release" />bool QGLFramebufferObject.release (<i>self</i>)</h3><p>Switches rendering back to the default, windowing system
provided framebuffer. Returns true upon success, false
otherwise.</p>
<p><b>See also</b> <a href="qglframebufferobject.html#bind">bind</a>().</p>


<h3 class="fn"><a name="size" /><a href="qsize.html">QSize</a> QGLFramebufferObject.size (<i>self</i>)</h3><p>Returns the size of the texture attached to this framebuffer
object.</p>


<h3 class="fn"><a name="texture" />int QGLFramebufferObject.texture (<i>self</i>)</h3><p>Returns the texture id for the texture attached as the default
rendering target in this framebuffer object. This texture id can be
bound as a normal texture in your own GL code.</p>
<p>If a multisample framebuffer object is used then the value
returned from this function will be invalid.</p>


<h3 class="fn"><a name="toImage" /><a href="qimage.html">QImage</a> QGLFramebufferObject.toImage (<i>self</i>)</h3><p>Returns the contents of this framebuffer object as a <a href="qimage.html">QImage</a>.</p>
<address><hr /><div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address"><td align="left" width="25%">PyQt&#160;4.10.1 for Windows</td><td align="center" width="50%">Copyright &#169; <a href="http://www.riverbankcomputing.com">Riverbank&#160;Computing&#160;Ltd</a> and <a href="http://www.qtsoftware.com">Nokia</a> 2012</td><td align="right" width="25%">Qt&#160;4.8.4</td></tr></table></div></address></body></html>