<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>module Parslet - parslet-1.5.0 Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="module">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  
<div id="table-of-contents">
  <nav class="section">
    <h3 class="section-header">Table of Contents</h3>
    <ul>
      <li><a href="#label-Further+reading">Further reading</a>
      <li><a href="#label-When+things+go+wrong">When things go wrong</a>
    </ul>
  </nav>
</div>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/parslet.rb
    <li>lib/parslet/atoms.rb
    <li>lib/parslet/atoms/alternative.rb
    <li>lib/parslet/atoms/base.rb
    <li>lib/parslet/atoms/can_flatten.rb
    <li>lib/parslet/atoms/capture.rb
    <li>lib/parslet/atoms/context.rb
    <li>lib/parslet/atoms/dsl.rb
    <li>lib/parslet/atoms/dynamic.rb
    <li>lib/parslet/atoms/entity.rb
    <li>lib/parslet/atoms/lookahead.rb
    <li>lib/parslet/atoms/named.rb
    <li>lib/parslet/atoms/re.rb
    <li>lib/parslet/atoms/repetition.rb
    <li>lib/parslet/atoms/scope.rb
    <li>lib/parslet/atoms/sequence.rb
    <li>lib/parslet/atoms/str.rb
    <li>lib/parslet/atoms/visitor.rb
    <li>lib/parslet/cause.rb
    <li>lib/parslet/convenience.rb
    <li>lib/parslet/error_reporter.rb
    <li>lib/parslet/error_reporter/deepest.rb
    <li>lib/parslet/error_reporter/tree.rb
    <li>lib/parslet/export.rb
    <li>lib/parslet/expression.rb
    <li>lib/parslet/expression/treetop.rb
    <li>lib/parslet/parser.rb
    <li>lib/parslet/pattern.rb
    <li>lib/parslet/pattern/binding.rb
    <li>lib/parslet/scope.rb
    <li>lib/parslet/slice.rb
    <li>lib/parslet/source.rb
    <li>lib/parslet/source/line_cache.rb
    <li>lib/parslet/transform.rb
    <li>lib/parslet/transform/context.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    
    
    <!-- Extension Modules -->
<nav id="extends-section" class="section">
  <h3 class="section-header">Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="Parslet/ClassMethods.html">Parslet::ClassMethods</a>
  
  
  </ul>
</nav>

    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-any">::any</a>
    
    <li ><a href="#method-c-dynamic">::dynamic</a>
    
    <li ><a href="#method-c-exp">::exp</a>
    
    <li ><a href="#method-c-included">::included</a>
    
    <li ><a href="#method-c-match">::match</a>
    
    <li ><a href="#method-c-scope">::scope</a>
    
    <li ><a href="#method-c-sequence">::sequence</a>
    
    <li ><a href="#method-c-simple">::simple</a>
    
    <li ><a href="#method-c-str">::str</a>
    
    <li ><a href="#method-c-subtree">::subtree</a>
    
    <li ><a href="#method-i-any">#any</a>
    
    <li ><a href="#method-i-dynamic">#dynamic</a>
    
    <li ><a href="#method-i-exp">#exp</a>
    
    <li ><a href="#method-i-match">#match</a>
    
    <li ><a href="#method-i-scope">#scope</a>
    
    <li ><a href="#method-i-sequence">#sequence</a>
    
    <li ><a href="#method-i-simple">#simple</a>
    
    <li ><a href="#method-i-str">#str</a>
    
    <li ><a href="#method-i-subtree">#subtree</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./README.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Parslet.html">Parslet</a>
  
    <li><a href="./Parslet/Atoms.html">Parslet::Atoms</a>
  
    <li><a href="./Parslet/Atoms/Alternative.html">Parslet::Atoms::Alternative</a>
  
    <li><a href="./Parslet/Atoms/Base.html">Parslet::Atoms::Base</a>
  
    <li><a href="./Parslet/Atoms/CanFlatten.html">Parslet::Atoms::CanFlatten</a>
  
    <li><a href="./Parslet/Atoms/Capture.html">Parslet::Atoms::Capture</a>
  
    <li><a href="./Parslet/Atoms/Context.html">Parslet::Atoms::Context</a>
  
    <li><a href="./Parslet/Atoms/DSL.html">Parslet::Atoms::DSL</a>
  
    <li><a href="./Parslet/Atoms/Dynamic.html">Parslet::Atoms::Dynamic</a>
  
    <li><a href="./Parslet/Atoms/Entity.html">Parslet::Atoms::Entity</a>
  
    <li><a href="./Parslet/Atoms/Lookahead.html">Parslet::Atoms::Lookahead</a>
  
    <li><a href="./Parslet/Atoms/Named.html">Parslet::Atoms::Named</a>
  
    <li><a href="./Parslet/Atoms/Precedence.html">Parslet::Atoms::Precedence</a>
  
    <li><a href="./Parslet/Atoms/Re.html">Parslet::Atoms::Re</a>
  
    <li><a href="./Parslet/Atoms/Repetition.html">Parslet::Atoms::Repetition</a>
  
    <li><a href="./Parslet/Atoms/Scope.html">Parslet::Atoms::Scope</a>
  
    <li><a href="./Parslet/Atoms/Sequence.html">Parslet::Atoms::Sequence</a>
  
    <li><a href="./Parslet/Atoms/Str.html">Parslet::Atoms::Str</a>
  
    <li><a href="./Parslet/Cause.html">Parslet::Cause</a>
  
    <li><a href="./Parslet/ClassMethods.html">Parslet::ClassMethods</a>
  
    <li><a href="./Parslet/DelayedMatchConstructor.html">Parslet::DelayedMatchConstructor</a>
  
    <li><a href="./Parslet/ErrorReporter.html">Parslet::ErrorReporter</a>
  
    <li><a href="./Parslet/ErrorReporter/Deepest.html">Parslet::ErrorReporter::Deepest</a>
  
    <li><a href="./Parslet/ErrorReporter/Tree.html">Parslet::ErrorReporter::Tree</a>
  
    <li><a href="./Parslet/Expression.html">Parslet::Expression</a>
  
    <li><a href="./Parslet/Expression/Treetop.html">Parslet::Expression::Treetop</a>
  
    <li><a href="./Parslet/Expression/Treetop/Parser.html">Parslet::Expression::Treetop::Parser</a>
  
    <li><a href="./Parslet/Expression/Treetop/Transform.html">Parslet::Expression::Treetop::Transform</a>
  
    <li><a href="./Parslet/ParseFailed.html">Parslet::ParseFailed</a>
  
    <li><a href="./Parslet/Parser.html">Parslet::Parser</a>
  
    <li><a href="./Parslet/Parser/PrettyPrinter.html">Parslet::Parser::PrettyPrinter</a>
  
    <li><a href="./Parslet/Parser/Visitors.html">Parslet::Parser::Visitors</a>
  
    <li><a href="./Parslet/Parser/Visitors/Citrus.html">Parslet::Parser::Visitors::Citrus</a>
  
    <li><a href="./Parslet/Parser/Visitors/Treetop.html">Parslet::Parser::Visitors::Treetop</a>
  
    <li><a href="./Parslet/Pattern.html">Parslet::Pattern</a>
  
    <li><a href="./Parslet/Pattern/SequenceBind.html">Parslet::Pattern::SequenceBind</a>
  
    <li><a href="./Parslet/Pattern/SimpleBind.html">Parslet::Pattern::SimpleBind</a>
  
    <li><a href="./Parslet/Pattern/SubtreeBind.html">Parslet::Pattern::SubtreeBind</a>
  
    <li><a href="./Parslet/Scope.html">Parslet::Scope</a>
  
    <li><a href="./Parslet/Scope/Binding.html">Parslet::Scope::Binding</a>
  
    <li><a href="./Parslet/Scope/NotFound.html">Parslet::Scope::NotFound</a>
  
    <li><a href="./Parslet/Slice.html">Parslet::Slice</a>
  
    <li><a href="./Parslet/Source.html">Parslet::Source</a>
  
    <li><a href="./Parslet/Source/LineCache.html">Parslet::Source::LineCache</a>
  
    <li><a href="./Parslet/Source/RangeSearch.html">Parslet::Source::RangeSearch</a>
  
    <li><a href="./Parslet/Transform.html">Parslet::Transform</a>
  
    <li><a href="./Parslet/Transform/Context.html">Parslet::Transform::Context</a>
  
    <li><a href="./RSpec.html">RSpec</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="module">module Parslet</h1>

  <div id="description" class="description">
    
<p>A simple parser generator library. Typical usage would look like this:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;parslet&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MyParser</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Parser</span>
  <span class="ruby-identifier">rule</span>(:<span class="ruby-identifier">a</span>) { <span class="ruby-identifier">str</span>(<span class="ruby-string">&#39;a&#39;</span>).<span class="ruby-identifier">repeat</span> }
  <span class="ruby-identifier">root</span>(:<span class="ruby-identifier">a</span>)        
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">pp</span> <span class="ruby-constant">MyParser</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;aaaa&#39;</span>)   <span class="ruby-comment"># =&gt; &#39;aaaa&#39;@0</span>
<span class="ruby-identifier">pp</span> <span class="ruby-constant">MyParser</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;bbbb&#39;</span>)   <span class="ruby-comment"># =&gt; Parslet::Atoms::ParseFailed: </span>
                                <span class="ruby-comment">#    Don&#39;t know what to do with bbbb at line 1 char 1.</span>
</pre>

<p>The simple DSL allows you to define grammars in PEG-style. This kind of
grammar construction does away with the ambiguities that usually comes with
parsers; instead, it allows you to construct grammars that are easier to
debug, since less magic is involved.</p>

<p><a href="Parslet.html">Parslet</a> is typically used in stages:</p>
<ul><li>
<p>Parsing the input string; this yields an intermediary tree, see <a
href="Parslet.html#method-i-any">#any</a>, <a
href="Parslet.html#method-i-match">#match</a>, <a
href="Parslet.html#method-i-str">#str</a>, <a
href="Parslet/ClassMethods.html#method-i-rule">Parslet::ClassMethods#rule</a>
and Parslet::ClassMethods#root.</p>
</li><li>
<p>Transformation of the tree into something useful to you, see <a
href="Parslet/Transform.html">Parslet::Transform</a>, <a
href="Parslet.html#method-i-simple">#simple</a>, <a
href="Parslet.html#method-i-sequence">#sequence</a> and <a
href="Parslet.html#method-i-subtree">#subtree</a>.</p>
</li></ul>

<p>The first stage is traditionally intermingled with the second stage; output
from the second stage is usually called the &#39;Abstract Syntax Tree&#39;
or AST.</p>

<p>The stages are completely decoupled; You can change your grammar around and
use the second stage to isolate the rest of your code from the changes
you&#39;ve effected.</p>

<h2 id="label-Further+reading">Further reading<span><a href="#label-Further+reading">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>All parslet atoms are subclasses of {Parslet::Atoms::Base}. You might want
to look at all of those: {Parslet::Atoms::Re}, {Parslet::Atoms::Str},
{Parslet::Atoms::Repetition}, {Parslet::Atoms::Sequence},
{Parslet::Atoms::Alternative}.</p>

<h2 id="label-When+things+go+wrong">When things go wrong<span><a href="#label-When+things+go+wrong">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>A parse that fails will raise {Parslet::ParseFailed}. This exception
contains all the details of what went wrong, including a detailed error
trace that  can be printed out as an ascii tree. ({Parslet::Cause})</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-any" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">any</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching any character. It acts like the &#39;.&#39; (dot)
character in regular expressions.</p>

<pre class="ruby"><span class="ruby-identifier">any</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;a&#39;</span>)    <span class="ruby-comment"># =&gt; &#39;a&#39;</span>
</pre>

<p>@return [Parslet::Atoms::Re] a parslet atom</p>
          
          

          
          <div class="method-source-code" id="any-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">any</span>
  <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;.&#39;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- any-source -->
          
        </div>

        

        
      </div><!-- any-method -->

    
      <div id="method-c-dynamic" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dynamic</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Designates a piece of the parser as being dynamic. Dynamic parsers can
either return a parser at runtime, which will be applied on the input, or
return a result from a parse.</p>

<p>Dynamic parse pieces are never cached and can introduce performance
abnormalitites - use sparingly where other constructs fail.</p>

<p>Example:</p>

<pre># Parses either &#39;a&#39; or &#39;b&#39;, depending on the weather
dynamic { rand() &lt; 0.5 ? str(&#39;a&#39;) : str(&#39;b&#39;) }</pre>
          
          

          
          <div class="method-source-code" id="dynamic-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dynamic</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Dynamic</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- dynamic-source -->
          
        </div>

        

        
      </div><!-- dynamic-method -->

    
      <div id="method-c-exp" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exp</span><span
            class="method-args">(str)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>A special kind of atom that allows embedding whole treetop expressions into
parslet construction.</p>

<pre># the same as str(&#39;a&#39;) &gt;&gt; str(&#39;b&#39;).maybe
exp(%Q(&quot;a&quot; &quot;b&quot;?))</pre>

<p>@param str [String] a treetop expression @return [Parslet::Atoms::Base] the
corresponding parslet parser</p>
          
          

          
          <div class="method-source-code" id="exp-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exp</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>).<span class="ruby-identifier">to_parslet</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- exp-source -->
          
        </div>

        

        
      </div><!-- exp-method -->

    
      <div id="method-c-included" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">included</span><span
            class="method-args">(base)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Extends classes that include <a href="Parslet.html">Parslet</a> with the
module {Parslet::ClassMethods}.</p>
          
          

          
          <div class="method-source-code" id="included-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 52</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">included</span>(<span class="ruby-identifier">base</span>)
  <span class="ruby-identifier">base</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">ClassMethods</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- included-source -->
          
        </div>

        

        
      </div><!-- included-method -->

    
      <div id="method-c-match" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">match</span><span
            class="method-args">(str=nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching a character class. All regular expressions can be
used, as long as they match only a single character at a time.</p>

<pre>match(&#39;[ab]&#39;)     # will match either &#39;a&#39; or &#39;b&#39;
match(&#39;[\n\s]&#39;)   # will match newlines and spaces</pre>

<p>There is also another (convenience) form of this method:</p>

<pre>match[&#39;a-z&#39;]      # synonymous to match(&#39;[a-z]&#39;)
match[&#39;\n&#39;]       # synonymous to match(&#39;[\n]&#39;)</pre>

<p>@overload match(str)</p>

<pre class="ruby"><span class="ruby-ivar">@param</span> <span class="ruby-identifier">str</span> [<span class="ruby-constant">String</span>] <span class="ruby-identifier">character</span> <span class="ruby-keyword">class</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">match</span> (<span class="ruby-identifier">regexp</span> <span class="ruby-identifier">syntax</span>)
<span class="ruby-ivar">@return</span> [<span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>] <span class="ruby-identifier">a</span> <span class="ruby-identifier">parslet</span> <span class="ruby-identifier">atom</span>
</pre>
          
          

          
          <div class="method-source-code" id="match-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">match</span>(<span class="ruby-identifier">str</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">DelayedMatchConstructor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">str</span>
  
  <span class="ruby-keyword">return</span> <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- match-source -->
          
        </div>

        

        
      </div><!-- match-method -->

    
      <div id="method-c-scope" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">scope</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Introduces a new capture scope. This means that all old captures stay
accessible, but new values stored will only be available during the block
given and the old values will be restored after the block.</p>

<p>Example:</p>

<pre># :a will be available until the end of the block. Afterwards, 
# :a from the outer scope will be available again, if such a thing 
# exists. 
scope { str(&#39;a&#39;).capture(:a) }</pre>
          
          

          
          <div class="method-source-code" id="scope-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">scope</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Scope</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- scope-source -->
          
        </div>

        

        
      </div><!-- scope-method -->

    
      <div id="method-c-sequence" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sequence</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for a tree transformation that will only match a
sequence of elements. The <code>symbol</code> you specify will be the key
for the matched sequence in the returned dictionary.</p>

<pre class="ruby"><span class="ruby-comment"># This would match a body element that contains several declarations.</span>
{ :<span class="ruby-identifier">body</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sequence</span>(:<span class="ruby-identifier">declarations</span>) }
</pre>

<p>The above example would match <code>:body =&gt; [&#39;a&#39;,
&#39;b&#39;]</code>, but not <code>:body =&gt; &#39;a&#39;</code>.</p>

<p>see {Parslet::Transform}</p>
          
          

          
          <div class="method-source-code" id="sequence-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sequence</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SequenceBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- sequence-source -->
          
        </div>

        

        
      </div><!-- sequence-method -->

    
      <div id="method-c-simple" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">simple</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for a tree transformation that will only match simple
elements. This matches everything that <code>#sequence</code> doesn&#39;t
match.</p>

<pre class="ruby"><span class="ruby-comment"># Matches a single header. </span>
{ :<span class="ruby-identifier">header</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">simple</span>(:<span class="ruby-identifier">header</span>) }
</pre>

<p>see {Parslet::Transform}</p>
          
          

          
          <div class="method-source-code" id="simple-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">simple</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- simple-source -->
          
        </div>

        

        
      </div><!-- simple-method -->

    
      <div id="method-c-str" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">str</span><span
            class="method-args">(str)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching the <code>str</code> given:</p>

<pre>str(&#39;class&#39;)      # will match &#39;class&#39;</pre>

<p>@param str [String] string to match verbatim @return [Parslet::Atoms::Str]
a parslet atom</p>
          
          

          
          <div class="method-source-code" id="str-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">str</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Str</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- str-source -->
          
        </div>

        

        
      </div><!-- str-method -->

    
      <div id="method-c-subtree" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">subtree</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for tree transformation patterns that will match  any
kind of subtree.</p>

<pre class="ruby">{ :<span class="ruby-identifier">expression</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">subtree</span>(:<span class="ruby-identifier">exp</span>) }
</pre>
          
          

          
          <div class="method-source-code" id="subtree-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">subtree</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SubtreeBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- subtree-source -->
          
        </div>

        

        
      </div><!-- subtree-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="private-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Private Instance Methods</h3>

    
      <div id="method-i-any" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">any</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching any character. It acts like the &#39;.&#39; (dot)
character in regular expressions.</p>

<pre class="ruby"><span class="ruby-identifier">any</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;a&#39;</span>)    <span class="ruby-comment"># =&gt; &#39;a&#39;</span>
</pre>

<p>@return [Parslet::Atoms::Re] a parslet atom</p>
          
          

          
          <div class="method-source-code" id="any-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">any</span>
  <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;.&#39;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- any-source -->
          
        </div>

        

        
      </div><!-- any-method -->

    
      <div id="method-i-dynamic" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dynamic</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Designates a piece of the parser as being dynamic. Dynamic parsers can
either return a parser at runtime, which will be applied on the input, or
return a result from a parse.</p>

<p>Dynamic parse pieces are never cached and can introduce performance
abnormalitites - use sparingly where other constructs fail.</p>

<p>Example:</p>

<pre># Parses either &#39;a&#39; or &#39;b&#39;, depending on the weather
dynamic { rand() &lt; 0.5 ? str(&#39;a&#39;) : str(&#39;b&#39;) }</pre>
          
          

          
          <div class="method-source-code" id="dynamic-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dynamic</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Dynamic</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- dynamic-source -->
          
        </div>

        

        
      </div><!-- dynamic-method -->

    
      <div id="method-i-exp" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exp</span><span
            class="method-args">(str)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>A special kind of atom that allows embedding whole treetop expressions into
parslet construction.</p>

<pre># the same as str(&#39;a&#39;) &gt;&gt; str(&#39;b&#39;).maybe
exp(%Q(&quot;a&quot; &quot;b&quot;?))</pre>

<p>@param str [String] a treetop expression @return [Parslet::Atoms::Base] the
corresponding parslet parser</p>
          
          

          
          <div class="method-source-code" id="exp-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exp</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>).<span class="ruby-identifier">to_parslet</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- exp-source -->
          
        </div>

        

        
      </div><!-- exp-method -->

    
      <div id="method-i-match" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">match</span><span
            class="method-args">(str=nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching a character class. All regular expressions can be
used, as long as they match only a single character at a time.</p>

<pre>match(&#39;[ab]&#39;)     # will match either &#39;a&#39; or &#39;b&#39;
match(&#39;[\n\s]&#39;)   # will match newlines and spaces</pre>

<p>There is also another (convenience) form of this method:</p>

<pre>match[&#39;a-z&#39;]      # synonymous to match(&#39;[a-z]&#39;)
match[&#39;\n&#39;]       # synonymous to match(&#39;[\n]&#39;)</pre>

<p>@overload match(str)</p>

<pre class="ruby"><span class="ruby-ivar">@param</span> <span class="ruby-identifier">str</span> [<span class="ruby-constant">String</span>] <span class="ruby-identifier">character</span> <span class="ruby-keyword">class</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">match</span> (<span class="ruby-identifier">regexp</span> <span class="ruby-identifier">syntax</span>)
<span class="ruby-ivar">@return</span> [<span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>] <span class="ruby-identifier">a</span> <span class="ruby-identifier">parslet</span> <span class="ruby-identifier">atom</span>
</pre>
          
          

          
          <div class="method-source-code" id="match-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">match</span>(<span class="ruby-identifier">str</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">DelayedMatchConstructor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">str</span>
  
  <span class="ruby-keyword">return</span> <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Re</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- match-source -->
          
        </div>

        

        
      </div><!-- match-method -->

    
      <div id="method-i-scope" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">scope</span><span
            class="method-args">(&block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Introduces a new capture scope. This means that all old captures stay
accessible, but new values stored will only be available during the block
given and the old values will be restored after the block.</p>

<p>Example:</p>

<pre># :a will be available until the end of the block. Afterwards, 
# :a from the outer scope will be available again, if such a thing 
# exists. 
scope { str(&#39;a&#39;).capture(:a) }</pre>
          
          

          
          <div class="method-source-code" id="scope-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">scope</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Parslet</span><span class="ruby-operator">::</span><span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Scope</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- scope-source -->
          
        </div>

        

        
      </div><!-- scope-method -->

    
      <div id="method-i-sequence" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sequence</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for a tree transformation that will only match a
sequence of elements. The <code>symbol</code> you specify will be the key
for the matched sequence in the returned dictionary.</p>

<pre class="ruby"><span class="ruby-comment"># This would match a body element that contains several declarations.</span>
{ :<span class="ruby-identifier">body</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sequence</span>(:<span class="ruby-identifier">declarations</span>) }
</pre>

<p>The above example would match <code>:body =&gt; [&#39;a&#39;,
&#39;b&#39;]</code>, but not <code>:body =&gt; &#39;a&#39;</code>.</p>

<p>see {Parslet::Transform}</p>
          
          

          
          <div class="method-source-code" id="sequence-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sequence</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SequenceBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- sequence-source -->
          
        </div>

        

        
      </div><!-- sequence-method -->

    
      <div id="method-i-simple" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">simple</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for a tree transformation that will only match simple
elements. This matches everything that <code>#sequence</code> doesn&#39;t
match.</p>

<pre class="ruby"><span class="ruby-comment"># Matches a single header. </span>
{ :<span class="ruby-identifier">header</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">simple</span>(:<span class="ruby-identifier">header</span>) }
</pre>

<p>see {Parslet::Transform}</p>
          
          

          
          <div class="method-source-code" id="simple-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">simple</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- simple-source -->
          
        </div>

        

        
      </div><!-- simple-method -->

    
      <div id="method-i-str" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">str</span><span
            class="method-args">(str)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an atom matching the <code>str</code> given:</p>

<pre>str(&#39;class&#39;)      # will match &#39;class&#39;</pre>

<p>@param str [String] string to match verbatim @return [Parslet::Atoms::Str]
a parslet atom</p>
          
          

          
          <div class="method-source-code" id="str-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">str</span>(<span class="ruby-identifier">str</span>)
  <span class="ruby-constant">Atoms</span><span class="ruby-operator">::</span><span class="ruby-constant">Str</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">str</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- str-source -->
          
        </div>

        

        
      </div><!-- str-method -->

    
      <div id="method-i-subtree" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">subtree</span><span
            class="method-args">(symbol)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a placeholder for tree transformation patterns that will match  any
kind of subtree.</p>

<pre class="ruby">{ :<span class="ruby-identifier">expression</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">subtree</span>(:<span class="ruby-identifier">exp</span>) }
</pre>
          
          

          
          <div class="method-source-code" id="subtree-source">
            <pre><span class="ruby-comment"># File lib/parslet.rb, line 253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">subtree</span>(<span class="ruby-identifier">symbol</span>)
  <span class="ruby-constant">Pattern</span><span class="ruby-operator">::</span><span class="ruby-constant">SubtreeBind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">symbol</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- subtree-source -->
          
        </div>

        

        
      </div><!-- subtree-method -->

    
    </section><!-- private-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

