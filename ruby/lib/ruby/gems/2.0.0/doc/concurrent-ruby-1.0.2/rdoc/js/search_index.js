var search_data = {"index":{"searchIndex":["concurrent","abstractexchanger","abstractexecutorservice","abstractthreadlocalvar","agent","error","validationerror","array","async","asyncdelegator","awaitdelegator","classmethods","atexitimplementation","atom","atomicboolean","atomicdirectupdate","atomicfixnum","atomicnumericcompareandsetwrapper","atomicreference","catomicreference","cachedthreadpool","collection","atomicreferencemapbackend","node","table","copyonnotifyobserverset","copyonwriteobserverset","javanonconcurrentpriorityqueue","mrimapbackend","nonconcurrentmapbackend","nonconcurrentpriorityqueue","rubynonconcurrentpriorityqueue","synchronizedmapbackend","concern","deprecation","dereferenceable","logging","obligation","observable","concurrentupdateerror","countdownlatch","cyclicbarrier","delay","dependencycounter","edge","event","exchanger","executorservice","fixedthreadpool","future","hash","ivar","immediateexecutor","immutablestruct","indirectimmediateexecutor","javaatomicreference","javacountdownlatch","javaexchanger","javaexecutorservice","job","javasinglethreadexecutor","javathreadlocalvar","javathreadpoolexecutor","lazyregister","mvar","map","maybe","mutablestruct","mutexatomicboolean","mutexatomicfixnum","mutexatomicreference","mutexcountdownlatch","mutexsemaphore","options","process","promise","rbxatomicreference","readwritelock","reentrantreadwritelock","rubyexchanger","node","rubyexecutorservice","rubysinglethreadexecutor","rubythreadlocalvar","rubythreadpoolexecutor","worker","safetaskexecutor","scheduledtask","semaphore","serialexecutorservice","serializedexecution","serializedexecutiondelegator","settablestruct","simpleexecutorservice","singlethreadexecutor","synchronization","abstractlockableobject","abstractobject","abstractstruct","condition","jrubyattrvolatile","classmethods","jrubylockableobject","jrubyobject","lock","lockableobject","mriattrvolatile","classmethods","mrilockableobject","mrimonitorlockableobject","mrimutexlockableobject","mriobject","object","rbxattrvolatile","classmethods","rbxlockableobject","rbxobject","truffleattrvolatile","classmethods","trufflelockableobject","truffleobject","synchronizeddelegator","tvar","threadlocalvar","threadpoolexecutor","threadsafe","util","adder","cheaplockable","poweroftwotuple","striped64","cell","volatile","xorshiftrandom","timerset","timertask","transaction","tuple","utility","enginedetector","nativeextensionloader","processorcounter","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<=>()","<=>()","==()","==()","==()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","[]=()","[]=()","_compare_and_set()","_get()","_mon_initialize()","_set()","abort()","abort_transaction()","abort_transaction()","acquire()","acquire_read_lock()","acquire_read_lock()","acquire_write_lock()","acquire_write_lock()","add()","add()","add()","add_observer()","add_observer()","add_observer()","add_observer()","aggregate()","all?()","allocate()","allocate_storage()","allocate_storage()","allocate_storage()","allow_c_extensions?()","any?()","apply_deref_options()","async()","atomically()","atomically()","attempt_compute()","attempt_get_and_set()","attempt_internal_compute_if_absent()","attempt_internal_replace()","attr_atomic()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","attr_volatile()","auto_terminate=()","auto_terminate?()","available_permits()","await()","await()","await()","await_for()","await_for()","await_for!()","await_for!()","bind()","bind()","bind()","borrow()","broadcast()","broadcast()","broken?()","c_extensions_loaded?()","call()","call_dataflow()","call_dataflow()","call_job()","can_overflow?()","can_overflow?()","can_overflow?()","cancel()","cancel()","cancelled?()","cancelled?()","cas()","cas_base_computed()","cas_computed()","cas_new_node()","cast()","catch()","cheap_broadcast()","cheap_synchronize()","cheap_wait()","check_for_resize()","clear()","clear()","clear()","clear()","clear()","clear()","clear_observers_and_return_old()","commit()","compare_and_set()","compare_and_set()","compare_and_set()","compare_and_set()","compare_and_set_state()","compare_and_swap()","complete()","complete()","complete?()","complete_without_notification()","completed_task_count()","completed_task_count()","compute()","compute()","compute()","compute()","compute_if_absent()","compute_if_absent()","compute_if_absent()","compute_if_absent()","compute_if_present()","compute_if_present()","compute_if_present()","compute_if_present()","compute_physical_processor_count()","compute_processor_count()","count()","count()","count_down()","count_down()","count_observers()","count_observers()","count_observers()","create_stdlib_logger()","create_worker()","current()","current=()","dataflow()","dataflow()","dataflow!()","dataflow!()","dataflow_with()","dataflow_with()","dataflow_with!()","dataflow_with!()","decrement()","decrement()","decrement_size()","define_initialize_volatile_with_cas()","define_struct_class()","delete()","delete()","delete()","delete()","delete()","delete()","delete()","delete()","delete_node_at()","delete_observer()","delete_observer()","delete_observer()","delete_observers()","delete_observers()","delete_observers()","delete_pair()","delete_pair()","delete_pair()","delete_pair()","deprecated()","deprecated_method()","deq()","deq()","deref()","deref()","disable_at_exit_handlers!()","do_exchange()","do_exchange()","do_exchange()","down()","drain_permits()","duplicate_and_clear_observers()","duplicate_observers()","dupped_backend()","dupped_backend()","each()","each()","each()","each()","each_key()","each_pair()","each_pair()","each_pair()","each_pair()","each_pair()","each_value()","empty?()","empty?()","empty?()","empty?()","empty?()","enabled=()","enabled?()","enq()","enq()","enqueue_action_job()","enqueue_await_job()","ensure_safe_initialization_when_final_fields_are_present()","error()","event()","exception()","exchange()","exchange!()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute()","execute_next_job()","execute_task()","execution_interval()","execution_interval=()","executor()","executor()","expand_table_unless_stale()","fail()","fail()","failed?()","false?()","fetch()","fetch_or_store()","find_value_in_node_list()","flat_map()","force_aquire_lock()","free?()","from()","from_list()","from_list()","fulfill()","fulfilled?()","fulfilled?()","full?()","full_memory_barrier()","full_memory_barrier()","full_memory_barrier()","full_memory_barrier()","get()","get()","get()","get()","get_and_set()","get_and_set()","get_and_set()","get_and_set()","get_and_set()","get_arguments_from()","get_or_default()","get_or_default()","get_or_default()","get_threadlocal_array()","get_time()","global_fast_executor()","global_immediate_executor()","global_io_executor()","global_logger()","global_logger=()","global_timer_set()","handle_error()","handle_fallback()","handler?()","handlers()","has_key?()","has_priority?()","has_priority?()","has_waiters?()","hash_code()","hash_code=()","hash_to_index()","idletime()","if_state()","include?()","include?()","included()","included()","included()","included()","included()","included()","incomplete?()","increment()","increment()","increment_size()","index()","init_obligation()","init_synchronization()","initial_delay()","initialize_copy()","initialize_copy()","initialize_copy()","initialize_table()","initialize_volatile_with_cas()","inspect()","inspect()","inspect()","inspect()","install()","internal_compute()","internal_replace()","internal_reset()","item()","java_extensions_loaded?()","just()","just?()","key()","key?()","key?()","key?()","key?()","key?()","key_hash()","keys()","kill()","kill()","kill()","kill()","kill()","kill()","kill()","largest_length()","largest_length()","latch()","leave_transaction()","leave_transaction()","length()","length()","length()","length()","length()","load_native_extensions()","lock_and_clean_up_reverse_forwarders()","locked?()","locked_hash?()","log()","make_false()","make_synchronized_on_rbx()","make_true()","marshal_dump()","marshal_load()","matches?()","max_readers?()","max_readers?()","max_writers?()","max_writers?()","members()","merge()","merge()","merge()","merge_pair()","merge_pair()","merge_pair()","merge_pair()","method_missing()","method_missing()","method_missing()","min_length()","modify()","modify!()","monotonic_time()","monotonic_time()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_condition()","new_fast_executor()","new_io_executor()","next_in_size_table()","no_error!()","nothing()","nothing?()","notify_and_delete_observers()","notify_and_delete_observers()","notify_child()","notify_observers()","notify_observers()","notify_observers()","notify_to()","notify_to()","ns_add_busy_worker()","ns_assign_worker()","ns_auto_terminate=()","ns_auto_terminate?()","ns_broadcast()","ns_broadcast()","ns_broadcast()","ns_broadcast()","ns_check_state?()","ns_complete_without_notification()","ns_each()","ns_each_pair()","ns_enqueue()","ns_enqueue_job()","ns_equality()","ns_execute()","ns_execute()","ns_find_last_job_for_thread()","ns_generation_done()","ns_get()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_initialize()","ns_inspect()","ns_kill_execution()","ns_kill_execution()","ns_kill_execution()","ns_limited_queue?()","ns_make_executor_runnable()","ns_make_value()","ns_merge()","ns_next_generation()","ns_post_next_job()","ns_post_task()","ns_prune_pool()","ns_ready_worker()","ns_remove_busy_worker()","ns_reschedule()","ns_reset_if_forked()","ns_running?()","ns_running?()","ns_schedule()","ns_select()","ns_set()","ns_set()","ns_set_deref_options()","ns_set_state()","ns_shutdown?()","ns_shutdown?()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shutdown_execution()","ns_shuttingdown?()","ns_shuttingdown?()","ns_signal()","ns_signal()","ns_signal()","ns_signal()","ns_to_h()","ns_validate()","ns_values()","ns_values_at()","ns_wait()","ns_wait()","ns_wait()","ns_wait()","ns_wait()","ns_wait_until()","ns_wait_until()","ns_worker_died()","ns_worker_not_old_enough()","number_waiting()","observers()","observers=()","on_cruby?()","on_error()","on_fulfill()","on_jruby?()","on_jruby_9000?()","on_linux?()","on_osx?()","on_rbx?()","on_reject()","on_success()","on_truffle?()","on_windows?()","or()","ordered?()","pair?()","parties()","peek()","peek()","pending?()","perform()","physical_processor_count()","physical_processor_count()","pop()","pop()","populate_from()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post()","post_task()","posts()","pr_underscore()","process_task()","process_tasks()","processing?()","processor_count()","processor_count()","pure_hash()","push()","push()","put()","put_if_absent()","queue_length()","queue_length()","raise_fetch_no_key()","range_check!()","read()","ready_worker()","realize()","realized?()","reason()","reason()","rebuild()","reconfigure()","reduce_permits()","register()","registered?()","reject()","rejected?()","rejected?()","release()","release_read_lock()","release_read_lock()","release_write_lock()","release_write_lock()","remaining_capacity()","remaining_capacity()","remove()","remove_busy_worker()","remove_task()","replace_if_exists()","replace_if_exists()","replace_if_exists()","replace_if_exists()","replace_pair()","replace_pair()","replace_pair()","replace_pair()","reschedule()","rescue()","reset()","reset()","reset()","reset()","reset()","restart()","retry_update()","ruby_engine()","ruby_version()","run()","run()","run_task()","runner()","running?()","running?()","running?()","running?()","running?()","running_readers()","running_readers()","running_readers?()","running_readers?()","running_writer?()","running_writer?()","safe_execute()","safe_initialization!()","safe_initialization?()","schedule_next_task()","schedule_time()","scheduled_task_count()","scheduled_task_count()","select()","select()","select()","send()","send!()","send_off()","send_off!()","send_via()","send_via!()","serialized?()","serialized?()","set()","set()","set()","set()","set()","set()","set!()","set?()","set_c_extensions_loaded()","set_deref_options()","set_java_extensions_loaded()","set_pending()","set_state()","set_state!()","set_threadlocal_array()","setup()","shift()","shift()","shutdown()","shutdown()","shutdown()","shutdown()","shutdown()","shutdown?()","shutdown?()","shutdown?()","shuttingdown?()","shuttingdown?()","shuttingdown?()","signal()","signal()","sink()","size()","size()","size()","size()","size()","size()","size()","split_bin()","split_old_bin()","state()","state=()","stop()","stop_event()","stopped?()","stopped_event()","store()","store_computed_value()","sum()","swap()","swap()","swap()","swim()","synchronize()","synchronize()","synchronize()","synchronize()","synchronize()","synchronized_set_state!()","table_size_for()","take()","teardown()","terminate_at_exit()","then()","thread_finalizer()","threadlocal_finalizer()","timeout_interval()","timeout_interval=()","timeout_task()","to_a()","to_a()","to_a()","to_h()","to_h()","to_h()","to_s()","to_s()","to_s()","true?()","try?()","try_acquire()","try_acquire_now()","try_acquire_timed()","try_await_lock()","try_await_lock()","try_exchange()","try_in_busy()","try_in_resize_lock()","try_initialize_cells()","try_lock_via_hash()","try_lock_via_hash()","try_put!()","try_read_lock()","try_set()","try_take!()","try_to_cas_in_computed()","try_to_install_new_cell()","try_update()","try_update!()","try_write_lock()","unlock()","unlock_via_hash()","unlocked_empty?()","unlocked_full?()","unregister()","unscheduled?()","up()","update()","update()","use_stdlib_logger()","valid?()","valid?()","validate_argc()","validate_options_hash!()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value()","value!()","value!()","value=()","value=()","value=()","value=()","value=()","value=()","value=()","value=()","value?()","value_for()","values()","values()","values()","values()","values_at()","values_at()","values_at()","volatile_cas_fields()","volatile_get()","volatile_get_by_hash()","volatile_set()","volatile_set_by_hash()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait()","wait!()","wait_for_empty()","wait_for_full()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_for_termination()","wait_or_cancel()","wait_until()","wait_until()","wait_while()","waiting_or_running_writer?()","waiting_writer?()","waiting_writers()","waiting_writers()","with_observer()","with_read_lock()","with_read_lock()","with_write_lock()","with_write_lock()","work()","worker_died()","worker_not_old_enough()","worker_task_completed()","write()","write_locked?()","xorshift()","zip()","zip()","changelog","license","readme"],"longSearchIndex":["concurrent","concurrent::abstractexchanger","concurrent::abstractexecutorservice","concurrent::abstractthreadlocalvar","concurrent::agent","concurrent::agent::error","concurrent::agent::validationerror","concurrent::array","concurrent::async","concurrent::async::asyncdelegator","concurrent::async::awaitdelegator","concurrent::async::classmethods","concurrent::atexitimplementation","concurrent::atom","concurrent::atomicboolean","concurrent::atomicdirectupdate","concurrent::atomicfixnum","concurrent::atomicnumericcompareandsetwrapper","concurrent::atomicreference","concurrent::catomicreference","concurrent::cachedthreadpool","concurrent::collection","concurrent::collection::atomicreferencemapbackend","concurrent::collection::atomicreferencemapbackend::node","concurrent::collection::atomicreferencemapbackend::table","concurrent::collection::copyonnotifyobserverset","concurrent::collection::copyonwriteobserverset","concurrent::collection::javanonconcurrentpriorityqueue","concurrent::collection::mrimapbackend","concurrent::collection::nonconcurrentmapbackend","concurrent::collection::nonconcurrentpriorityqueue","concurrent::collection::rubynonconcurrentpriorityqueue","concurrent::collection::synchronizedmapbackend","concurrent::concern","concurrent::concern::deprecation","concurrent::concern::dereferenceable","concurrent::concern::logging","concurrent::concern::obligation","concurrent::concern::observable","concurrent::concurrentupdateerror","concurrent::countdownlatch","concurrent::cyclicbarrier","concurrent::delay","concurrent::dependencycounter","concurrent::edge","concurrent::event","concurrent::exchanger","concurrent::executorservice","concurrent::fixedthreadpool","concurrent::future","concurrent::hash","concurrent::ivar","concurrent::immediateexecutor","concurrent::immutablestruct","concurrent::indirectimmediateexecutor","concurrent::javaatomicreference","concurrent::javacountdownlatch","concurrent::javaexchanger","concurrent::javaexecutorservice","concurrent::javaexecutorservice::job","concurrent::javasinglethreadexecutor","concurrent::javathreadlocalvar","concurrent::javathreadpoolexecutor","concurrent::lazyregister","concurrent::mvar","concurrent::map","concurrent::maybe","concurrent::mutablestruct","concurrent::mutexatomicboolean","concurrent::mutexatomicfixnum","concurrent::mutexatomicreference","concurrent::mutexcountdownlatch","concurrent::mutexsemaphore","concurrent::options","concurrent::process","concurrent::promise","concurrent::rbxatomicreference","concurrent::readwritelock","concurrent::reentrantreadwritelock","concurrent::rubyexchanger","concurrent::rubyexchanger::node","concurrent::rubyexecutorservice","concurrent::rubysinglethreadexecutor","concurrent::rubythreadlocalvar","concurrent::rubythreadpoolexecutor","concurrent::rubythreadpoolexecutor::worker","concurrent::safetaskexecutor","concurrent::scheduledtask","concurrent::semaphore","concurrent::serialexecutorservice","concurrent::serializedexecution","concurrent::serializedexecutiondelegator","concurrent::settablestruct","concurrent::simpleexecutorservice","concurrent::singlethreadexecutor","concurrent::synchronization","concurrent::synchronization::abstractlockableobject","concurrent::synchronization::abstractobject","concurrent::synchronization::abstractstruct","concurrent::synchronization::condition","concurrent::synchronization::jrubyattrvolatile","concurrent::synchronization::jrubyattrvolatile::classmethods","concurrent::synchronization::jrubylockableobject","concurrent::synchronization::jrubyobject","concurrent::synchronization::lock","concurrent::synchronization::lockableobject","concurrent::synchronization::mriattrvolatile","concurrent::synchronization::mriattrvolatile::classmethods","concurrent::synchronization::mrilockableobject","concurrent::synchronization::mrimonitorlockableobject","concurrent::synchronization::mrimutexlockableobject","concurrent::synchronization::mriobject","concurrent::synchronization::object","concurrent::synchronization::rbxattrvolatile","concurrent::synchronization::rbxattrvolatile::classmethods","concurrent::synchronization::rbxlockableobject","concurrent::synchronization::rbxobject","concurrent::synchronization::truffleattrvolatile","concurrent::synchronization::truffleattrvolatile::classmethods","concurrent::synchronization::trufflelockableobject","concurrent::synchronization::truffleobject","concurrent::synchronizeddelegator","concurrent::tvar","concurrent::threadlocalvar","concurrent::threadpoolexecutor","concurrent::threadsafe","concurrent::threadsafe::util","concurrent::threadsafe::util::adder","concurrent::threadsafe::util::cheaplockable","concurrent::threadsafe::util::poweroftwotuple","concurrent::threadsafe::util::striped64","concurrent::threadsafe::util::striped64::cell","concurrent::threadsafe::util::volatile","concurrent::threadsafe::util::xorshiftrandom","concurrent::timerset","concurrent::timertask","concurrent::transaction","concurrent::tuple","concurrent::utility","concurrent::utility::enginedetector","concurrent::utility::nativeextensionloader","concurrent::utility::processorcounter","concurrent::agent#<<()","concurrent::collection::javanonconcurrentpriorityqueue#<<()","concurrent::collection::rubynonconcurrentpriorityqueue#<<()","concurrent::executorservice#<<()","concurrent::immediateexecutor#<<()","concurrent::rubythreadpoolexecutor::worker#<<()","concurrent::simpleexecutorservice#<<()","concurrent::simpleexecutorservice::<<()","concurrent::maybe#<=>()","concurrent::scheduledtask#<=>()","concurrent::immutablestruct#==()","concurrent::mutablestruct#==()","concurrent::settablestruct#==()","concurrent::collection::atomicreferencemapbackend#[]()","concurrent::collection::nonconcurrentmapbackend#[]()","concurrent::collection::synchronizedmapbackend#[]()","concurrent::immutablestruct#[]()","concurrent::lazyregister#[]()","concurrent::map#[]()","concurrent::mutablestruct#[]()","concurrent::settablestruct#[]()","concurrent::collection::atomicreferencemapbackend#[]=()","concurrent::collection::mrimapbackend#[]=()","concurrent::collection::nonconcurrentmapbackend#[]=()","concurrent::collection::synchronizedmapbackend#[]=()","concurrent::mutablestruct#[]=()","concurrent::settablestruct#[]=()","concurrent::mutexatomicreference#_compare_and_set()","concurrent::collection::nonconcurrentmapbackend#_get()","concurrent::threadsafe::util#_mon_initialize()","concurrent::collection::nonconcurrentmapbackend#_set()","concurrent::transaction#abort()","concurrent::abort_transaction()","concurrent#abort_transaction()","concurrent::mutexsemaphore#acquire()","concurrent::readwritelock#acquire_read_lock()","concurrent::reentrantreadwritelock#acquire_read_lock()","concurrent::readwritelock#acquire_write_lock()","concurrent::reentrantreadwritelock#acquire_write_lock()","concurrent::atexitimplementation#add()","concurrent::lazyregister#add()","concurrent::threadsafe::util::adder#add()","concurrent::collection::copyonnotifyobserverset#add_observer()","concurrent::collection::copyonwriteobserverset#add_observer()","concurrent::concern::observable#add_observer()","concurrent::ivar#add_observer()","concurrent::promise::aggregate()","concurrent::promise::all?()","concurrent::threadsafe::util::allocate()","concurrent::abstractthreadlocalvar#allocate_storage()","concurrent::javathreadlocalvar#allocate_storage()","concurrent::rubythreadlocalvar#allocate_storage()","concurrent::utility::nativeextensionloader#allow_c_extensions?()","concurrent::promise::any?()","concurrent::concern::dereferenceable#apply_deref_options()","concurrent::async#async()","concurrent#atomically()","concurrent::atomically()","concurrent::collection::atomicreferencemapbackend#attempt_compute()","concurrent::collection::atomicreferencemapbackend#attempt_get_and_set()","concurrent::collection::atomicreferencemapbackend#attempt_internal_compute_if_absent()","concurrent::collection::atomicreferencemapbackend#attempt_internal_replace()","concurrent::synchronization::object::attr_atomic()","concurrent::synchronization::abstractobject::attr_volatile()","concurrent::synchronization::jrubyattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::mriattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::rbxattrvolatile::classmethods#attr_volatile()","concurrent::synchronization::truffleattrvolatile::classmethods#attr_volatile()","concurrent::threadsafe::util::volatile#attr_volatile()","concurrent::abstractexecutorservice#auto_terminate=()","concurrent::abstractexecutorservice#auto_terminate?()","concurrent::mutexsemaphore#available_permits()","concurrent::agent#await()","concurrent::agent::await()","concurrent::async#await()","concurrent::agent::await_for()","concurrent::agent#await_for()","concurrent::agent::await_for!()","concurrent::agent#await_for!()","concurrent::abstractthreadlocalvar#bind()","concurrent::javathreadlocalvar#bind()","concurrent::rubythreadlocalvar#bind()","concurrent::mvar#borrow()","concurrent::synchronization::condition#broadcast()","concurrent::synchronization::lock#broadcast()","concurrent::cyclicbarrier#broken?()","concurrent::utility::nativeextensionloader#c_extensions_loaded?()","concurrent::async#call()","concurrent#call_dataflow()","concurrent::call_dataflow()","concurrent::serializedexecution#call_job()","concurrent::executorservice#can_overflow?()","concurrent::javathreadpoolexecutor#can_overflow?()","concurrent::rubythreadpoolexecutor#can_overflow?()","concurrent::future#cancel()","concurrent::scheduledtask#cancel()","concurrent::future#cancelled?()","concurrent::scheduledtask#cancelled?()","concurrent::tuple#cas()","concurrent::threadsafe::util::striped64#cas_base_computed()","concurrent::threadsafe::util::striped64::cell#cas_computed()","concurrent::collection::atomicreferencemapbackend::table#cas_new_node()","concurrent::async#cast()","concurrent::promise#catch()","concurrent::threadsafe::util::cheaplockable#cheap_broadcast()","concurrent::threadsafe::util::cheaplockable#cheap_synchronize()","concurrent::threadsafe::util::cheaplockable#cheap_wait()","concurrent::collection::atomicreferencemapbackend#check_for_resize()","concurrent::collection::atomicreferencemapbackend#clear()","concurrent::collection::javanonconcurrentpriorityqueue#clear()","concurrent::collection::mrimapbackend#clear()","concurrent::collection::nonconcurrentmapbackend#clear()","concurrent::collection::rubynonconcurrentpriorityqueue#clear()","concurrent::collection::synchronizedmapbackend#clear()","concurrent::collection::copyonwriteobserverset#clear_observers_and_return_old()","concurrent::transaction#commit()","concurrent::atom#compare_and_set()","concurrent::atomicnumericcompareandsetwrapper#compare_and_set()","concurrent::mutexatomicfixnum#compare_and_set()","concurrent::tuple#compare_and_set()","concurrent::concern::obligation#compare_and_set_state()","concurrent::atomicnumericcompareandsetwrapper#compare_and_swap()","concurrent::ivar#complete()","concurrent::promise#complete()","concurrent::concern::obligation#complete?()","concurrent::ivar#complete_without_notification()","concurrent::javathreadpoolexecutor#completed_task_count()","concurrent::rubythreadpoolexecutor#completed_task_count()","concurrent::collection::atomicreferencemapbackend#compute()","concurrent::collection::mrimapbackend#compute()","concurrent::collection::nonconcurrentmapbackend#compute()","concurrent::collection::synchronizedmapbackend#compute()","concurrent::collection::atomicreferencemapbackend#compute_if_absent()","concurrent::collection::mrimapbackend#compute_if_absent()","concurrent::collection::nonconcurrentmapbackend#compute_if_absent()","concurrent::collection::synchronizedmapbackend#compute_if_absent()","concurrent::collection::atomicreferencemapbackend#compute_if_present()","concurrent::collection::mrimapbackend#compute_if_present()","concurrent::collection::nonconcurrentmapbackend#compute_if_present()","concurrent::collection::synchronizedmapbackend#compute_if_present()","concurrent::utility::processorcounter#compute_physical_processor_count()","concurrent::utility::processorcounter#compute_processor_count()","concurrent::javacountdownlatch#count()","concurrent::mutexcountdownlatch#count()","concurrent::javacountdownlatch#count_down()","concurrent::mutexcountdownlatch#count_down()","concurrent::collection::copyonnotifyobserverset#count_observers()","concurrent::collection::copyonwriteobserverset#count_observers()","concurrent::concern::observable#count_observers()","concurrent::create_stdlib_logger()","concurrent::rubythreadpoolexecutor::worker#create_worker()","concurrent::transaction::current()","concurrent::transaction::current=()","concurrent#dataflow()","concurrent::dataflow()","concurrent::dataflow!()","concurrent#dataflow!()","concurrent::dataflow_with()","concurrent#dataflow_with()","concurrent#dataflow_with!()","concurrent::dataflow_with!()","concurrent::mutexatomicfixnum#decrement()","concurrent::threadsafe::util::adder#decrement()","concurrent::collection#decrement_size()","concurrent::synchronization::object::define_initialize_volatile_with_cas()","concurrent::synchronization::abstractstruct::define_struct_class()","concurrent::atexitimplementation#delete()","concurrent::collection::atomicreferencemapbackend#delete()","concurrent::collection::javanonconcurrentpriorityqueue#delete()","concurrent::collection::mrimapbackend#delete()","concurrent::collection::nonconcurrentmapbackend#delete()","concurrent::collection::rubynonconcurrentpriorityqueue#delete()","concurrent::collection::synchronizedmapbackend#delete()","concurrent::lazyregister#delete()","concurrent::collection::atomicreferencemapbackend::table#delete_node_at()","concurrent::collection::copyonnotifyobserverset#delete_observer()","concurrent::collection::copyonwriteobserverset#delete_observer()","concurrent::concern::observable#delete_observer()","concurrent::collection::copyonnotifyobserverset#delete_observers()","concurrent::collection::copyonwriteobserverset#delete_observers()","concurrent::concern::observable#delete_observers()","concurrent::collection::atomicreferencemapbackend#delete_pair()","concurrent::collection::mrimapbackend#delete_pair()","concurrent::collection::nonconcurrentmapbackend#delete_pair()","concurrent::collection::synchronizedmapbackend#delete_pair()","concurrent::concern::deprecation#deprecated()","concurrent::concern::deprecation#deprecated_method()","concurrent::collection::javanonconcurrentpriorityqueue#deq()","concurrent::collection::rubynonconcurrentpriorityqueue#deq()","concurrent::agent#deref()","concurrent::concern::dereferenceable#deref()","concurrent::disable_at_exit_handlers!()","concurrent::abstractexchanger#do_exchange()","concurrent::javaexchanger#do_exchange()","concurrent::rubyexchanger#do_exchange()","concurrent::mutexatomicfixnum#down()","concurrent::mutexsemaphore#drain_permits()","concurrent::collection::copyonnotifyobserverset#duplicate_and_clear_observers()","concurrent::collection::copyonnotifyobserverset#duplicate_observers()","concurrent::collection::nonconcurrentmapbackend#dupped_backend()","concurrent::collection::synchronizedmapbackend#dupped_backend()","concurrent::immutablestruct#each()","concurrent::mutablestruct#each()","concurrent::settablestruct#each()","concurrent::tuple#each()","concurrent::map#each_key()","concurrent::collection::atomicreferencemapbackend#each_pair()","concurrent::collection::nonconcurrentmapbackend#each_pair()","concurrent::immutablestruct#each_pair()","concurrent::mutablestruct#each_pair()","concurrent::settablestruct#each_pair()","concurrent::map#each_value()","concurrent::collection::atomicreferencemapbackend#empty?()","concurrent::collection::javanonconcurrentpriorityqueue#empty?()","concurrent::collection::rubynonconcurrentpriorityqueue#empty?()","concurrent::mvar#empty?()","concurrent::map#empty?()","concurrent::atexitimplementation#enabled=()","concurrent::atexitimplementation#enabled?()","concurrent::collection::javanonconcurrentpriorityqueue#enq()","concurrent::collection::rubynonconcurrentpriorityqueue#enq()","concurrent::agent#enqueue_action_job()","concurrent::agent#enqueue_await_job()","concurrent::synchronization::object::ensure_safe_initialization_when_final_fields_are_present()","concurrent::agent#error()","concurrent::concern::obligation#event()","concurrent::concern::obligation#exception()","concurrent::abstractexchanger#exchange()","concurrent::abstractexchanger#exchange!()","concurrent::future::execute()","concurrent::future#execute()","concurrent::promise::execute()","concurrent::promise#execute()","concurrent::safetaskexecutor#execute()","concurrent::scheduledtask::execute()","concurrent::scheduledtask#execute()","concurrent::timertask#execute()","concurrent::timertask::execute()","concurrent::agent#execute_next_job()","concurrent::timertask#execute_task()","concurrent::timertask#execution_interval()","concurrent::timertask#execution_interval=()","concurrent::executor()","concurrent::options::executor()","concurrent::threadsafe::util::striped64#expand_table_unless_stale()","concurrent::ivar#fail()","concurrent::promise#fail()","concurrent::agent#failed?()","concurrent::mutexatomicboolean#false?()","concurrent::map#fetch()","concurrent::map#fetch_or_store()","concurrent::collection::atomicreferencemapbackend#find_value_in_node_list()","concurrent::promise#flat_map()","concurrent::collection::atomicreferencemapbackend::node#force_aquire_lock()","concurrent::threadsafe::util::striped64#free?()","concurrent::maybe::from()","concurrent::collection::javanonconcurrentpriorityqueue::from_list()","concurrent::collection::rubynonconcurrentpriorityqueue::from_list()","concurrent::promise::fulfill()","concurrent::concern::obligation#fulfilled?()","concurrent::maybe#fulfilled?()","concurrent::mvar#full?()","concurrent::synchronization::abstractobject#full_memory_barrier()","concurrent::synchronization::mriattrvolatile#full_memory_barrier()","concurrent::synchronization::rbxattrvolatile#full_memory_barrier()","concurrent::synchronization::truffleattrvolatile#full_memory_barrier()","concurrent::map#get()","concurrent::mutexatomicreference#get()","concurrent::threadsafe::util::xorshiftrandom#get()","concurrent::tuple#get()","concurrent::collection::atomicreferencemapbackend#get_and_set()","concurrent::collection::mrimapbackend#get_and_set()","concurrent::collection::nonconcurrentmapbackend#get_and_set()","concurrent::collection::synchronizedmapbackend#get_and_set()","concurrent::mutexatomicreference#get_and_set()","concurrent::concern::obligation#get_arguments_from()","concurrent::collection::atomicreferencemapbackend#get_or_default()","concurrent::collection::nonconcurrentmapbackend#get_or_default()","concurrent::collection::synchronizedmapbackend#get_or_default()","concurrent::rubythreadlocalvar#get_threadlocal_array()","concurrent#get_time()","concurrent::global_fast_executor()","concurrent::global_immediate_executor()","concurrent::global_io_executor()","concurrent::global_logger()","concurrent::global_logger=()","concurrent::global_timer_set()","concurrent::agent#handle_error()","concurrent::abstractexecutorservice#handle_fallback()","concurrent::atexitimplementation#handler?()","concurrent::atexitimplementation#handlers()","concurrent::lazyregister#has_key?()","concurrent::collection::javanonconcurrentpriorityqueue#has_priority?()","concurrent::collection::rubynonconcurrentpriorityqueue#has_priority?()","concurrent::readwritelock#has_waiters?()","concurrent::threadsafe::util::striped64#hash_code()","concurrent::threadsafe::util::striped64#hash_code=()","concurrent::threadsafe::util::poweroftwotuple#hash_to_index()","concurrent::javathreadpoolexecutor#idletime()","concurrent::concern::obligation#if_state()","concurrent::collection::javanonconcurrentpriorityqueue#include?()","concurrent::collection::rubynonconcurrentpriorityqueue#include?()","concurrent::async::included()","concurrent::immutablestruct::included()","concurrent::synchronization::jrubyattrvolatile::included()","concurrent::synchronization::mriattrvolatile::included()","concurrent::synchronization::rbxattrvolatile::included()","concurrent::synchronization::truffleattrvolatile::included()","concurrent::concern::obligation#incomplete?()","concurrent::mutexatomicfixnum#increment()","concurrent::threadsafe::util::adder#increment()","concurrent::collection#increment_size()","concurrent::map#index()","concurrent::concern::obligation#init_obligation()","concurrent::async#init_synchronization()","concurrent::scheduledtask#initial_delay()","concurrent::collection::atomicreferencemapbackend#initialize_copy()","concurrent::collection::nonconcurrentmapbackend#initialize_copy()","concurrent::map#initialize_copy()","concurrent::collection::atomicreferencemapbackend#initialize_table()","concurrent::synchronization::object#initialize_volatile_with_cas()","concurrent::immutablestruct#inspect()","concurrent::map#inspect()","concurrent::mutablestruct#inspect()","concurrent::settablestruct#inspect()","concurrent::atexitimplementation#install()","concurrent::collection::atomicreferencemapbackend#internal_compute()","concurrent::collection::atomicreferencemapbackend#internal_replace()","concurrent::threadsafe::util::striped64#internal_reset()","concurrent::rubyexchanger::node#item()","concurrent::utility::nativeextensionloader#java_extensions_loaded?()","concurrent::maybe::just()","concurrent::maybe#just?()","concurrent::map#key()","concurrent::collection::atomicreferencemapbackend#key?()","concurrent::collection::atomicreferencemapbackend::node#key?()","concurrent::collection::nonconcurrentmapbackend#key?()","concurrent::collection::synchronizedmapbackend#key?()","concurrent::lazyregister#key?()","concurrent::collection::atomicreferencemapbackend#key_hash()","concurrent::map#keys()","concurrent::abstractexecutorservice#kill()","concurrent::immediateexecutor#kill()","concurrent::javaexecutorservice#kill()","concurrent::rubyexecutorservice#kill()","concurrent::rubythreadpoolexecutor::worker#kill()","concurrent::simpleexecutorservice#kill()","concurrent::timerset#kill()","concurrent::javathreadpoolexecutor#largest_length()","concurrent::rubythreadpoolexecutor#largest_length()","concurrent::rubyexchanger::node#latch()","concurrent#leave_transaction()","concurrent::leave_transaction()","concurrent::collection::javanonconcurrentpriorityqueue#length()","concurrent::collection::rubynonconcurrentpriorityqueue#length()","concurrent::javathreadpoolexecutor#length()","concurrent::rubythreadpoolexecutor#length()","concurrent::synchronization::abstractstruct#length()","concurrent::utility::nativeextensionloader#load_native_extensions()","concurrent::collection#lock_and_clean_up_reverse_forwarders()","concurrent::collection::atomicreferencemapbackend::node#locked?()","concurrent::collection::atomicreferencemapbackend::node::locked_hash?()","concurrent::concern::logging#log()","concurrent::mutexatomicboolean#make_false()","concurrent::threadsafe::util::make_synchronized_on_rbx()","concurrent::mutexatomicboolean#make_true()","concurrent::map#marshal_dump()","concurrent::map#marshal_load()","concurrent::collection::atomicreferencemapbackend::node#matches?()","concurrent::readwritelock#max_readers?()","concurrent::reentrantreadwritelock#max_readers?()","concurrent::readwritelock#max_writers?()","concurrent::reentrantreadwritelock#max_writers?()","concurrent::synchronization::abstractstruct#members()","concurrent::immutablestruct#merge()","concurrent::mutablestruct#merge()","concurrent::settablestruct#merge()","concurrent::collection::atomicreferencemapbackend#merge_pair()","concurrent::collection::mrimapbackend#merge_pair()","concurrent::collection::nonconcurrentmapbackend#merge_pair()","concurrent::collection::synchronizedmapbackend#merge_pair()","concurrent::async::asyncdelegator#method_missing()","concurrent::async::awaitdelegator#method_missing()","concurrent::synchronizeddelegator#method_missing()","concurrent::javathreadpoolexecutor#min_length()","concurrent::mvar#modify()","concurrent::mvar#modify!()","concurrent#monotonic_time()","concurrent::monotonic_time()","concurrent::new()","concurrent::abstractexchanger::new()","concurrent::abstractexecutorservice::new()","concurrent::abstractthreadlocalvar::new()","concurrent::agent::new()","concurrent::agent::error::new()","concurrent::agent::validationerror::new()","concurrent::async::asyncdelegator::new()","concurrent::async::awaitdelegator::new()","concurrent::async::classmethods#new()","concurrent::atexitimplementation::new()","concurrent::atom::new()","concurrent::cachedthreadpool::new()","concurrent::collection::atomicreferencemapbackend::new()","concurrent::collection::atomicreferencemapbackend::node::new()","concurrent::collection::copyonnotifyobserverset::new()","concurrent::collection::copyonwriteobserverset::new()","concurrent::collection::javanonconcurrentpriorityqueue::new()","concurrent::collection::mrimapbackend::new()","concurrent::collection::nonconcurrentmapbackend::new()","concurrent::collection::rubynonconcurrentpriorityqueue::new()","concurrent::cyclicbarrier::new()","concurrent::delay::new()","concurrent::event::new()","concurrent::fixedthreadpool::new()","concurrent::future::new()","concurrent::ivar::new()","concurrent::immediateexecutor::new()","concurrent::immutablestruct::new()","concurrent::indirectimmediateexecutor::new()","concurrent::javacountdownlatch::new()","concurrent::javaexchanger::new()","concurrent::javaexecutorservice::new()","concurrent::javaexecutorservice::job::new()","concurrent::javasinglethreadexecutor::new()","concurrent::javathreadpoolexecutor::new()","concurrent::lazyregister::new()","concurrent::mvar::new()","concurrent::map::new()","concurrent::maybe::new()","concurrent::mutablestruct::new()","concurrent::mutexatomicboolean::new()","concurrent::mutexatomicfixnum::new()","concurrent::mutexatomicreference::new()","concurrent::mutexcountdownlatch::new()","concurrent::mutexsemaphore::new()","concurrent::promise::new()","concurrent::readwritelock::new()","concurrent::reentrantreadwritelock::new()","concurrent::rubyexchanger::new()","concurrent::rubyexchanger::node::new()","concurrent::rubyexecutorservice::new()","concurrent::rubysinglethreadexecutor::new()","concurrent::rubythreadlocalvar::new()","concurrent::rubythreadpoolexecutor::new()","concurrent::rubythreadpoolexecutor::worker::new()","concurrent::safetaskexecutor::new()","concurrent::scheduledtask::new()","concurrent::serializedexecution::new()","concurrent::serializedexecutiondelegator::new()","concurrent::settablestruct::new()","concurrent::synchronization::abstractobject::new()","concurrent::synchronization::abstractstruct::new()","concurrent::synchronization::condition::new()","concurrent::synchronization::jrubyobject::new()","concurrent::synchronization::mrimonitorlockableobject::new()","concurrent::synchronization::mrimutexlockableobject::new()","concurrent::synchronization::mriobject::new()","concurrent::synchronization::object::new()","concurrent::synchronization::object::new()","concurrent::synchronization::rbxlockableobject::new()","concurrent::synchronization::rbxobject::new()","concurrent::synchronization::trufflelockableobject#new()","concurrent::synchronization::truffleobject::new()","concurrent::synchronizeddelegator::new()","concurrent::tvar::new()","concurrent::threadsafe::util::poweroftwotuple::new()","concurrent::threadsafe::util::striped64::new()","concurrent::timerset::new()","concurrent::timertask::new()","concurrent::transaction::new()","concurrent::tuple::new()","concurrent::utility::processorcounter::new()","concurrent::synchronization::lockableobject#new_condition()","concurrent::new_fast_executor()","concurrent::new_io_executor()","concurrent::threadsafe::util::poweroftwotuple#next_in_size_table()","concurrent::concern::obligation#no_error!()","concurrent::maybe::nothing()","concurrent::maybe#nothing?()","concurrent::collection::copyonnotifyobserverset#notify_and_delete_observers()","concurrent::collection::copyonwriteobserverset#notify_and_delete_observers()","concurrent::promise#notify_child()","concurrent::collection::copyonnotifyobserverset#notify_observers()","concurrent::collection::copyonwriteobserverset#notify_observers()","concurrent::ivar#notify_observers()","concurrent::collection::copyonnotifyobserverset#notify_to()","concurrent::collection::copyonwriteobserverset#notify_to()","concurrent::rubythreadpoolexecutor#ns_add_busy_worker()","concurrent::rubythreadpoolexecutor#ns_assign_worker()","concurrent::abstractexecutorservice#ns_auto_terminate=()","concurrent::abstractexecutorservice#ns_auto_terminate?()","concurrent::synchronization::abstractlockableobject#ns_broadcast()","concurrent::synchronization::condition#ns_broadcast()","concurrent::synchronization::mrilockableobject#ns_broadcast()","concurrent::synchronization::rbxlockableobject#ns_broadcast()","concurrent::concern::obligation#ns_check_state?()","concurrent::ivar#ns_complete_without_notification()","concurrent::synchronization::abstractstruct#ns_each()","concurrent::synchronization::abstractstruct#ns_each_pair()","concurrent::rubythreadpoolexecutor#ns_enqueue()","concurrent::agent#ns_enqueue_job()","concurrent::synchronization::abstractstruct#ns_equality()","concurrent::abstractexecutorservice#ns_execute()","concurrent::rubythreadpoolexecutor#ns_execute()","concurrent::agent#ns_find_last_job_for_thread()","concurrent::cyclicbarrier#ns_generation_done()","concurrent::synchronization::abstractstruct#ns_get()","concurrent::agent#ns_initialize()","concurrent::atexitimplementation#ns_initialize()","concurrent::cachedthreadpool#ns_initialize()","concurrent::collection::copyonnotifyobserverset#ns_initialize()","concurrent::collection::copyonwriteobserverset#ns_initialize()","concurrent::cyclicbarrier#ns_initialize()","concurrent::delay#ns_initialize()","concurrent::event#ns_initialize()","concurrent::future#ns_initialize()","concurrent::ivar#ns_initialize()","concurrent::javasinglethreadexecutor#ns_initialize()","concurrent::javathreadpoolexecutor#ns_initialize()","concurrent::mutexatomicboolean#ns_initialize()","concurrent::mutexatomicfixnum#ns_initialize()","concurrent::mutexatomicreference#ns_initialize()","concurrent::mutexcountdownlatch#ns_initialize()","concurrent::mutexsemaphore#ns_initialize()","concurrent::promise#ns_initialize()","concurrent::rubythreadpoolexecutor#ns_initialize()","concurrent::serializedexecution#ns_initialize()","concurrent::simpleexecutorservice#ns_initialize()","concurrent::synchronization::abstractstruct#ns_initialize()","concurrent::timerset#ns_initialize()","concurrent::timertask#ns_initialize()","concurrent::synchronization::abstractstruct#ns_inspect()","concurrent::abstractexecutorservice#ns_kill_execution()","concurrent::rubythreadpoolexecutor#ns_kill_execution()","concurrent::timertask#ns_kill_execution()","concurrent::rubythreadpoolexecutor#ns_limited_queue?()","concurrent::javaexecutorservice#ns_make_executor_runnable()","concurrent::mutexatomicboolean#ns_make_value()","concurrent::synchronization::abstractstruct#ns_merge()","concurrent::cyclicbarrier#ns_next_generation()","concurrent::agent#ns_post_next_job()","concurrent::timerset#ns_post_task()","concurrent::rubythreadpoolexecutor#ns_prune_pool()","concurrent::rubythreadpoolexecutor#ns_ready_worker()","concurrent::rubythreadpoolexecutor#ns_remove_busy_worker()","concurrent::scheduledtask#ns_reschedule()","concurrent::rubythreadpoolexecutor#ns_reset_if_forked()","concurrent::javaexecutorservice#ns_running?()","concurrent::rubyexecutorservice#ns_running?()","concurrent::scheduledtask#ns_schedule()","concurrent::synchronization::abstractstruct#ns_select()","concurrent::event#ns_set()","concurrent::mutexatomicfixnum#ns_set()","concurrent::concern::dereferenceable#ns_set_deref_options()","concurrent::concern::obligation#ns_set_state()","concurrent::javaexecutorservice#ns_shutdown?()","concurrent::rubyexecutorservice#ns_shutdown?()","concurrent::abstractexecutorservice#ns_shutdown_execution()","concurrent::rubyexecutorservice#ns_shutdown_execution()","concurrent::rubythreadpoolexecutor#ns_shutdown_execution()","concurrent::timerset#ns_shutdown_execution()","concurrent::timertask#ns_shutdown_execution()","concurrent::javaexecutorservice#ns_shuttingdown?()","concurrent::rubyexecutorservice#ns_shuttingdown?()","concurrent::synchronization::abstractlockableobject#ns_signal()","concurrent::synchronization::condition#ns_signal()","concurrent::synchronization::mrilockableobject#ns_signal()","concurrent::synchronization::rbxlockableobject#ns_signal()","concurrent::synchronization::abstractstruct#ns_to_h()","concurrent::agent#ns_validate()","concurrent::synchronization::abstractstruct#ns_values()","concurrent::synchronization::abstractstruct#ns_values_at()","concurrent::synchronization::abstractlockableobject#ns_wait()","concurrent::synchronization::condition#ns_wait()","concurrent::synchronization::mrimonitorlockableobject#ns_wait()","concurrent::synchronization::mrimutexlockableobject#ns_wait()","concurrent::synchronization::rbxlockableobject#ns_wait()","concurrent::synchronization::abstractlockableobject#ns_wait_until()","concurrent::synchronization::condition#ns_wait_until()","concurrent::rubythreadpoolexecutor#ns_worker_died()","concurrent::rubythreadpoolexecutor#ns_worker_not_old_enough()","concurrent::cyclicbarrier#number_waiting()","concurrent::collection::copyonwriteobserverset#observers()","concurrent::collection::copyonwriteobserverset#observers=()","concurrent::utility::enginedetector#on_cruby?()","concurrent::promise#on_error()","concurrent::promise#on_fulfill()","concurrent::utility::enginedetector#on_jruby?()","concurrent::utility::enginedetector#on_jruby_9000?()","concurrent::utility::enginedetector#on_linux?()","concurrent::utility::enginedetector#on_osx?()","concurrent::utility::enginedetector#on_rbx?()","concurrent::promise#on_reject()","concurrent::promise#on_success()","concurrent::utility::enginedetector#on_truffle?()","concurrent::utility::enginedetector#on_windows?()","concurrent::maybe#or()","concurrent::collection::rubynonconcurrentpriorityqueue#ordered?()","concurrent::collection::nonconcurrentmapbackend#pair?()","concurrent::cyclicbarrier#parties()","concurrent::collection::javanonconcurrentpriorityqueue#peek()","concurrent::collection::rubynonconcurrentpriorityqueue#peek()","concurrent::concern::obligation#pending?()","concurrent::async::asyncdelegator#perform()","concurrent::physical_processor_count()","concurrent::utility::processorcounter#physical_processor_count()","concurrent::collection::javanonconcurrentpriorityqueue#pop()","concurrent::collection::rubynonconcurrentpriorityqueue#pop()","concurrent::map#populate_from()","concurrent::agent#post()","concurrent::executorservice#post()","concurrent::immediateexecutor#post()","concurrent::indirectimmediateexecutor#post()","concurrent::javaexecutorservice#post()","concurrent::rubyexecutorservice#post()","concurrent::serializedexecution#post()","concurrent::serializedexecutiondelegator#post()","concurrent::simpleexecutorservice::post()","concurrent::simpleexecutorservice#post()","concurrent::timerset#post()","concurrent::timerset#post_task()","concurrent::serializedexecution#posts()","concurrent::synchronization::abstractstruct#pr_underscore()","concurrent::scheduledtask#process_task()","concurrent::timerset#process_tasks()","concurrent::scheduledtask#processing?()","concurrent::processor_count()","concurrent::utility::processorcounter#processor_count()","concurrent::collection::atomicreferencemapbackend::node#pure_hash()","concurrent::collection::javanonconcurrentpriorityqueue#push()","concurrent::collection::rubynonconcurrentpriorityqueue#push()","concurrent::mvar#put()","concurrent::map#put_if_absent()","concurrent::javathreadpoolexecutor#queue_length()","concurrent::rubythreadpoolexecutor#queue_length()","concurrent::map#raise_fetch_no_key()","concurrent::mutexatomicfixnum#range_check!()","concurrent::transaction#read()","concurrent::rubythreadpoolexecutor#ready_worker()","concurrent::promise#realize()","concurrent::concern::obligation#realized?()","concurrent::agent#reason()","concurrent::concern::obligation#reason()","concurrent::collection#rebuild()","concurrent::delay#reconfigure()","concurrent::mutexsemaphore#reduce_permits()","concurrent::lazyregister#register()","concurrent::lazyregister#registered?()","concurrent::promise::reject()","concurrent::concern::obligation#rejected?()","concurrent::maybe#rejected?()","concurrent::mutexsemaphore#release()","concurrent::readwritelock#release_read_lock()","concurrent::reentrantreadwritelock#release_read_lock()","concurrent::readwritelock#release_write_lock()","concurrent::reentrantreadwritelock#release_write_lock()","concurrent::javathreadpoolexecutor#remaining_capacity()","concurrent::rubythreadpoolexecutor#remaining_capacity()","concurrent::lazyregister#remove()","concurrent::rubythreadpoolexecutor#remove_busy_worker()","concurrent::timerset#remove_task()","concurrent::collection::atomicreferencemapbackend#replace_if_exists()","concurrent::collection::mrimapbackend#replace_if_exists()","concurrent::collection::nonconcurrentmapbackend#replace_if_exists()","concurrent::collection::synchronizedmapbackend#replace_if_exists()","concurrent::collection::atomicreferencemapbackend#replace_pair()","concurrent::collection::mrimapbackend#replace_pair()","concurrent::collection::nonconcurrentmapbackend#replace_pair()","concurrent::collection::synchronizedmapbackend#replace_pair()","concurrent::scheduledtask#reschedule()","concurrent::promise#rescue()","concurrent::atom#reset()","concurrent::cyclicbarrier#reset()","concurrent::event#reset()","concurrent::scheduledtask#reset()","concurrent::threadsafe::util::adder#reset()","concurrent::agent#restart()","concurrent::threadsafe::util::striped64#retry_update()","concurrent::utility::enginedetector#ruby_engine()","concurrent::utility::enginedetector#ruby_version()","concurrent::atexitimplementation#run()","concurrent::javaexecutorservice::job#run()","concurrent::rubythreadpoolexecutor::worker#run_task()","concurrent::atexitimplementation#runner()","concurrent::abstractexecutorservice#running?()","concurrent::immediateexecutor#running?()","concurrent::javathreadpoolexecutor#running?()","concurrent::simpleexecutorservice#running?()","concurrent::timertask#running?()","concurrent::readwritelock#running_readers()","concurrent::reentrantreadwritelock#running_readers()","concurrent::readwritelock#running_readers?()","concurrent::reentrantreadwritelock#running_readers?()","concurrent::readwritelock#running_writer?()","concurrent::reentrantreadwritelock#running_writer?()","concurrent::ivar#safe_execute()","concurrent::synchronization::object::safe_initialization!()","concurrent::synchronization::object::safe_initialization?()","concurrent::timertask#schedule_next_task()","concurrent::scheduledtask#schedule_time()","concurrent::javathreadpoolexecutor#scheduled_task_count()","concurrent::rubythreadpoolexecutor#scheduled_task_count()","concurrent::immutablestruct#select()","concurrent::mutablestruct#select()","concurrent::settablestruct#select()","concurrent::agent#send()","concurrent::agent#send!()","concurrent::agent#send_off()","concurrent::agent#send_off!()","concurrent::agent#send_via()","concurrent::agent#send_via!()","concurrent::executorservice#serialized?()","concurrent::serialexecutorservice#serialized?()","concurrent::event#set()","concurrent::future#set()","concurrent::ivar#set()","concurrent::mutexatomicreference#set()","concurrent::promise#set()","concurrent::tuple#set()","concurrent::mvar#set!()","concurrent::event#set?()","concurrent::utility::nativeextensionloader#set_c_extensions_loaded()","concurrent::concern::dereferenceable#set_deref_options()","concurrent::utility::nativeextensionloader#set_java_extensions_loaded()","concurrent::promise#set_pending()","concurrent::concern::obligation#set_state()","concurrent::promise#set_state!()","concurrent::rubythreadlocalvar#set_threadlocal_array()","concurrent::synchronizeddelegator#setup()","concurrent::collection::javanonconcurrentpriorityqueue#shift()","concurrent::collection::rubynonconcurrentpriorityqueue#shift()","concurrent::abstractexecutorservice#shutdown()","concurrent::immediateexecutor#shutdown()","concurrent::javaexecutorservice#shutdown()","concurrent::rubyexecutorservice#shutdown()","concurrent::simpleexecutorservice#shutdown()","concurrent::abstractexecutorservice#shutdown?()","concurrent::immediateexecutor#shutdown?()","concurrent::simpleexecutorservice#shutdown?()","concurrent::abstractexecutorservice#shuttingdown?()","concurrent::immediateexecutor#shuttingdown?()","concurrent::simpleexecutorservice#shuttingdown?()","concurrent::synchronization::condition#signal()","concurrent::synchronization::lock#signal()","concurrent::collection::rubynonconcurrentpriorityqueue#sink()","concurrent::collection::atomicreferencemapbackend#size()","concurrent::collection::javanonconcurrentpriorityqueue#size()","concurrent::collection::nonconcurrentmapbackend#size()","concurrent::collection::rubynonconcurrentpriorityqueue#size()","concurrent::collection::synchronizedmapbackend#size()","concurrent::map#size()","concurrent::synchronization::abstractstruct#size()","concurrent::collection#split_bin()","concurrent::collection#split_old_bin()","concurrent::concern::obligation#state()","concurrent::concern::obligation#state=()","concurrent::rubythreadpoolexecutor::worker#stop()","concurrent::rubyexecutorservice#stop_event()","concurrent::agent#stopped?()","concurrent::rubyexecutorservice#stopped_event()","concurrent::lazyregister#store()","concurrent::collection::nonconcurrentmapbackend#store_computed_value()","concurrent::threadsafe::util::adder#sum()","concurrent::atom#swap()","concurrent::collection::rubynonconcurrentpriorityqueue#swap()","concurrent::mutexatomicreference#swap()","concurrent::collection::rubynonconcurrentpriorityqueue#swim()","concurrent::mvar#synchronize()","concurrent::synchronization::abstractlockableobject#synchronize()","concurrent::synchronization::mrimonitorlockableobject#synchronize()","concurrent::synchronization::mrimutexlockableobject#synchronize()","concurrent::synchronization::rbxlockableobject#synchronize()","concurrent::promise#synchronized_set_state!()","concurrent::collection::atomicreferencemapbackend#table_size_for()","concurrent::mvar#take()","concurrent::synchronizeddelegator#teardown()","concurrent::abstractexecutorservice#terminate_at_exit()","concurrent::promise#then()","concurrent::rubythreadlocalvar::thread_finalizer()","concurrent::rubythreadlocalvar::threadlocal_finalizer()","concurrent::timertask#timeout_interval()","concurrent::timertask#timeout_interval=()","concurrent::timertask#timeout_task()","concurrent::immutablestruct#to_a()","concurrent::mutablestruct#to_a()","concurrent::settablestruct#to_a()","concurrent::immutablestruct#to_h()","concurrent::mutablestruct#to_h()","concurrent::settablestruct#to_h()","concurrent::immutablestruct#to_s()","concurrent::mutablestruct#to_s()","concurrent::settablestruct#to_s()","concurrent::mutexatomicboolean#true?()","concurrent::event#try?()","concurrent::mutexsemaphore#try_acquire()","concurrent::mutexsemaphore#try_acquire_now()","concurrent::mutexsemaphore#try_acquire_timed()","concurrent::collection::atomicreferencemapbackend#try_await_lock()","concurrent::collection::atomicreferencemapbackend::node#try_await_lock()","concurrent::abstractexchanger#try_exchange()","concurrent::threadsafe::util::striped64#try_in_busy()","concurrent::collection#try_in_resize_lock()","concurrent::threadsafe::util::striped64#try_initialize_cells()","concurrent::collection::atomicreferencemapbackend::node#try_lock_via_hash()","concurrent::collection::atomicreferencemapbackend::table#try_lock_via_hash()","concurrent::mvar#try_put!()","concurrent::reentrantreadwritelock#try_read_lock()","concurrent::ivar#try_set()","concurrent::mvar#try_take!()","concurrent::collection::atomicreferencemapbackend::table#try_to_cas_in_computed()","concurrent::threadsafe::util::striped64#try_to_install_new_cell()","concurrent::atomicdirectupdate#try_update()","concurrent::atomicdirectupdate#try_update!()","concurrent::reentrantreadwritelock#try_write_lock()","concurrent::transaction#unlock()","concurrent::collection::atomicreferencemapbackend::node#unlock_via_hash()","concurrent::mvar#unlocked_empty?()","concurrent::mvar#unlocked_full?()","concurrent::lazyregister#unregister()","concurrent::concern::obligation#unscheduled?()","concurrent::mutexatomicfixnum#up()","concurrent::atomicdirectupdate#update()","concurrent::mutexatomicfixnum#update()","concurrent::use_stdlib_logger()","concurrent::atom#valid?()","concurrent::transaction#valid?()","concurrent::async::validate_argc()","concurrent::map#validate_options_hash!()","concurrent::abstractthreadlocalvar#value()","concurrent::agent#value()","concurrent::concern::dereferenceable#value()","concurrent::concern::obligation#value()","concurrent::delay#value()","concurrent::javathreadlocalvar#value()","concurrent::mutexatomicboolean#value()","concurrent::mutexatomicfixnum#value()","concurrent::mutexatomicreference#value()","concurrent::rubythreadlocalvar#value()","concurrent::tvar#value()","concurrent::concern::obligation#value!()","concurrent::delay#value!()","concurrent::abstractthreadlocalvar#value=()","concurrent::concern::dereferenceable#value=()","concurrent::javathreadlocalvar#value=()","concurrent::mutexatomicboolean#value=()","concurrent::mutexatomicfixnum#value=()","concurrent::mutexatomicreference#value=()","concurrent::rubythreadlocalvar#value=()","concurrent::tvar#value=()","concurrent::map#value?()","concurrent::rubythreadlocalvar#value_for()","concurrent::immutablestruct#values()","concurrent::map#values()","concurrent::mutablestruct#values()","concurrent::settablestruct#values()","concurrent::immutablestruct#values_at()","concurrent::mutablestruct#values_at()","concurrent::settablestruct#values_at()","concurrent::synchronization::object::volatile_cas_fields()","concurrent::tuple#volatile_get()","concurrent::threadsafe::util::poweroftwotuple#volatile_get_by_hash()","concurrent::tuple#volatile_set()","concurrent::threadsafe::util::poweroftwotuple#volatile_set_by_hash()","concurrent::agent#wait()","concurrent::concern::obligation#wait()","concurrent::cyclicbarrier#wait()","concurrent::delay#wait()","concurrent::event#wait()","concurrent::javacountdownlatch#wait()","concurrent::mutexcountdownlatch#wait()","concurrent::synchronization::condition#wait()","concurrent::synchronization::lock#wait()","concurrent::concern::obligation#wait!()","concurrent::mvar#wait_for_empty()","concurrent::mvar#wait_for_full()","concurrent::abstractexecutorservice#wait_for_termination()","concurrent::immediateexecutor#wait_for_termination()","concurrent::javaexecutorservice#wait_for_termination()","concurrent::rubyexecutorservice#wait_for_termination()","concurrent::simpleexecutorservice#wait_for_termination()","concurrent::future#wait_or_cancel()","concurrent::synchronization::condition#wait_until()","concurrent::synchronization::lock#wait_until()","concurrent::mvar#wait_while()","concurrent::reentrantreadwritelock#waiting_or_running_writer?()","concurrent::readwritelock#waiting_writer?()","concurrent::readwritelock#waiting_writers()","concurrent::reentrantreadwritelock#waiting_writers()","concurrent::concern::observable#with_observer()","concurrent::readwritelock#with_read_lock()","concurrent::reentrantreadwritelock#with_read_lock()","concurrent::readwritelock#with_write_lock()","concurrent::reentrantreadwritelock#with_write_lock()","concurrent::serializedexecution#work()","concurrent::rubythreadpoolexecutor#worker_died()","concurrent::rubythreadpoolexecutor#worker_not_old_enough()","concurrent::rubythreadpoolexecutor#worker_task_completed()","concurrent::transaction#write()","concurrent::readwritelock#write_locked?()","concurrent::threadsafe::util::xorshiftrandom#xorshift()","concurrent::promise::zip()","concurrent::promise#zip()","","",""],"info":[["Concurrent","","Concurrent.html","","<p>Modern concurrency tools for Ruby. Inspired by Erlang, Clojure, Scala,\nHaskell, F#, C#, Java, and classic \n"],["Concurrent::AbstractExchanger","","Concurrent/AbstractExchanger.html","","<p>@!macro [attach] exchanger\n\n<pre>A synchronization point at which threads can pair and swap elements within ...</pre>\n"],["Concurrent::AbstractExecutorService","","Concurrent/AbstractExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::AbstractThreadLocalVar","","Concurrent/AbstractThreadLocalVar.html","","<p>@!macro thread_local_var @!macro internal_implementation_note @!visibility\nprivate\n"],["Concurrent::Agent","","Concurrent/Agent.html","","<p>`Agent` is inspired by Clojure&#39;s [agent](clojure.org/agents) function.\nAn agent is a shared, mutable \n"],["Concurrent::Agent::Error","","Concurrent/Agent/Error.html","","<p>Raised during action processing or any other time in an Agent&#39;s\nlifecycle.\n"],["Concurrent::Agent::ValidationError","","Concurrent/Agent/ValidationError.html","","<p>Raised when a new value obtained during action processing or at `#restart`\nfails validation.\n"],["Concurrent::Array","","Concurrent/Array.html","","<p>@!macro concurrent_array\n"],["Concurrent::Async","","Concurrent/Async.html","","<p>A mixin module that provides simple asynchronous behavior to a class,\nturning it into a simple actor. \n"],["Concurrent::Async::AsyncDelegator","","Concurrent/Async/AsyncDelegator.html","","<p>Delegates asynchronous, thread-safe method calls to the wrapped object.\n<p>@!visibility private\n"],["Concurrent::Async::AwaitDelegator","","Concurrent/Async/AwaitDelegator.html","","<p>Delegates synchronous, thread-safe method calls to the wrapped object.\n<p>@!visibility private\n"],["Concurrent::Async::ClassMethods","","Concurrent/Async/ClassMethods.html","","<p>@!visibility private\n"],["Concurrent::AtExitImplementation","","Concurrent/AtExitImplementation.html","","<p>Provides ability to add and remove handlers to be run at `Kernel#at_exit`,\norder is undefined. Each handler \n"],["Concurrent::Atom","","Concurrent/Atom.html","","<p>Atoms provide a way to manage shared, synchronous, independent state.\n<p>An atom is initialized with an initial \n"],["Concurrent::AtomicBoolean","","Concurrent/AtomicBoolean.html","","<p>@!macro [attach] atomic_boolean\n\n<pre>A boolean value that can be updated atomically. Reads and writes to an ...</pre>\n"],["Concurrent::AtomicDirectUpdate","","Concurrent/AtomicDirectUpdate.html","","<p>Define update methods that use direct paths\n<p>@!visibility private @!macro internal_implementation_note \n"],["Concurrent::AtomicFixnum","","Concurrent/AtomicFixnum.html","","<p>@!macro [attach] atomic_fixnum\n\n<pre>A numeric value that can be updated atomically. Reads and writes to an ...</pre>\n"],["Concurrent::AtomicNumericCompareAndSetWrapper","","Concurrent/AtomicNumericCompareAndSetWrapper.html","","<p>Special compare and set handling of numeric values.\n<p>@!visibility private @!macro internal_implementation_note \n"],["Concurrent::AtomicReference","","Concurrent/AtomicReference.html","","<p>@!macro atomic_reference\n"],["Concurrent::CAtomicReference","","Concurrent/CAtomicReference.html","","<p>@!macro atomic_reference\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::CachedThreadPool","","Concurrent/CachedThreadPool.html","","<p>A thread pool that dynamically grows and shrinks to fit the current\nworkload. New threads are created \n"],["Concurrent::Collection","","Concurrent/Collection.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::Collection::AtomicReferenceMapBackend","","Concurrent/Collection/AtomicReferenceMapBackend.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.ConcurrentHashMapV8 class version\n1.59 available in public \n"],["Concurrent::Collection::AtomicReferenceMapBackend::Node","","Concurrent/Collection/AtomicReferenceMapBackend/Node.html","","<p>Key-value entry. Nodes with a hash field of <code>MOVED</code> are special,\nand do not contain user keys or values. \n"],["Concurrent::Collection::AtomicReferenceMapBackend::Table","","Concurrent/Collection/AtomicReferenceMapBackend/Table.html","","<p>@!visibility private\n"],["Concurrent::Collection::CopyOnNotifyObserverSet","","Concurrent/Collection/CopyOnNotifyObserverSet.html","","<p>A thread safe observer set implemented using copy-on-read approach:\nobservers are added and removed from \n"],["Concurrent::Collection::CopyOnWriteObserverSet","","Concurrent/Collection/CopyOnWriteObserverSet.html","","<p>A thread safe observer set implemented using copy-on-write approach: every\ntime an observer is added \n"],["Concurrent::Collection::JavaNonConcurrentPriorityQueue","","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html","","<p>@!macro priority_queue\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Collection::MriMapBackend","","Concurrent/Collection/MriMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Collection::NonConcurrentMapBackend","","Concurrent/Collection/NonConcurrentMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Collection::NonConcurrentPriorityQueue","","Concurrent/Collection/NonConcurrentPriorityQueue.html","","<p>@!macro [attach] priority_queue\n\n<pre>A queue collection in which the elements are sorted based on their\ncomparison ...</pre>\n"],["Concurrent::Collection::RubyNonConcurrentPriorityQueue","","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html","","<p>@!macro priority_queue\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Collection::SynchronizedMapBackend","","Concurrent/Collection/SynchronizedMapBackend.html","","<p>@!visibility private\n"],["Concurrent::Concern","","Concurrent/Concern.html","",""],["Concurrent::Concern::Deprecation","","Concurrent/Concern/Deprecation.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Concern::Dereferenceable","","Concurrent/Concern/Dereferenceable.html","","<p>Object references in Ruby are mutable. This can lead to serious problems\nwhen the `#value` of a concurrent \n"],["Concurrent::Concern::Logging","","Concurrent/Concern/Logging.html","","<p>Include where logging is needed\n<p>@!visibility private\n"],["Concurrent::Concern::Obligation","","Concurrent/Concern/Obligation.html","",""],["Concurrent::Concern::Observable","","Concurrent/Concern/Observable.html","","<p>The [observer pattern](en.wikipedia.org/wiki/Observer_pattern) is one of\nthe most useful design patterns. \n"],["Concurrent::ConcurrentUpdateError","","Concurrent/ConcurrentUpdateError.html","","<p>@!macro atomic_reference\n"],["Concurrent::CountDownLatch","","Concurrent/CountDownLatch.html","","<p>@!macro [attach] count_down_latch\n\n<pre>A synchronization object that allows one thread to wait on multiple ...</pre>\n"],["Concurrent::CyclicBarrier","","Concurrent/CyclicBarrier.html","","<p>A synchronization aid that allows a set of threads to all wait for each\nother to reach a common barrier \n"],["Concurrent::Delay","","Concurrent/Delay.html","","<p>Lazy evaluation of a block yielding an immutable result. Useful for\nexpensive operations that may never \n"],["Concurrent::DependencyCounter","","Concurrent/DependencyCounter.html","",""],["Concurrent::Edge","","Concurrent/Edge.html","","<p>A submodule for unstable, highly experimental features that are likely to\nchange often and which may \n"],["Concurrent::Event","","Concurrent/Event.html","","<p>Old school kernel-style event reminiscent of Win32 programming in C++.\n<p>When an `Event` is created it is \n"],["Concurrent::Exchanger","","Concurrent/Exchanger.html","","<p>@!macro exchanger\n"],["Concurrent::ExecutorService","","Concurrent/ExecutorService.html","","<p>@!macro executor_service_public_api @!visibility private\n"],["Concurrent::FixedThreadPool","","Concurrent/FixedThreadPool.html","","<p>@!macro [attach] fixed_thread_pool\n\n<pre>A thread pool that reuses a fixed number of threads operating off an ...</pre>\n"],["Concurrent::Future","","Concurrent/Future.html","","<p>{include:file:doc/future.md}\n<p>@!macro copy_options\n<p>@see ruby-doc.org/stdlib-2.1.1/libdoc/observer/rdoc/Observable.html \n"],["Concurrent::Hash","","Concurrent/Hash.html","","<p>@!macro concurrent_hash\n"],["Concurrent::IVar","","Concurrent/IVar.html","","<p>An `IVar` is like a future that you can assign. As a future is a value that\nis being computed that you \n"],["Concurrent::ImmediateExecutor","","Concurrent/ImmediateExecutor.html","","<p>An executor service which runs all operations on the current thread,\nblocking as necessary. Operations \n"],["Concurrent::ImmutableStruct","","Concurrent/ImmutableStruct.html","","<p>A thread-safe, immutable variation of Ruby&#39;s standard `Struct`.\n<p>@see ruby-doc.org/core-2.2.0/Struct.html \n"],["Concurrent::IndirectImmediateExecutor","","Concurrent/IndirectImmediateExecutor.html","","<p>An executor service which runs all operations on a new thread, blocking\nuntil it completes. Operations \n"],["Concurrent::JavaAtomicReference","","Concurrent/JavaAtomicReference.html","","<p>@!macro atomic_reference\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::JavaCountDownLatch","","Concurrent/JavaCountDownLatch.html","","<p>@!macro count_down_latch @!visibility private @!macro\ninternal_implementation_note\n"],["Concurrent::JavaExchanger","","Concurrent/JavaExchanger.html","","<p>@!macro exchanger @!macro internal_implementation_note @!visibility private\n"],["Concurrent::JavaExecutorService","","Concurrent/JavaExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::JavaExecutorService::Job","","Concurrent/JavaExecutorService/Job.html","",""],["Concurrent::JavaSingleThreadExecutor","","Concurrent/JavaSingleThreadExecutor.html","","<p>@!macro single_thread_executor @!macro abstract_executor_service_public_api\n@!visibility private\n"],["Concurrent::JavaThreadLocalVar","","Concurrent/JavaThreadLocalVar.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::JavaThreadPoolExecutor","","Concurrent/JavaThreadPoolExecutor.html","","<p>@!macro thread_pool_executor @!macro thread_pool_options @!visibility\nprivate\n"],["Concurrent::LazyRegister","","Concurrent/LazyRegister.html","","<p>Hash-like collection that store lazys evaluated values.\n<p>@example\n\n<pre>register = Concurrent::LazyRegister.new ...</pre>\n"],["Concurrent::MVar","","Concurrent/MVar.html","","<p>An `MVar` is a synchronized single element container. They are empty or\ncontain one item. Taking a value \n"],["Concurrent::Map","","Concurrent/Map.html","","<p>`Concurrent::Map` is a hash-like object and should have much better\nperformance characteristics, especially \n"],["Concurrent::Maybe","","Concurrent/Maybe.html","","<p>A `Maybe` encapsulates an optional value. A `Maybe` either contains a value\nof (represented as `Just`), \n"],["Concurrent::MutableStruct","","Concurrent/MutableStruct.html","","<p>An thread-safe variation of Ruby&#39;s standard `Struct`. Values can be set\nat construction or safely \n"],["Concurrent::MutexAtomicBoolean","","Concurrent/MutexAtomicBoolean.html","","<p>@!macro atomic_boolean @!visibility private @!macro\ninternal_implementation_note\n"],["Concurrent::MutexAtomicFixnum","","Concurrent/MutexAtomicFixnum.html","","<p>@!macro atomic_fixnum @!visibility private @!macro\ninternal_implementation_note\n"],["Concurrent::MutexAtomicReference","","Concurrent/MutexAtomicReference.html","","<p>@!macro atomic_reference\n<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::MutexCountDownLatch","","Concurrent/MutexCountDownLatch.html","","<p>@!macro count_down_latch @!visibility private @!macro\ninternal_implementation_note\n"],["Concurrent::MutexSemaphore","","Concurrent/MutexSemaphore.html","","<p>@!macro semaphore @!visibility private @!macro internal_implementation_note\n"],["Concurrent::Options","","Concurrent/Options.html","","<p>@!visibility private\n"],["Concurrent::Process","","Concurrent/Process.html","",""],["Concurrent::Promise","","Concurrent/Promise.html","","<p>Promises are inspired by the JavaScript\n[Promises/A](wiki.commonjs.org/wiki/Promises/A) and [Promises/A+]( \n"],["Concurrent::RbxAtomicReference","","Concurrent/RbxAtomicReference.html","","<p>@!macro atomic_reference\n<p>@note Extends `Rubinius::AtomicReference` version adding aliases\n\n<pre>and numeric logic.</pre>\n"],["Concurrent::ReadWriteLock","","Concurrent/ReadWriteLock.html","","<p>Ruby read-write lock implementation\n<p>Allows any number of concurrent readers, but only one concurrent writer \n"],["Concurrent::ReentrantReadWriteLock","","Concurrent/ReentrantReadWriteLock.html","","<p>Re-entrant read-write lock implementation\n<p>Allows any number of concurrent readers, but only one concurrent \n"],["Concurrent::RubyExchanger","","Concurrent/RubyExchanger.html","","<p>@!macro exchanger @!macro internal_implementation_note @!visibility private\n"],["Concurrent::RubyExchanger::Node","","Concurrent/RubyExchanger/Node.html","",""],["Concurrent::RubyExecutorService","","Concurrent/RubyExecutorService.html","","<p>@!macro abstract_executor_service_public_api @!visibility private\n"],["Concurrent::RubySingleThreadExecutor","","Concurrent/RubySingleThreadExecutor.html","","<p>@!macro single_thread_executor @!macro abstract_executor_service_public_api\n@!visibility private\n"],["Concurrent::RubyThreadLocalVar","","Concurrent/RubyThreadLocalVar.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::RubyThreadPoolExecutor","","Concurrent/RubyThreadPoolExecutor.html","","<p>@!macro thread_pool_executor @!macro thread_pool_options @!visibility\nprivate\n"],["Concurrent::RubyThreadPoolExecutor::Worker","","Concurrent/RubyThreadPoolExecutor/Worker.html","","<p>@!visibility private\n"],["Concurrent::SafeTaskExecutor","","Concurrent/SafeTaskExecutor.html","","<p>A simple utility class that executes a callable and returns and array of\nthree elements: success - indicating \n"],["Concurrent::ScheduledTask","","Concurrent/ScheduledTask.html","","<p>`ScheduledTask` is a close relative of `Concurrent::Future` but with one\nimportant difference: A `Future` \n"],["Concurrent::Semaphore","","Concurrent/Semaphore.html","","<p>@!macro [attach] semaphore\n\n<pre>A counting semaphore. Conceptually, a semaphore maintains a set of\npermits. ...</pre>\n"],["Concurrent::SerialExecutorService","","Concurrent/SerialExecutorService.html","","<p>Indicates that the including `ExecutorService` guarantees that all\noperations will occur in the order \n"],["Concurrent::SerializedExecution","","Concurrent/SerializedExecution.html","","<p>Ensures passed jobs in a serialized order never running at the same time.\n"],["Concurrent::SerializedExecutionDelegator","","Concurrent/SerializedExecutionDelegator.html","","<p>A wrapper/delegator for any `ExecutorService` that guarantees serialized\nexecution of tasks.\n<p>@see [SimpleDelegator]( \n"],["Concurrent::SettableStruct","","Concurrent/SettableStruct.html","","<p>An thread-safe, write-once variation of Ruby&#39;s standard `Struct`. Each\nmember can have its value \n"],["Concurrent::SimpleExecutorService","","Concurrent/SimpleExecutorService.html","","<p>An executor service in which every operation spawns a new, independently\noperating thread.\n<p>This is perhaps \n"],["Concurrent::SingleThreadExecutor","","Concurrent/SingleThreadExecutor.html","","<p>@!macro [attach] single_thread_executor\n\n<pre>A thread pool with a single thread an unlimited queue. Should ...</pre>\n"],["Concurrent::Synchronization","","Concurrent/Synchronization.html","","<p>{include:file:doc/synchronization.md}\n{include:file:doc/synchronization-notes.md}\n"],["Concurrent::Synchronization::AbstractLockableObject","","Concurrent/Synchronization/AbstractLockableObject.html","","<p>@!visibility private\n"],["Concurrent::Synchronization::AbstractObject","","Concurrent/Synchronization/AbstractObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::AbstractStruct","","Concurrent/Synchronization/AbstractStruct.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Condition","","Concurrent/Synchronization/Condition.html","",""],["Concurrent::Synchronization::JRubyAttrVolatile","","Concurrent/Synchronization/JRubyAttrVolatile.html","",""],["Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods","","Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::JRubyLockableObject","","Concurrent/Synchronization/JRubyLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::JRubyObject","","Concurrent/Synchronization/JRubyObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Lock","","Concurrent/Synchronization/Lock.html","",""],["Concurrent::Synchronization::LockableObject","","Concurrent/Synchronization/LockableObject.html","","\n<pre>Safe synchronization under any Ruby implementation.\nIt provides methods like {#synchronize}, {#wait}, ...</pre>\n"],["Concurrent::Synchronization::MriAttrVolatile","","Concurrent/Synchronization/MriAttrVolatile.html","",""],["Concurrent::Synchronization::MriAttrVolatile::ClassMethods","","Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::MriLockableObject","","Concurrent/Synchronization/MriLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::MriMonitorLockableObject","","Concurrent/Synchronization/MriMonitorLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::MriMutexLockableObject","","Concurrent/Synchronization/MriMutexLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::MriObject","","Concurrent/Synchronization/MriObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::Object","","Concurrent/Synchronization/Object.html","","<p>Abstract object providing final, volatile, ans CAS extensions to build\nother concurrent abstractions. \n"],["Concurrent::Synchronization::RbxAttrVolatile","","Concurrent/Synchronization/RbxAttrVolatile.html","",""],["Concurrent::Synchronization::RbxAttrVolatile::ClassMethods","","Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::RbxLockableObject","","Concurrent/Synchronization/RbxLockableObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::RbxObject","","Concurrent/Synchronization/RbxObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::Synchronization::TruffleAttrVolatile","","Concurrent/Synchronization/TruffleAttrVolatile.html","",""],["Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods","","Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html","",""],["Concurrent::Synchronization::TruffleLockableObject","","Concurrent/Synchronization/TruffleLockableObject.html","",""],["Concurrent::Synchronization::TruffleObject","","Concurrent/Synchronization/TruffleObject.html","","<p>@!visibility private @!macro internal_implementation_note\n"],["Concurrent::SynchronizedDelegator","","Concurrent/SynchronizedDelegator.html","","<p>This class provides a trivial way to synchronize all calls to a given\nobject by wrapping it with a `Delegator` \n"],["Concurrent::TVar","","Concurrent/TVar.html","","<p>A `TVar` is a transactional variable - a single-element container that is\nused as part of a transaction \n"],["Concurrent::ThreadLocalVar","","Concurrent/ThreadLocalVar.html","","<p>@!macro [attach] thread_local_var\n\n<pre>A `ThreadLocalVar` is a variable where the value is different for each ...</pre>\n"],["Concurrent::ThreadPoolExecutor","","Concurrent/ThreadPoolExecutor.html","","<p>@!macro [attach] thread_pool_executor\n\n<pre>An abstraction composed of one or more threads and a task queue. ...</pre>\n"],["Concurrent::ThreadSafe","","Concurrent/ThreadSafe.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util","","Concurrent/ThreadSafe/Util.html","","<p>@!visibility private\n<p>@!visibility private\n<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::Adder","","Concurrent/ThreadSafe/Util/Adder.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.LondAdder class version 1.8\navailable in public domain.\n<p>Original \n"],["Concurrent::ThreadSafe::Util::CheapLockable","","Concurrent/ThreadSafe/Util/CheapLockable.html","","<p>Provides a cheapest possible (mainly in terms of memory usage)\n<code>Mutex</code> with the <code>ConditionVariable</code> bundled \n"],["Concurrent::ThreadSafe::Util::PowerOfTwoTuple","","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html","","<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::Striped64","","Concurrent/ThreadSafe/Util/Striped64.html","","<p>A Ruby port of the Doug Lea&#39;s jsr166e.Striped64 class version 1.6\navailable in public domain.\n<p>Original \n"],["Concurrent::ThreadSafe::Util::Striped64::Cell","","Concurrent/ThreadSafe/Util/Striped64/Cell.html","","<p>Padded variant of AtomicLong supporting only raw accesses plus CAS. The\n<code>value</code> field is placed between \n"],["Concurrent::ThreadSafe::Util::Volatile","","Concurrent/ThreadSafe/Util/Volatile.html","","<p>@!visibility private\n"],["Concurrent::ThreadSafe::Util::XorShiftRandom","","Concurrent/ThreadSafe/Util/XorShiftRandom.html","","<p>A xorshift random number (positive +Fixnum+s) generator, provides\nreasonably cheap way to generate thread \n"],["Concurrent::TimerSet","","Concurrent/TimerSet.html","","<p>Executes a collection of tasks, each after a given delay. A master task\nmonitors the set and schedules \n"],["Concurrent::TimerTask","","Concurrent/TimerTask.html","","<p>A very common currency pattern is to run a thread that performs a task at\nregular intervals. The thread \n"],["Concurrent::Transaction","","Concurrent/Transaction.html","",""],["Concurrent::Tuple","","Concurrent/Tuple.html","","<p>A fixed size array with volatile (synchronized, thread safe)\ngetters/setters. Mixes in Ruby&#39;s `Enumerable` \n"],["Concurrent::Utility","","Concurrent/Utility.html","",""],["Concurrent::Utility::EngineDetector","","Concurrent/Utility/EngineDetector.html","","<p>@!visibility private\n"],["Concurrent::Utility::NativeExtensionLoader","","Concurrent/Utility/NativeExtensionLoader.html","","<p>@!visibility private\n"],["Concurrent::Utility::ProcessorCounter","","Concurrent/Utility/ProcessorCounter.html","","<p>@!visibility private\n"],["<<","Concurrent::Agent","Concurrent/Agent.html#method-i-3C-3C","(action)","<p>Dispatches an action to the Agent and returns immediately. Subsequently, in\na thread from a thread pool, \n"],["<<","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-3C-3C","(item)",""],["<<","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-3C-3C","(item)",""],["<<","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-3C-3C","(message)",""],["<<","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<<","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-c-3C-3C","(task)","<p>@!macro executor_service_method_left_shift\n"],["<=>","Concurrent::Maybe","Concurrent/Maybe.html#method-i-3C-3D-3E","(other)","<p>Comparison operator.\n<p>@return [Integer] 0 if self and other are both `Nothing`;\n\n<pre>-1 if self is `Nothing` ...</pre>\n"],["<=>","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-3C-3D-3E","(other)","<p>Comparator which orders by schedule time.\n<p>@!visibility private\n"],["==","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-3D-3D","(other)","<p>@!macro struct_equality\n"],["==","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-3D-3D","(other)","<p>@!macro [attach] struct_equality\n\n<pre>Equality\n\n@return [Boolean] true if other has the same struct subclass ...</pre>\n"],["==","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-3D-3D","(other)","<p>@!macro struct_equality\n"],["[]","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-5B-5D","(key)",""],["[]","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-5B-5D","(key)",""],["[]","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-5B-5D","(key)","<p>WARNING: Mutex_m is a non-reentrant lock, so the synchronized methods are\nnot allowed to call each other. \n"],["[]","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-5B-5D","(member)","<p>@!macro struct_get\n"],["[]","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-5B-5D","(key)","<p>Element reference. Retrieves the value object corresponding to the key\nobject. Returns nil if the key \n"],["[]","Concurrent::Map","Concurrent/Map.html#method-i-5B-5D","(key)",""],["[]","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-5B-5D","(member)","<p>@!macro [attach] struct_get\n\n<pre>Attribute Reference\n\n@param [Symbol, String, Integer] member the string or ...</pre>\n"],["[]","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-5B-5D","(member)","<p>@!macro struct_get\n"],["[]=","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-5B-5D-3D","(key, value)",""],["[]=","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-5B-5D-3D","(member, value)","<p>@!macro [new] struct_set\n\n<pre>Attribute Assignment\n\nSets the value of the given struct member or the member ...</pre>\n"],["[]=","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-5B-5D-3D","(member, value)","<p>@!macro struct_set\n<p>@raise [Concurrent::ImmutabilityError] if the given member has already been\nset\n"],["_compare_and_set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-_compare_and_set","(old_value, new_value)","<p>@!macro atomic_reference_method_compare_and_set\n"],["_get","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-_get","(key)",""],["_mon_initialize","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-i-_mon_initialize","()",""],["_set","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-_set","(key, value)",""],["abort","Concurrent::Transaction","Concurrent/Transaction.html#method-i-abort","()",""],["abort_transaction","Concurrent","Concurrent.html#method-c-abort_transaction","()","<p>Abort a currently running transaction - see `Concurrent::atomically`.\n"],["abort_transaction","Concurrent","Concurrent.html#method-i-abort_transaction","()","<p>Abort a currently running transaction - see `Concurrent::atomically`.\n"],["acquire","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-acquire","(permits = 1)","<p>@!macro semaphore_method_acquire\n"],["acquire_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-acquire_read_lock","()","<p>Acquire a read lock. If a write lock has been acquired will block until it\nis released. Will not block \n"],["acquire_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-acquire_read_lock","()","<p>Acquire a read lock. If a write lock is held by another thread, will block\nuntil it is released.\n<p>@return \n"],["acquire_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-acquire_write_lock","()","<p>Acquire a write lock. Will block and wait for all active readers and\nwriters.\n<p>@return [Boolean] true if \n"],["acquire_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-acquire_write_lock","()","<p>Acquire a write lock. Will block and wait for all active readers and\nwriters.\n<p>@return [Boolean] true if \n"],["add","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-add","(handler_id = nil, &handler)","<p>Add a handler to be run at `Kernel#at_exit` @param [Object] handler_id\noptionally provide an id, if allready \n"],["add","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-add","(key, &block)",""],["add","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-add","(x)","<p>Adds the given value.\n"],["add_observer","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro observable_add_observer\n"],["add_observer","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro observable_add_observer\n"],["add_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>@!macro [attach] observable_add_observer\n\n<pre>Adds an observer to this set. If a block is passed, the observer ...</pre>\n"],["add_observer","Concurrent::IVar","Concurrent/IVar.html#method-i-add_observer","(observer = nil, func = :update, &block)","<p>Add an observer on this object that will receive notification on update.\n<p>Upon completion the `IVar` will \n"],["aggregate","Concurrent::Promise","Concurrent/Promise.html#method-c-aggregate","(method, *promises)","<p>Aggregate a collection of zero or more promises under a composite promise,\nexecute the aggregated promises \n"],["all?","Concurrent::Promise","Concurrent/Promise.html#method-c-all-3F","(*promises)","<p>Aggregates a collection of promises and executes the `then` condition if\nall aggregated promises succeed. \n"],["allocate","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-c-allocate","()",""],["allocate_storage","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allocate_storage","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allocate_storage","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-allocate_storage","()","<p>@!visibility private\n"],["allow_c_extensions?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-allow_c_extensions-3F","()",""],["any?","Concurrent::Promise","Concurrent/Promise.html#method-c-any-3F","(*promises)","<p>Aggregates a collection of promises and executes the `then` condition if\nany aggregated promises succeed. \n"],["apply_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-apply_deref_options","(value)","<p>@!visibility private\n"],["async","Concurrent::Async","Concurrent/Async.html#method-i-async","()","<p>Causes the chained method call to be performed asynchronously on the\nobject&#39;s thread. The delegated \n"],["atomically","Concurrent","Concurrent.html#method-i-atomically","()","<p>Run a block that reads and writes `TVar`s as a single atomic transaction.\nWith respect to the value of \n"],["atomically","Concurrent","Concurrent.html#method-c-atomically","()","<p>Run a block that reads and writes `TVar`s as a single atomic transaction.\nWith respect to the value of \n"],["attempt_compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_compute","(key, hash, current_table, i, node, node_hash)",""],["attempt_get_and_set","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_get_and_set","(key, value, hash, current_table, i, node, node_hash)",""],["attempt_internal_compute_if_absent","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_internal_compute_if_absent","(key, hash, current_table, i, node, node_hash)",""],["attempt_internal_replace","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-attempt_internal_replace","(key, expected_old_value, hash, current_table, i, node, node_hash)",""],["attr_atomic","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-attr_atomic","(*names)","<p>Creates methods for reading and writing to a instance variable with\nvolatile (Java) semantic as {.attr_volatile} \n"],["attr_volatile","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-c-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::JRubyAttrVolatile::ClassMethods","Concurrent/Synchronization/JRubyAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::MriAttrVolatile::ClassMethods","Concurrent/Synchronization/MriAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::RbxAttrVolatile::ClassMethods","Concurrent/Synchronization/RbxAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods","Concurrent/Synchronization/TruffleAttrVolatile/ClassMethods.html#method-i-attr_volatile","(*names)",""],["attr_volatile","Concurrent::ThreadSafe::Util::Volatile","Concurrent/ThreadSafe/Util/Volatile.html#method-i-attr_volatile","(*attr_names)","<p>Provides <code>volatile</code> (in the JVM&#39;s sense) attribute accessors\nimplemented atop of +Concurrent::AtomicReference+. \n"],["auto_terminate=","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-auto_terminate-3D","(value)","<p>@!macro executor_service_method_auto_terminate_setter\n"],["auto_terminate?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-auto_terminate-3F","()","<p>@!macro executor_service_method_auto_terminate_question\n"],["available_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-available_permits","()","<p>@!macro semaphore_method_available_permits\n"],["await","Concurrent::Agent","Concurrent/Agent.html#method-i-await","()","<p>Blocks the current thread (indefinitely!) until all actions dispatched thus\nfar, from this thread or \n"],["await","Concurrent::Agent","Concurrent/Agent.html#method-c-await","(*agents)","<p>Blocks the current thread (indefinitely!) until all actions dispatched thus\nfar to all the given Agents \n"],["await","Concurrent::Async","Concurrent/Async.html#method-i-await","()","<p>Causes the chained method call to be performed synchronously on the current\nthread. The delegated will \n"],["await_for","Concurrent::Agent","Concurrent/Agent.html#method-c-await_for","(timeout, *agents)","<p>Blocks the current thread until all actions dispatched thus far to all the\ngiven Agents, from this thread \n"],["await_for","Concurrent::Agent","Concurrent/Agent.html#method-i-await_for","(timeout)","<p>Blocks the current thread until all actions dispatched thus far, from this\nthread or nested by the Agent \n"],["await_for!","Concurrent::Agent","Concurrent/Agent.html#method-c-await_for-21","(timeout, *agents)","<p>Blocks the current thread until all actions dispatched thus far to all the\ngiven Agents, from this thread \n"],["await_for!","Concurrent::Agent","Concurrent/Agent.html#method-i-await_for-21","(timeout)","<p>Blocks the current thread until all actions dispatched thus far, from this\nthread or nested by the Agent \n"],["bind","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-bind","(value, &block)","<p>@!macro thread_local_var_method_bind\n"],["bind","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-bind","(value, &block)","<p>@!macro thread_local_var_method_bind\n"],["bind","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-bind","(value, &block)","<p>@!macro thread_local_var_method_bind\n"],["borrow","Concurrent::MVar","Concurrent/MVar.html#method-i-borrow","(timeout = nil)","<p>acquires lock on the from an `MVAR`, yields the value to provided block,\nand release lock. A timeout \n"],["broadcast","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-broadcast","()",""],["broadcast","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-broadcast","()",""],["broken?","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-broken-3F","()","<p>A barrier can be broken when:\n<p>a thread called the `reset` method while at least one other thread was\nwaiting \n"],["c_extensions_loaded?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-c_extensions_loaded-3F","()",""],["call","Concurrent::Async","Concurrent/Async.html#method-i-call","()",""],["call_dataflow","Concurrent","Concurrent.html#method-i-call_dataflow","(method, executor, *inputs, &block)",""],["call_dataflow","Concurrent","Concurrent.html#method-c-call_dataflow","(method, executor, *inputs, &block)",""],["call_job","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-call_job","(job)",""],["can_overflow?","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n<p>@note Always returns `false`\n"],["can_overflow?","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n"],["can_overflow?","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-can_overflow-3F","()","<p>@!macro executor_service_method_can_overflow_question\n"],["cancel","Concurrent::Future","Concurrent/Future.html#method-i-cancel","()","<p>Attempt to cancel the operation if it has not already processed. The\noperation can only be cancelled \n"],["cancel","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-cancel","()","<p>Cancel this task and prevent it from executing. A task can only be\ncancelled if it is pending or unscheduled. \n"],["cancelled?","Concurrent::Future","Concurrent/Future.html#method-i-cancelled-3F","()","<p>Has the operation been successfully cancelled?\n<p>@return [Boolean]\n"],["cancelled?","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-cancelled-3F","()","<p>Has the task been cancelled?\n<p>@return [Boolean] true if the task is in the given state else false\n"],["cas","Concurrent::Tuple","Concurrent/Tuple.html#method-i-cas","(i, old_value, new_value)",""],["cas_base_computed","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-cas_base_computed","()",""],["cas_computed","Concurrent::ThreadSafe::Util::Striped64::Cell","Concurrent/ThreadSafe/Util/Striped64/Cell.html#method-i-cas_computed","()",""],["cas_new_node","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-cas_new_node","(i, hash, key, value)",""],["cast","Concurrent::Async","Concurrent/Async.html#method-i-cast","()",""],["catch","Concurrent::Promise","Concurrent/Promise.html#method-i-catch","(&block)",""],["cheap_broadcast","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_broadcast","()",""],["cheap_synchronize","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_synchronize","()","<p>Making use of the Rubinius&#39; ability to lock via object headers to avoid\nthe overhead of the extra \n"],["cheap_wait","Concurrent::ThreadSafe::Util::CheapLockable","Concurrent/ThreadSafe/Util/CheapLockable.html#method-i-cheap_wait","()",""],["check_for_resize","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-check_for_resize","()","<p>If table is too small and not already resizing, creates next table and\ntransfers bins. Rechecks occupancy \n"],["clear","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-clear","()","<p>Implementation for clear. Steps through each bin, removing all nodes.\n"],["clear","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-clear","()","<p>@!macro priority_queue_method_clear\n"],["clear","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-clear","()",""],["clear","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-clear","()",""],["clear","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-clear","()","<p>@!macro priority_queue_method_clear\n"],["clear","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-clear","()",""],["clear_observers_and_return_old","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-clear_observers_and_return_old","()",""],["commit","Concurrent::Transaction","Concurrent/Transaction.html#method-i-commit","()",""],["compare_and_set","Concurrent::Atom","Concurrent/Atom.html#method-i-compare_and_set","(old_value, new_value)","<p>Atomically sets the value of atom to the new value if and only if the\ncurrent value of the atom is identical \n"],["compare_and_set","Concurrent::AtomicNumericCompareAndSetWrapper","Concurrent/AtomicNumericCompareAndSetWrapper.html#method-i-compare_and_set","(old_value, new_value)","<p>@!macro atomic_reference_method_compare_and_set\n"],["compare_and_set","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-compare_and_set","(expect, update)","<p>@!macro atomic_fixnum_method_compare_and_set\n"],["compare_and_set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-compare_and_set","(i, old_value, new_value)","<p>Set the value at the given index to the new value if and only if the\ncurrent value matches the given \n"],["compare_and_set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-compare_and_set_state","(next_state, *expected_current)","<p>Atomic compare and set operation State is set to `next_state` only if\n`current state == expected_current \n"],["compare_and_swap","Concurrent::AtomicNumericCompareAndSetWrapper","Concurrent/AtomicNumericCompareAndSetWrapper.html#method-i-compare_and_swap","(old_value, new_value)",""],["complete","Concurrent::IVar","Concurrent/IVar.html#method-i-complete","(success, value, reason)","<p>@!visibility private\n"],["complete","Concurrent::Promise","Concurrent/Promise.html#method-i-complete","(success, value, reason)","<p>@!visibility private\n"],["complete?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-complete-3F","()","<p>Has the obligation completed processing?\n<p>@return [Boolean]\n"],["complete_without_notification","Concurrent::IVar","Concurrent/IVar.html#method-i-complete_without_notification","(success, value, reason)","<p>@!visibility private\n"],["completed_task_count","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-completed_task_count","()","<p>@!macro thread_pool_executor_attr_reader_completed_task_count\n"],["completed_task_count","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-completed_task_count","()","<p>@!macro thread_pool_executor_attr_reader_completed_task_count\n"],["compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute","(key)",""],["compute","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute","(key)",""],["compute_if_absent","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_absent","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute_if_absent","(key)",""],["compute_if_present","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-compute_if_present","(key)",""],["compute_if_present","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-compute_if_present","(key)",""],["compute_physical_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-compute_physical_processor_count","()",""],["compute_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-compute_processor_count","()",""],["count","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-count","()","<p>@!macro count_down_latch_method_count\n"],["count","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-count","()","<p>@!macro count_down_latch_method_count\n"],["count_down","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-count_down","()","<p>@!macro count_down_latch_method_count_down\n"],["count_down","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-count_down","()","<p>@!macro count_down_latch_method_count_down\n"],["count_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-count_observers","()","<p>@!macro observable_count_observers\n"],["count_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-count_observers","()","<p>@!macro observable_count_observers\n"],["count_observers","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-count_observers","()","<p>@!macro [attach] observable_count_observers\n\n<pre>Return the number of observers associated with this object. ...</pre>\n"],["create_stdlib_logger","Concurrent","Concurrent.html#method-c-create_stdlib_logger","(level = Logger::FATAL, output = $stderr)","<p>@return [Logger] Logger with provided level and output.\n"],["create_worker","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-create_worker","(queue, pool, idletime)",""],["current","Concurrent::Transaction","Concurrent/Transaction.html#method-c-current","()",""],["current=","Concurrent::Transaction","Concurrent/Transaction.html#method-c-current-3D","(transaction)",""],["dataflow","Concurrent","Concurrent.html#method-i-dataflow","(*inputs, &block)","<p>{include:file:doc/dataflow.md}\n<p>@param [Future] inputs zero or more `Future` operations that this dataflow\n\n"],["dataflow","Concurrent","Concurrent.html#method-c-dataflow","(*inputs, &block)","<p>{include:file:doc/dataflow.md}\n<p>@param [Future] inputs zero or more `Future` operations that this dataflow\n\n"],["dataflow!","Concurrent","Concurrent.html#method-c-dataflow-21","(*inputs, &block)",""],["dataflow!","Concurrent","Concurrent.html#method-i-dataflow-21","(*inputs, &block)",""],["dataflow_with","Concurrent","Concurrent.html#method-c-dataflow_with","(executor, *inputs, &block)",""],["dataflow_with","Concurrent","Concurrent.html#method-i-dataflow_with","(executor, *inputs, &block)",""],["dataflow_with!","Concurrent","Concurrent.html#method-i-dataflow_with-21","(executor, *inputs, &block)",""],["dataflow_with!","Concurrent","Concurrent.html#method-c-dataflow_with-21","(executor, *inputs, &block)",""],["decrement","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-decrement","(delta = 1)","<p>@!macro atomic_fixnum_method_decrement\n"],["decrement","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-decrement","()",""],["decrement_size","Concurrent::Collection","Concurrent/Collection.html#method-i-decrement_size","(by = 1)",""],["define_initialize_volatile_with_cas","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-define_initialize_volatile_with_cas","()",""],["define_struct_class","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-c-define_struct_class","(parent, base, name, members, &block)","<p>@!visibility private\n"],["delete","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-delete","(handler_id)","<p>Delete a handler by handler_id @return [true, false]\n"],["delete","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-delete","(item)","<p>@!macro priority_queue_method_delete\n"],["delete","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-delete","(item)","<p>@!macro priority_queue_method_delete\n"],["delete","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-delete","(key)",""],["delete","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-delete","(key)",""],["delete_node_at","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-delete_node_at","(i, node, predecessor_node)",""],["delete_observer","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-delete_observer","(observer)","<p>@!macro observable_delete_observer\n"],["delete_observer","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-delete_observer","(observer)","<p>@!macro observable_delete_observer\n"],["delete_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-delete_observer","(observer)","<p>@!macro [attach] observable_delete_observer\n\n<pre>Remove `observer` as an observer on this object so that it ...</pre>\n"],["delete_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-delete_observers","()","<p>@!macro observable_delete_observers\n"],["delete_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-delete_observers","()","<p>@!macro observable_delete_observers\n"],["delete_observers","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-delete_observers","()","<p>@!macro [attach] observable_delete_observers\n\n<pre>Remove all observers associated with this object.\n\n@return ...</pre>\n"],["delete_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-delete_pair","(key, value)",""],["delete_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-delete_pair","(key, value)",""],["deprecated","Concurrent::Concern::Deprecation","Concurrent/Concern/Deprecation.html#method-i-deprecated","(message, strip = 2)",""],["deprecated_method","Concurrent::Concern::Deprecation","Concurrent/Concern/Deprecation.html#method-i-deprecated_method","(old_name, new_name)",""],["deq","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-deq","()",""],["deq","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-deq","()",""],["deref","Concurrent::Agent","Concurrent/Agent.html#method-i-deref","()",""],["deref","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-deref","()",""],["disable_at_exit_handlers!","Concurrent","Concurrent.html#method-c-disable_at_exit_handlers-21","()","<p>Disables AtExit handlers including pool auto-termination handlers. When\ndisabled it will be the application \n"],["do_exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["do_exchange","Concurrent::JavaExchanger","Concurrent/JavaExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["do_exchange","Concurrent::RubyExchanger","Concurrent/RubyExchanger.html#method-i-do_exchange","(value, timeout)","<p>@!macro exchanger_method_do_exchange\n<p>@return [Object, CANCEL] the value exchanged by the other thread; \n"],["down","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-down","(delta = 1)",""],["drain_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-drain_permits","()","<p>@!macro semaphore_method_drain_permits\n\n<pre>Acquires and returns all permits that are immediately available. ...</pre>\n"],["duplicate_and_clear_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-duplicate_and_clear_observers","()",""],["duplicate_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-duplicate_observers","()",""],["dupped_backend","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-dupped_backend","()",""],["dupped_backend","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-dupped_backend","()",""],["each","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-each","(&block)","<p>@!macro struct_each\n"],["each","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-each","(&block)","<p>@!macro [attach] struct_each\n\n<pre>Yields the value of each struct member in order. If no block is given\nan ...</pre>\n"],["each","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-each","(&block)","<p>@!macro struct_each\n"],["each","Concurrent::Tuple","Concurrent/Tuple.html#method-i-each","()","<p>Calls the given block once for each element in self, passing that element\nas a parameter.\n<p>@yieldparam \n"],["each_key","Concurrent::Map","Concurrent/Map.html#method-i-each_key","()",""],["each_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-each_pair","()",""],["each_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-each_pair","()",""],["each_pair","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-each_pair","(&block)","<p>@!macro struct_each_pair\n"],["each_pair","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-each_pair","(&block)","<p>@!macro [attach] struct_each_pair\n\n<pre>Yields the name and value of each struct member in order. If no block ...</pre>\n"],["each_pair","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-each_pair","(&block)","<p>@!macro struct_each_pair\n"],["each_value","Concurrent::Map","Concurrent/Map.html#method-i-each_value","()",""],["empty?","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-empty-3F","()",""],["empty?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-empty-3F","()","<p>@!macro priority_queue_method_empty\n"],["empty?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-empty-3F","()","<p>@!macro priority_queue_method_empty\n"],["empty?","Concurrent::MVar","Concurrent/MVar.html#method-i-empty-3F","()","<p>Returns if the `MVar` is currently empty.\n"],["empty?","Concurrent::Map","Concurrent/Map.html#method-i-empty-3F","()",""],["enabled=","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-enabled-3D","(value)","<p>Configure if it runs during `Kernel#at_exit`\n"],["enabled?","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-enabled-3F","()","<p>Will it run during `Kernel#at_exit`\n"],["enq","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-enq","(item)",""],["enq","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-enq","(item)",""],["enqueue_action_job","Concurrent::Agent","Concurrent/Agent.html#method-i-enqueue_action_job","(action, args, executor)",""],["enqueue_await_job","Concurrent::Agent","Concurrent/Agent.html#method-i-enqueue_await_job","(latch)",""],["ensure_safe_initialization_when_final_fields_are_present","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-ensure_safe_initialization_when_final_fields_are_present","()","<p>For testing purposes, quite slow. Injects assert code to new method which\nwill raise if class instance \n"],["error","Concurrent::Agent","Concurrent/Agent.html#method-i-error","()","<p>When {#failed?} and {#error_mode} is `:fail`, returns the error object\nwhich caused the failure, else \n"],["event","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-event","()","<p>@!visibility private\n"],["exception","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-exception","(*args)","<p>@example allows Obligation to be risen\n\n<pre>rejected_ivar = Ivar.new.fail\nraise rejected_ivar</pre>\n"],["exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-exchange","(value, timeout = nil)","<p>@!macro [attach] exchanger_method_do_exchange\n\n<pre>Waits for another thread to arrive at this exchange point ...</pre>\n"],["exchange!","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-exchange-21","(value, timeout = nil)","<p>@!macro exchanger_method_do_exchange\n<p>@!macro [attach] exchanger_method_exchange_bang\n\n<pre>On timeout a {Concurrent::TimeoutError} ...</pre>\n"],["execute","Concurrent::Future","Concurrent/Future.html#method-c-execute","(opts = {}, &block)","<p>Create a new `Future` object with the given block, execute it, and return\nthe `:pending` object.\n<p>@yield \n"],["execute","Concurrent::Future","Concurrent/Future.html#method-i-execute","()","<p>Execute an `:unscheduled` `Future`. Immediately sets the state to\n`:pending` and passes the block to \n"],["execute","Concurrent::Promise","Concurrent/Promise.html#method-c-execute","(opts = {}, &block)","<p>Create a new `Promise` object with the given block, execute it, and return\nthe `:pending` object.\n<p>@!macro \n"],["execute","Concurrent::Promise","Concurrent/Promise.html#method-i-execute","()","<p>Execute an `:unscheduled` `Promise`. Immediately sets the state to\n`:pending` and passes the block to \n"],["execute","Concurrent::SafeTaskExecutor","Concurrent/SafeTaskExecutor.html#method-i-execute","(*args)","<p>@return [Array]\n"],["execute","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-c-execute","(delay, opts = {}, &task)","<p>Create a new `ScheduledTask` object with the given block, execute it, and\nreturn the `:pending` object. \n"],["execute","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-execute","()","<p>Execute an `:unscheduled` `ScheduledTask`. Immediately sets the state to\n`:pending` and starts counting \n"],["execute","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execute","()","<p>Execute a previously created `TimerTask`.\n<p>@return [TimerTask] a reference to `self`\n<p>@example Instance and \n"],["execute","Concurrent::TimerTask","Concurrent/TimerTask.html#method-c-execute","(opts = {}, &task)","<p>Create and execute a new `TimerTask`.\n<p>@!macro timer_task_initialize\n<p>@example\n"],["execute_next_job","Concurrent::Agent","Concurrent/Agent.html#method-i-execute_next_job","()",""],["execute_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execute_task","(completion)","<p>@!visibility private\n"],["execution_interval","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execution_interval","()","<p>@!attribute [rw] execution_interval @return [Fixnum] Number of seconds\nafter the task completes before \n"],["execution_interval=","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-execution_interval-3D","(value)","<p>@!attribute [rw] execution_interval @return [Fixnum] Number of seconds\nafter the task completes before \n"],["executor","Concurrent","Concurrent.html#method-c-executor","(executor_identifier)","<p>General access point to global executors. @param [Symbol, Executor]\nexecutor_identifier symbols:\n\n<pre>- :fast ...</pre>\n"],["executor","Concurrent::Options","Concurrent/Options.html#method-c-executor","(executor_identifier)",""],["expand_table_unless_stale","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-expand_table_unless_stale","(current_cells)",""],["fail","Concurrent::IVar","Concurrent/IVar.html#method-i-fail","(reason = StandardError.new)","<p>@!macro [attach] ivar_fail_method\n\n<pre>Set the `IVar` to failed due to some error and wake or notify all threads ...</pre>\n"],["fail","Concurrent::Promise","Concurrent/Promise.html#method-i-fail","(reason = StandardError.new)","<p>@!macro ivar_fail_method\n<p>@raise [Concurrent::PromiseExecutionError] if not the root promise\n"],["failed?","Concurrent::Agent","Concurrent/Agent.html#method-i-failed-3F","()","<p>Is the Agent in a failed state?\n<p>@see {#restart}\n"],["false?","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-false-3F","()","<p>@!macro atomic_boolean_method_false_question\n"],["fetch","Concurrent::Map","Concurrent/Map.html#method-i-fetch","(key, default_value = NULL)","<p>@!macro [attach] map_method_not_atomic\n\n<pre>The &quot;fetch-then-act&quot; methods of `Map` are not atomic. `Map` is ...</pre>\n"],["fetch_or_store","Concurrent::Map","Concurrent/Map.html#method-i-fetch_or_store","(key, default_value = NULL)","<p>@!macro map_method_not_atomic\n"],["find_value_in_node_list","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-find_value_in_node_list","(node, key, hash, pure_hash)",""],["flat_map","Concurrent::Promise","Concurrent/Promise.html#method-i-flat_map","(&block)","<p>Yield the successful result to the block that returns a promise. If that\npromise is also successful the \n"],["force_aquire_lock","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-force_aquire_lock","(table, i)",""],["free?","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-free-3F","()",""],["from","Concurrent::Maybe","Concurrent/Maybe.html#method-c-from","(*args)","<p>Create a new `Maybe` using the given block.\n<p>Runs the given block passing all function arguments to the \n"],["from_list","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-c-from_list","(list, opts = {})","<p>@!macro priority_queue_method_from_list\n"],["from_list","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-c-from_list","(list, opts = {})","<p>@!macro priority_queue_method_from_list\n"],["fulfill","Concurrent::Promise","Concurrent/Promise.html#method-c-fulfill","(value, opts = {})","<p>Create a new `Promise` and fulfill it immediately.\n<p>@!macro executor_and_deref_options\n<p>@!macro promise_init_options \n"],["fulfilled?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-fulfilled-3F","()","<p>Has the obligation been fulfilled?\n<p>@return [Boolean]\n"],["fulfilled?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-fulfilled-3F","()",""],["full?","Concurrent::MVar","Concurrent/MVar.html#method-i-full-3F","()","<p>Returns if the `MVar` currently contains a value.\n"],["full_memory_barrier","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-i-full_memory_barrier","()","<p>@!visibility private @abstract\n"],["full_memory_barrier","Concurrent::Synchronization::MriAttrVolatile","Concurrent/Synchronization/MriAttrVolatile.html#method-i-full_memory_barrier","()",""],["full_memory_barrier","Concurrent::Synchronization::RbxAttrVolatile","Concurrent/Synchronization/RbxAttrVolatile.html#method-i-full_memory_barrier","()",""],["full_memory_barrier","Concurrent::Synchronization::TruffleAttrVolatile","Concurrent/Synchronization/TruffleAttrVolatile.html#method-i-full_memory_barrier","()",""],["get","Concurrent::Map","Concurrent/Map.html#method-i-get","(key)",""],["get","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-get","()","<p>@!macro atomic_reference_method_get\n"],["get","Concurrent::ThreadSafe::Util::XorShiftRandom","Concurrent/ThreadSafe/Util/XorShiftRandom.html#method-i-get","()","<p>Generates an initial non-zero positive <code>Fixnum</code> via\n<code>Kernel.rand</code>.\n"],["get","Concurrent::Tuple","Concurrent/Tuple.html#method-i-get","(i)","<p>Get the value of the element at the given index.\n<p>@param [Integer] i the index from which to retrieve the \n"],["get_and_set","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-get_and_set","(key, value)",""],["get_and_set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-get_and_set","(new_value)","<p>@!macro atomic_reference_method_get_and_set\n"],["get_arguments_from","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-get_arguments_from","(opts = {})","<p>@!visibility private\n"],["get_or_default","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-get_or_default","(key, else_value = nil)",""],["get_or_default","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-get_or_default","(key, default_value)",""],["get_or_default","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-get_or_default","(key, default_value)",""],["get_threadlocal_array","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-get_threadlocal_array","(thread = Thread.current)",""],["get_time","Concurrent","Concurrent.html#method-i-get_time","()","<p>@!visibility private\n"],["global_fast_executor","Concurrent","Concurrent.html#method-c-global_fast_executor","()","<p>Global thread pool optimized for short, fast <strong>operations</strong>.\n<p>@return [ThreadPoolExecutor] the thread pool \n"],["global_immediate_executor","Concurrent","Concurrent.html#method-c-global_immediate_executor","()",""],["global_io_executor","Concurrent","Concurrent.html#method-c-global_io_executor","()","<p>Global thread pool optimized for long, blocking (IO)\n<strong>tasks</strong>.\n<p>@return [ThreadPoolExecutor] the thread pool \n"],["global_logger","Concurrent","Concurrent.html#method-c-global_logger","()",""],["global_logger=","Concurrent","Concurrent.html#method-c-global_logger-3D","(value)",""],["global_timer_set","Concurrent","Concurrent.html#method-c-global_timer_set","()","<p>Global thread pool user for global <strong>timers</strong>.\n<p>@return [Concurrent::TimerSet] the thread pool\n"],["handle_error","Concurrent::Agent","Concurrent/Agent.html#method-i-handle_error","(error)",""],["handle_fallback","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-handle_fallback","(*args)","<p>Handler which executes the `fallback_policy` once the queue size reaches\n`max_queue`.\n<p>@param [Array] args \n"],["handler?","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-handler-3F","(handler_id)","<p>Is handler with handler_id rpesent? @return [true, false]\n"],["handlers","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-handlers","()","<p>@return copy of the handlers\n"],["has_key?","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-has_key-3F","(key)",""],["has_priority?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-has_priority-3F","(item)",""],["has_priority?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-has_priority-3F","(item)",""],["has_waiters?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-has_waiters-3F","()","<p>Queries whether any threads are waiting to acquire the read or write lock.\n<p>@return [Boolean] true if any \n"],["hash_code","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-hash_code","()","<p>A thread-local hash code accessor. The code is initially random, but may be\nset to a different value \n"],["hash_code=","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-hash_code-3D","(hash)",""],["hash_to_index","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-hash_to_index","(hash)",""],["idletime","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-idletime","()","<p>@!macro thread_pool_executor_attr_reader_idletime\n"],["if_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-if_state","(*expected_states)","<p>Executes the block within mutex if current state is included in\nexpected_states\n<p>@return block value if \n"],["include?","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-include-3F","(item)","<p>@!macro priority_queue_method_include\n"],["include?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-include-3F","(item)","<p>@!macro priority_queue_method_include\n"],["included","Concurrent::Async","Concurrent/Async.html#method-c-included","(base)","<p>@!visibility private\n"],["included","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::JRubyAttrVolatile","Concurrent/Synchronization/JRubyAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::MriAttrVolatile","Concurrent/Synchronization/MriAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::RbxAttrVolatile","Concurrent/Synchronization/RbxAttrVolatile.html#method-c-included","(base)",""],["included","Concurrent::Synchronization::TruffleAttrVolatile","Concurrent/Synchronization/TruffleAttrVolatile.html#method-c-included","(base)",""],["incomplete?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-incomplete-3F","()","<p>Is the obligation still awaiting completion of processing?\n<p>@return [Boolean]\n"],["increment","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-increment","(delta = 1)","<p>@!macro atomic_fixnum_method_increment\n"],["increment","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-increment","()",""],["increment_size","Concurrent::Collection","Concurrent/Collection.html#method-i-increment_size","()",""],["index","Concurrent::Map","Concurrent/Map.html#method-i-index","(value)",""],["init_obligation","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-init_obligation","()","<p>@!visibility private\n"],["init_synchronization","Concurrent::Async","Concurrent/Async.html#method-i-init_synchronization","()","<p>Initialize the internal serializer and other stnchronization mechanisms.\n<p>@note This method <strong>must</strong> be called \n"],["initial_delay","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-initial_delay","()","<p>The `delay` value given at instanciation.\n<p>@return [Float] the initial delay.\n"],["initialize_copy","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-initialize_copy","(other)",""],["initialize_copy","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-initialize_copy","(other)",""],["initialize_copy","Concurrent::Map","Concurrent/Map.html#method-i-initialize_copy","(other)",""],["initialize_table","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-initialize_table","()","<p>Initializes table, using the size recorded in <code>size_control</code>.\n"],["initialize_volatile_with_cas","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-i-initialize_volatile_with_cas","()",""],["inspect","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-inspect","()","<p>@!macro struct_inspect\n"],["inspect","Concurrent::Map","Concurrent/Map.html#method-i-inspect","()","<p>override default #inspect() method: firstly, we don&#39;t want to be\nspilling our guts (i-vars), secondly, \n"],["inspect","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-inspect","()","<p>@!macro [attach] struct_inspect\n\n<pre>Describe the contents of this struct in a string.\n\n@return [String] the ...</pre>\n"],["inspect","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-inspect","()","<p>@!macro struct_inspect\n"],["install","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-install","()","<p>install `Kernel#at_exit` callback to execute added handlers\n"],["internal_compute","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-internal_compute","(key, &block)",""],["internal_replace","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-internal_replace","(key, expected_old_value = NULL, &block)","<p>Internal versions of the insertion methods, each a little more complicated\nthan the last. All have the \n"],["internal_reset","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-internal_reset","(initial_value)","<p>Sets base and all <code>cells</code> to the given value.\n"],["item","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-i-item","()",""],["java_extensions_loaded?","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-java_extensions_loaded-3F","()",""],["just","Concurrent::Maybe","Concurrent/Maybe.html#method-c-just","(value)","<p>Create a new `Just` with the given value.\n<p>@param [Object] value The value to set for the new `Maybe` object. \n"],["just?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-just-3F","()","<p>Is this `Maybe` a `Just` (successfully fulfilled with a value)?\n<p>@return [Boolean] True if `Just` or false \n"],["key","Concurrent::Map","Concurrent/Map.html#method-i-key","(value)",""],["key?","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-key-3F","(key)",""],["key?","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-key-3F","(key)",""],["key?","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-key-3F","(key)",""],["key_hash","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-key_hash","(key)",""],["keys","Concurrent::Map","Concurrent/Map.html#method-i-keys","()",""],["kill","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-kill","()","<p>@!macro executor_service_method_kill\n"],["kill","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-kill","()",""],["kill","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-kill","()",""],["kill","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-kill","()",""],["kill","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-kill","()",""],["kill","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-kill","()","<p>@!macro executor_service_method_kill\n"],["kill","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-kill","()","<p>Begin an immediate shutdown. In-progress tasks will be allowed to complete\nbut enqueued tasks will be \n"],["largest_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-largest_length","()","<p>@!macro thread_pool_executor_attr_reader_largest_length\n"],["largest_length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-largest_length","()","<p>@!macro thread_pool_executor_attr_reader_largest_length\n"],["latch","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-i-latch","()",""],["leave_transaction","Concurrent","Concurrent.html#method-i-leave_transaction","()","<p>Leave a transaction without commiting or aborting - see\n`Concurrent::atomically`.\n"],["leave_transaction","Concurrent","Concurrent.html#method-c-leave_transaction","()","<p>Leave a transaction without commiting or aborting - see\n`Concurrent::atomically`.\n"],["length","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-length","()","<p>@!macro priority_queue_method_length\n"],["length","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-length","()","<p>@!macro priority_queue_method_length\n"],["length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-length","()","<p>@!macro thread_pool_executor_attr_reader_length\n"],["length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-length","()","<p>@!macro thread_pool_executor_attr_reader_length\n"],["length","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-length","()","<p>@!macro [attach] struct_length\n\n<pre>Returns the number of struct members.\n\n@return [Fixnum] the number of struct ...</pre>\n"],["load_native_extensions","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-load_native_extensions","()",""],["lock_and_clean_up_reverse_forwarders","Concurrent::Collection","Concurrent/Collection.html#method-i-lock_and_clean_up_reverse_forwarders","(old_table, old_table_size, new_table, i, forwarder)",""],["locked?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-locked-3F","()",""],["locked_hash?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-c-locked_hash-3F","(hash)",""],["log","Concurrent::Concern::Logging","Concurrent/Concern/Logging.html#method-i-log","(level, progname, message = nil, &block)","<p>Logs through {Concurrent.global_logger}, it can be overridden by setting\n@logger @param [Integer] level \n"],["make_false","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-make_false","()","<p>@!macro atomic_boolean_method_make_false\n"],["make_synchronized_on_rbx","Concurrent::ThreadSafe::Util","Concurrent/ThreadSafe/Util.html#method-c-make_synchronized_on_rbx","(klass)",""],["make_true","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-make_true","()","<p>@!macro atomic_boolean_method_make_true\n"],["marshal_dump","Concurrent::Map","Concurrent/Map.html#method-i-marshal_dump","()",""],["marshal_load","Concurrent::Map","Concurrent/Map.html#method-i-marshal_load","(hash)",""],["matches?","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-matches-3F","(key, hash)",""],["max_readers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-max_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_readers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-max_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_writers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-max_writers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["max_writers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-max_writers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["members","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-members","()","<p>@!macro [attach] struct_members\n\n<pre>Returns the struct members as an array of symbols.\n\n@return [Array] the ...</pre>\n"],["merge","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-merge","(other, &block)","<p>@!macro struct_merge\n"],["merge","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-merge","(other, &block)","<p>@!macro [attach] struct_merge\n\n<pre>Returns a new struct containing the contents of `other` and the contents ...</pre>\n"],["merge","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-merge","(other, &block)","<p>@!macro struct_merge\n"],["merge_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-merge_pair","(key, value)",""],["merge_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-merge_pair","(key, value)",""],["method_missing","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-i-method_missing","(method, *args, &block)","<p>Delegates method calls to the wrapped object.\n<p>@param [Symbol] method the method being called @param [Array] \n"],["method_missing","Concurrent::Async::AwaitDelegator","Concurrent/Async/AwaitDelegator.html#method-i-method_missing","(method, *args, &block)","<p>Delegates method calls to the wrapped object.\n<p>@param [Symbol] method the method being called @param [Array] \n"],["method_missing","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-method_missing","(method, *args, &block)",""],["min_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-min_length","()","<p>@!macro thread_pool_executor_attr_reader_min_length\n"],["modify","Concurrent::MVar","Concurrent/MVar.html#method-i-modify","(timeout = nil)","<p>Atomically `take`, yield the value to a block for transformation, and then\n`put` the transformed value. \n"],["modify!","Concurrent::MVar","Concurrent/MVar.html#method-i-modify-21","()","<p>Non-blocking version of `modify` that will yield with `EMPTY` if there is\nno value yet.\n"],["monotonic_time","Concurrent","Concurrent.html#method-i-monotonic_time","()","<p>@!macro [attach] monotonic_get_time\n\n<pre>Returns the current time a tracked by the application monotonic clock. ...</pre>\n"],["monotonic_time","Concurrent","Concurrent.html#method-c-monotonic_time","()","<p>@!macro [attach] monotonic_get_time\n\n<pre>Returns the current time a tracked by the application monotonic clock. ...</pre>\n"],["new","Concurrent","Concurrent.html#method-c-new","()",""],["new","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-c-new","()","<p>@!macro [attach] exchanger_method_initialize\n"],["new","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-c-new","(*args, &block)","<p>Create a new thread pool.\n"],["new","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-c-new","(default = nil)","<p>@!macro thread_local_var_method_initialize\n"],["new","Concurrent::Agent","Concurrent/Agent.html#method-c-new","(initial, opts = {})","<p>Create a new `Agent` with the given initial value and options.\n<p>The `:validator` option must be `nil` or \n"],["new","Concurrent::Agent::Error","Concurrent/Agent/Error.html#method-c-new","(message = nil)",""],["new","Concurrent::Agent::ValidationError","Concurrent/Agent/ValidationError.html#method-c-new","(message = nil)",""],["new","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-c-new","(delegate)","<p>Create a new delegator object wrapping the given delegate.\n<p>@param [Object] delegate the object to wrap \n"],["new","Concurrent::Async::AwaitDelegator","Concurrent/Async/AwaitDelegator.html#method-c-new","(delegate)","<p>Create a new delegator object wrapping the given delegate.\n<p>@param [AsyncDelegator] delegate the object \n"],["new","Concurrent::Async::ClassMethods","Concurrent/Async/ClassMethods.html#method-i-new","(*args, &block)",""],["new","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-c-new","(*args)",""],["new","Concurrent::Atom","Concurrent/Atom.html#method-c-new","(value, opts = {})","<p>Create a new atom with the given initial value.\n<p>@param [Object] value The initial value @param [Hash] \n"],["new","Concurrent::CachedThreadPool","Concurrent/CachedThreadPool.html#method-c-new","(opts = {})","<p>@!macro [attach] cached_thread_pool_method_initialize\n\n<pre>Create a new thread pool.\n\n@param [Hash] opts the ...</pre>\n"],["new","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-c-new","(options = nil)",""],["new","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-c-new","(hash, key, value, next_node = nil)",""],["new","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-c-new","()",""],["new","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-c-new","()",""],["new","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-c-new","(opts = {})","<p>@!macro priority_queue_method_initialize\n"],["new","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-c-new","(options = nil)",""],["new","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-c-new","(options = nil)","<p>WARNING: all public methods of the class must operate on the @backend\ndirectly without calling each other. \n"],["new","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-c-new","(opts = {})","<p>@!macro priority_queue_method_initialize\n"],["new","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-c-new","(parties, &block)","<p>Create a new `CyclicBarrier` that waits for `parties` threads\n<p>@param [Fixnum] parties the number of parties \n"],["new","Concurrent::Delay","Concurrent/Delay.html#method-c-new","(opts = {}, &block)","<p>Create a new `Delay` in the `:pending` state.\n<p>@!macro executor_and_deref_options\n<p>@yield the delayed operation \n"],["new","Concurrent::Event","Concurrent/Event.html#method-c-new","()","<p>Creates a new `Event` in the unset state. Threads calling `#wait` on the\n`Event` will block.\n"],["new","Concurrent::FixedThreadPool","Concurrent/FixedThreadPool.html#method-c-new","(num_threads, opts = {})","<p>@!macro [attach] fixed_thread_pool_method_initialize\n\n<pre>Create a new thread pool.\n\n@param [Integer] num_threads ...</pre>\n"],["new","Concurrent::Future","Concurrent/Future.html#method-c-new","(opts = {}, &block)","<p>Create a new `Future` in the `:unscheduled` state.\n<p>@yield the asynchronous operation to perform\n<p>@!macro \n"],["new","Concurrent::IVar","Concurrent/IVar.html#method-c-new","(value = NULL, opts = {}, &block)","<p>Create a new `IVar` in the `:pending` state with the (optional) initial\nvalue.\n<p>@param [Object] value the \n"],["new","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-c-new","()","<p>Creates a new executor\n"],["new","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::IndirectImmediateExecutor","Concurrent/IndirectImmediateExecutor.html#method-c-new","()","<p>Creates a new executor\n"],["new","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-c-new","(count = 1)","<p>@!macro count_down_latch_method_initialize\n"],["new","Concurrent::JavaExchanger","Concurrent/JavaExchanger.html#method-c-new","()","<p>@!macro exchanger_method_initialize\n"],["new","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-c-new","(*args, &block)",""],["new","Concurrent::JavaExecutorService::Job","Concurrent/JavaExecutorService/Job.html#method-c-new","(args, block)",""],["new","Concurrent::JavaSingleThreadExecutor","Concurrent/JavaSingleThreadExecutor.html#method-c-new","(opts = {})","<p>@!macro single_thread_executor_method_initialize\n"],["new","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-c-new","(opts = {})","<p>@!macro thread_pool_executor_method_initialize\n"],["new","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-c-new","()",""],["new","Concurrent::MVar","Concurrent/MVar.html#method-c-new","(value = EMPTY, opts = {})","<p>Create a new `MVar`, either empty or with an initial value.\n<p>@param [Hash] opts the options controlling \n"],["new","Concurrent::Map","Concurrent/Map.html#method-c-new","(options = nil, &block)","<p>@!method delete_pair\n\n<pre>@!macro map_method_is_atomic</pre>\n"],["new","Concurrent::Maybe","Concurrent/Maybe.html#method-c-new","(just, nothing)","<p>Create a new `Maybe` with the given attributes.\n<p>@param [Object] just The value when `Just` else `NONE`. \n"],["new","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-c-new","(initial = false)","<p>@!macro atomic_boolean_method_initialize\n"],["new","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-c-new","(initial = 0)","<p>@!macro atomic_fixnum_method_initialize\n"],["new","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-c-new","(value = nil)","<p>@!macro atomic_reference_method_initialize\n"],["new","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-c-new","(count = 1)","<p>@!macro count_down_latch_method_initialize\n"],["new","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-c-new","(count)","<p>@!macro semaphore_method_initialize\n"],["new","Concurrent::Promise","Concurrent/Promise.html#method-c-new","(opts = {}, &block)","<p>Initialize a new Promise with the provided options.\n<p>@!macro executor_and_deref_options\n<p>@!macro [attach] \n"],["new","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-c-new","()","<p>Create a new `ReadWriteLock` in the unlocked state.\n"],["new","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-c-new","()","<p>Create a new `ReentrantReadWriteLock` in the unlocked state.\n"],["new","Concurrent::RubyExchanger","Concurrent/RubyExchanger.html#method-c-new","()","<p>@!macro exchanger_method_initialize\n"],["new","Concurrent::RubyExchanger::Node","Concurrent/RubyExchanger/Node.html#method-c-new","(item)",""],["new","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-c-new","(*args, &block)",""],["new","Concurrent::RubySingleThreadExecutor","Concurrent/RubySingleThreadExecutor.html#method-c-new","(opts = {})","<p>@!macro single_thread_executor_method_initialize\n"],["new","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-c-new","(default = nil)","<p>@!macro [attach] thread_local_var_method_initialize\n\n<pre>Creates a thread local variable.\n\n@param [Object] ...</pre>\n"],["new","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-c-new","(opts = {})","<p>@!macro thread_pool_executor_method_initialize\n"],["new","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-c-new","(pool)",""],["new","Concurrent::SafeTaskExecutor","Concurrent/SafeTaskExecutor.html#method-c-new","(task, opts = {})",""],["new","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-c-new","(delay, opts = {}, &task)","<p>Schedule a task for execution at a specified future time.\n<p>@param [Float] delay the number of seconds to \n"],["new","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-c-new","()",""],["new","Concurrent::SerializedExecutionDelegator","Concurrent/SerializedExecutionDelegator.html#method-c-new","(executor)",""],["new","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-c-new","(*args, &block)","<p>@!macro struct_new\n"],["new","Concurrent::Synchronization::AbstractObject","Concurrent/Synchronization/AbstractObject.html#method-c-new","()","<p>@abstract has to be implemented based on Ruby runtime\n"],["new","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-c-new","(*values)","<p>@!visibility private\n"],["new","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-c-new","(lock)",""],["new","Concurrent::Synchronization::JRubyObject","Concurrent/Synchronization/JRubyObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::MriMonitorLockableObject","Concurrent/Synchronization/MriMonitorLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::MriMutexLockableObject","Concurrent/Synchronization/MriMutexLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::MriObject","Concurrent/Synchronization/MriObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-new","()","<p>Has to be called by children.\n"],["new","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-new","(*args, &block)",""],["new","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-c-new","(*defaults)",""],["new","Concurrent::Synchronization::RbxObject","Concurrent/Synchronization/RbxObject.html#method-c-new","()",""],["new","Concurrent::Synchronization::TruffleLockableObject","Concurrent/Synchronization/TruffleLockableObject.html#method-i-new","(*)",""],["new","Concurrent::Synchronization::TruffleObject","Concurrent/Synchronization/TruffleObject.html#method-c-new","()",""],["new","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-c-new","(obj)",""],["new","Concurrent::TVar","Concurrent/TVar.html#method-c-new","(value)","<p>Create a new `TVar` with an initial value.\n"],["new","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-c-new","(size)",""],["new","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-c-new","()",""],["new","Concurrent::TimerSet","Concurrent/TimerSet.html#method-c-new","(opts = {})","<p>Create a new set of timed tasks.\n<p>@!macro [attach] executor_options\n\n<pre>@param [Hash] opts the options used ...</pre>\n"],["new","Concurrent::TimerTask","Concurrent/TimerTask.html#method-c-new","(opts = {}, &task)","<p>Create a new TimerTask with the given task and configuration.\n<p>@!macro [attach] timer_task_initialize\n\n<pre>@param ...</pre>\n"],["new","Concurrent::Transaction","Concurrent/Transaction.html#method-c-new","()",""],["new","Concurrent::Tuple","Concurrent/Tuple.html#method-c-new","(size)","<p>Create a new tuple of the given size.\n<p>@param [Integer] size the number of elements in the tuple\n"],["new","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-c-new","()",""],["new_condition","Concurrent::Synchronization::LockableObject","Concurrent/Synchronization/LockableObject.html#method-i-new_condition","()",""],["new_fast_executor","Concurrent","Concurrent.html#method-c-new_fast_executor","(opts = {})",""],["new_io_executor","Concurrent","Concurrent.html#method-c-new_io_executor","(opts = {})",""],["next_in_size_table","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-next_in_size_table","()",""],["no_error!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-no_error-21","(timeout = nil)",""],["nothing","Concurrent::Maybe","Concurrent/Maybe.html#method-c-nothing","(error = '')","<p>Create a new `Nothing` with the given (optional) reason.\n<p>@param [Exception] error The reason to set for \n"],["nothing?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-nothing-3F","()","<p>Is this `Maybe` a `nothing` (rejected with an exception upon fulfillment)?\n<p>@return [Boolean] True if `Nothing` \n"],["notify_and_delete_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_and_delete_observers","(*args, &block)","<p>Notifies all registered observers with optional args and deletes them.\n<p>@param [Object] args arguments \n"],["notify_and_delete_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_and_delete_observers","(*args, &block)","<p>Notifies all registered observers with optional args and deletes them.\n<p>@param [Object] args arguments \n"],["notify_child","Concurrent::Promise","Concurrent/Promise.html#method-i-notify_child","(child)","<p>@!visibility private\n"],["notify_observers","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_observers","(*args, &block)","<p>Notifies all registered observers with optional args @param [Object] args\narguments to be passed to each \n"],["notify_observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_observers","(*args, &block)","<p>Notifies all registered observers with optional args @param [Object] args\narguments to be passed to each \n"],["notify_observers","Concurrent::IVar","Concurrent/IVar.html#method-i-notify_observers","(value, reason)","<p>@!visibility private\n"],["notify_to","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-notify_to","(observers, *args)",""],["notify_to","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-notify_to","(observers, *args)",""],["ns_add_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_add_busy_worker","()","<p>creates new worker which has to receive work to do after it&#39;s added\n@return [nil, Worker] nil of \n"],["ns_assign_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_assign_worker","(*args, &task)","<p>tries to assign task to a worker, tries to get one from @ready or to create\nnew one @return [true, false] \n"],["ns_auto_terminate=","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_auto_terminate-3D","(value)",""],["ns_auto_terminate?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_auto_terminate-3F","()",""],["ns_broadcast","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_broadcast","()","<p>@!macro [attach] synchronization_object_method_ns_broadcast\n\n<pre>Broadcast to all waiting threads.\n@return ...</pre>\n"],["ns_broadcast","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_broadcast","()",""],["ns_broadcast","Concurrent::Synchronization::MriLockableObject","Concurrent/Synchronization/MriLockableObject.html#method-i-ns_broadcast","()",""],["ns_broadcast","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_broadcast","()",""],["ns_check_state?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-ns_check_state-3F","(expected)","<p>Am I in the current state?\n<p>@param [Symbol] expected The state to check against @return [Boolean] true\n\n"],["ns_complete_without_notification","Concurrent::IVar","Concurrent/IVar.html#method-i-ns_complete_without_notification","(success, value, reason)","<p>@!visibility private\n"],["ns_each","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_each","()","<p>@!macro struct_each\n<p>@!visibility private\n"],["ns_each_pair","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_each_pair","()","<p>@!macro struct_each_pair\n<p>@!visibility private\n"],["ns_enqueue","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_enqueue","(*args, &task)","<p>tries to enqueue task @return [true, false] if enqueued\n<p>@!visibility private\n"],["ns_enqueue_job","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_enqueue_job","(job, index = nil)",""],["ns_equality","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_equality","(other)","<p>@!macro struct_equality\n<p>@!visibility private\n"],["ns_execute","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_execute","(*args, &task)",""],["ns_execute","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_execute","(*args, &task)","<p>@!visibility private\n"],["ns_find_last_job_for_thread","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_find_last_job_for_thread","()",""],["ns_generation_done","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_generation_done","(generation, status, continue = true)",""],["ns_get","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_get","(member)","<p>@!macro struct_get\n<p>@!visibility private\n"],["ns_initialize","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_initialize","(initial, opts)",""],["ns_initialize","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-ns_initialize","(enabled = true)",""],["ns_initialize","Concurrent::CachedThreadPool","Concurrent/CachedThreadPool.html#method-i-ns_initialize","(opts)","<p>@!macro cached_thread_pool_method_initialize @!visibility private\n"],["ns_initialize","Concurrent::Collection::CopyOnNotifyObserverSet","Concurrent/Collection/CopyOnNotifyObserverSet.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_initialize","(parties, &block)",""],["ns_initialize","Concurrent::Delay","Concurrent/Delay.html#method-i-ns_initialize","(opts, &block)",""],["ns_initialize","Concurrent::Event","Concurrent/Event.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Future","Concurrent/Future.html#method-i-ns_initialize","(value, opts)",""],["ns_initialize","Concurrent::IVar","Concurrent/IVar.html#method-i-ns_initialize","(value, opts)","<p>@!visibility private\n"],["ns_initialize","Concurrent::JavaSingleThreadExecutor","Concurrent/JavaSingleThreadExecutor.html#method-i-ns_initialize","(opts)",""],["ns_initialize","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-ns_initialize","(opts)",""],["ns_initialize","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-ns_initialize","(initial)","<p>@!visibility private\n"],["ns_initialize","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-ns_initialize","(initial)","<p>@!visibility private\n"],["ns_initialize","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-ns_initialize","(value)",""],["ns_initialize","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-ns_initialize","(count)",""],["ns_initialize","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-ns_initialize","(count)","<p>@!visibility private\n"],["ns_initialize","Concurrent::Promise","Concurrent/Promise.html#method-i-ns_initialize","(value, opts)",""],["ns_initialize","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_initialize","(opts)","<p>@!visibility private\n"],["ns_initialize","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-ns_initialize","()",""],["ns_initialize","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_initialize","(*values)",""],["ns_initialize","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_initialize","(opts)","<p>Initialize the object.\n<p>@param [Hash] opts the options to create the object with. @!visibility\nprivate \n"],["ns_initialize","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_initialize","(opts, &task)",""],["ns_inspect","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_inspect","()","<p>@!macro struct_inspect\n<p>@!visibility private\n"],["ns_kill_execution","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_kill_execution","()","<p>@!macro [attach] executor_service_method_ns_kill_execution\n\n<pre>Callback method called when the executor has ...</pre>\n"],["ns_kill_execution","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_kill_execution","()","<p>@!visibility private\n"],["ns_kill_execution","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_kill_execution","()","<p>@!visibility private\n"],["ns_limited_queue?","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_limited_queue-3F","()","<p>@!visibility private\n"],["ns_make_executor_runnable","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_make_executor_runnable","()",""],["ns_make_value","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-ns_make_value","(value)","<p>@!visibility private\n"],["ns_merge","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_merge","(other, &block)","<p>@!macro struct_merge\n<p>@!visibility private\n"],["ns_next_generation","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-ns_next_generation","()",""],["ns_post_next_job","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_post_next_job","()",""],["ns_post_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_post_task","(task)","<p>@!visibility private\n"],["ns_prune_pool","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_prune_pool","()","<p>try oldest worker if it is idle for enough time, it&#39;s returned back at\nthe start\n<p>@!visibility private \n"],["ns_ready_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_ready_worker","(worker, success = true)","<p>handle ready worker, giving it new job or assigning back to @ready\n<p>@!visibility private\n"],["ns_remove_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_remove_busy_worker","(worker)","<p>removes a worker which is not in not tracked in @ready\n<p>@!visibility private\n"],["ns_reschedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-ns_reschedule","(delay)","<p>Reschedule the task using the given delay and the current time. A task can\nonly be reset while it is \n"],["ns_reset_if_forked","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_reset_if_forked","()",""],["ns_running?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_running-3F","()",""],["ns_running?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_running-3F","()",""],["ns_schedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-ns_schedule","(delay)","<p>Schedule the task using the given delay and the current time.\n<p>@param [Float] delay the number of seconds \n"],["ns_select","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_select","()","<p>@!macro struct_select\n<p>@!visibility private\n"],["ns_set","Concurrent::Event","Concurrent/Event.html#method-i-ns_set","()",""],["ns_set","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-ns_set","(value)","<p>@!visibility private\n"],["ns_set_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-ns_set_deref_options","(opts)","<p>@!macro dereferenceable_set_deref_options @!visibility private\n"],["ns_set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-ns_set_state","(value)","<p>@!visibility private\n"],["ns_shutdown?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_shutdown-3F","()",""],["ns_shutdown?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shutdown-3F","()",""],["ns_shutdown_execution","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-ns_shutdown_execution","()","<p>@!macro [attach] executor_service_method_ns_shutdown_execution\n\n<pre>Callback method called when an orderly ...</pre>\n"],["ns_shutdown_execution","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shutdown_execution","()",""],["ns_shutdown_execution","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_shutdown_execution","()","<p>@!visibility private\n"],["ns_shutdown_execution","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-ns_shutdown_execution","()","<p>`ExecutorService` callback called during shutdown.\n<p>@!visibility private\n"],["ns_shutdown_execution","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-ns_shutdown_execution","()","<p>@!visibility private\n"],["ns_shuttingdown?","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-ns_shuttingdown-3F","()",""],["ns_shuttingdown?","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-ns_shuttingdown-3F","()",""],["ns_signal","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_signal","()","<p>@!macro [attach] synchronization_object_method_ns_signal\n\n<pre>Signal one waiting thread.\n@return [self]\n@note ...</pre>\n"],["ns_signal","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_signal","()",""],["ns_signal","Concurrent::Synchronization::MriLockableObject","Concurrent/Synchronization/MriLockableObject.html#method-i-ns_signal","()",""],["ns_signal","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_signal","()",""],["ns_to_h","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_to_h","()","<p>@!macro struct_to_h\n<p>@!visibility private\n"],["ns_validate","Concurrent::Agent","Concurrent/Agent.html#method-i-ns_validate","(value)",""],["ns_values","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_values","()","<p>@!macro struct_values\n<p>@!visibility private\n"],["ns_values_at","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-ns_values_at","(indexes)","<p>@!macro struct_values_at\n<p>@!visibility private\n"],["ns_wait","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_wait","(timeout = nil)","<p>@!macro [attach] synchronization_object_method_ns_wait\n\n<pre>Wait until another thread calls #signal or #broadcast, ...</pre>\n"],["ns_wait","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::MriMonitorLockableObject","Concurrent/Synchronization/MriMonitorLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::MriMutexLockableObject","Concurrent/Synchronization/MriMutexLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-ns_wait","(timeout = nil)",""],["ns_wait_until","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-ns_wait_until","(timeout = nil, &condition)","<p>@!macro [attach] synchronization_object_method_ns_wait_until\n\n<pre>Wait until condition is met or timeout passes, ...</pre>\n"],["ns_wait_until","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-ns_wait_until","(timeout = nil, &condition)",""],["ns_worker_died","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_worker_died","(worker)","<p>@!visibility private\n"],["ns_worker_not_old_enough","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ns_worker_not_old_enough","(worker)","<p>returns back worker to @ready which was not idle for enough time\n<p>@!visibility private\n"],["number_waiting","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-number_waiting","()","<p>@return [Fixnum] the number of threads currently waiting on the barrier\n"],["observers","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-observers","()",""],["observers=","Concurrent::Collection::CopyOnWriteObserverSet","Concurrent/Collection/CopyOnWriteObserverSet.html#method-i-observers-3D","(new_set)",""],["on_cruby?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_cruby-3F","()",""],["on_error","Concurrent::Promise","Concurrent/Promise.html#method-i-on_error","(&block)",""],["on_fulfill","Concurrent::Promise","Concurrent/Promise.html#method-i-on_fulfill","(result)","<p>@!visibility private\n"],["on_jruby?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_jruby-3F","()",""],["on_jruby_9000?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_jruby_9000-3F","()",""],["on_linux?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_linux-3F","()",""],["on_osx?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_osx-3F","()",""],["on_rbx?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_rbx-3F","()",""],["on_reject","Concurrent::Promise","Concurrent/Promise.html#method-i-on_reject","(reason)","<p>@!visibility private\n"],["on_success","Concurrent::Promise","Concurrent/Promise.html#method-i-on_success","(&block)","<p>Chain onto this promise an action to be undertaken on success\n(fulfillment).\n<p>@yield The block to execute \n"],["on_truffle?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_truffle-3F","()",""],["on_windows?","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-on_windows-3F","()",""],["or","Concurrent::Maybe","Concurrent/Maybe.html#method-i-or","(other)","<p>Return either the value of self or the given default value.\n<p>@return [Object] The value of self when `Just`; \n"],["ordered?","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-ordered-3F","(x, y)","<p>Are the items at the given indexes ordered based on the priority order\nspecified at construction?\n<p>@param \n"],["pair?","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-pair-3F","(key, expected_value)",""],["parties","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-parties","()","<p>@return [Fixnum] the number of threads needed to pass the barrier\n"],["peek","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-peek","()","<p>@!macro priority_queue_method_peek\n"],["peek","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-peek","()","<p>@!macro priority_queue_method_peek\n"],["pending?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-pending-3F","()","<p>Is obligation completion still pending?\n<p>@return [Boolean]\n"],["perform","Concurrent::Async::AsyncDelegator","Concurrent/Async/AsyncDelegator.html#method-i-perform","()","<p>Perform all enqueued tasks.\n<p>This method must be called from within the executor. It must not be called\n\n"],["physical_processor_count","Concurrent","Concurrent.html#method-c-physical_processor_count","()",""],["physical_processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-physical_processor_count","()","<p>Number of physical processor cores on the current system. For performance\nreasons the calculated value \n"],["pop","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-pop","()","<p>@!macro priority_queue_method_pop\n"],["pop","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-pop","()","<p>@!macro priority_queue_method_pop\n"],["populate_from","Concurrent::Map","Concurrent/Map.html#method-i-populate_from","(hash)",""],["post","Concurrent::Agent","Concurrent/Agent.html#method-i-post","(*args, &action)",""],["post","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::IndirectImmediateExecutor","Concurrent/IndirectImmediateExecutor.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-post","(*args, &task)",""],["post","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-post","(*args, &task)",""],["post","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-post","(executor, *args, &task)","<p>Submit a task to the executor for asynchronous processing.\n<p>@param [Executor] executor to be used for this \n"],["post","Concurrent::SerializedExecutionDelegator","Concurrent/SerializedExecutionDelegator.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-c-post","(*args)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-post","(*args, &task)","<p>@!macro executor_service_method_post\n"],["post","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-post","(delay, *args, &task)","<p>Post a task to be execute run after a given delay (in seconds). If the\ndelay is less than 1/100th of \n"],["post_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-post_task","(task)","<p>Post the task to the internal queue.\n<p>@note This is intended as a callback method from ScheduledTask\n\n<pre>only. ...</pre>\n"],["posts","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-posts","(posts)","<p>As {#post} but allows to submit multiple tasks at once, it&#39;s guaranteed\nthat they will not be interleaved \n"],["pr_underscore","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-pr_underscore","(clazz)","<p>@!visibility private\n"],["process_task","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-process_task","()","<p>Execute the task.\n<p>@!visibility private\n"],["process_tasks","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-process_tasks","()","<p>Run a loop and execute tasks in the scheduled order and at the approximate\nscheduled time. If no tasks \n"],["processing?","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-processing-3F","()","<p>In the task execution in progress?\n<p>@return [Boolean] true if the task is in the given state else false \n"],["processor_count","Concurrent","Concurrent.html#method-c-processor_count","()",""],["processor_count","Concurrent::Utility::ProcessorCounter","Concurrent/Utility/ProcessorCounter.html#method-i-processor_count","()","<p>Number of processors seen by the OS and used for process scheduling. For\nperformance reasons the calculated \n"],["pure_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-pure_hash","()",""],["push","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-push","(item)","<p>@!macro priority_queue_method_push\n"],["push","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-push","(item)","<p>@!macro priority_queue_method_push\n"],["put","Concurrent::MVar","Concurrent/MVar.html#method-i-put","(value, timeout = nil)","<p>Put a value into an `MVar`, blocking if there is already a value until it\nis empty. A timeout can be \n"],["put_if_absent","Concurrent::Map","Concurrent/Map.html#method-i-put_if_absent","(key, value)","<p>@!macro map_method_is_atomic\n"],["queue_length","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-queue_length","()","<p>@!macro thread_pool_executor_attr_reader_queue_length\n"],["queue_length","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-queue_length","()","<p>@!macro thread_pool_executor_attr_reader_queue_length\n"],["raise_fetch_no_key","Concurrent::Map","Concurrent/Map.html#method-i-raise_fetch_no_key","()",""],["range_check!","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-range_check-21","(value)","<p>@!visibility private\n"],["read","Concurrent::Transaction","Concurrent/Transaction.html#method-i-read","(tvar)",""],["ready_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-ready_worker","(worker)","<p>@!visibility private\n"],["realize","Concurrent::Promise","Concurrent/Promise.html#method-i-realize","(task)","<p>@!visibility private\n"],["realized?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-realized-3F","()",""],["reason","Concurrent::Agent","Concurrent/Agent.html#method-i-reason","()",""],["reason","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-reason","()","<p>If an exception was raised during processing this will return the exception\nobject. Will return `nil` \n"],["rebuild","Concurrent::Collection","Concurrent/Collection.html#method-i-rebuild","(table)","<p>Moves and/or copies the nodes in each bin to new table. See above for\nexplanation.\n"],["reconfigure","Concurrent::Delay","Concurrent/Delay.html#method-i-reconfigure","(&block)","<p>Reconfigures the block returning the value if still `#incomplete?`\n<p>@yield the delayed operation to perform \n"],["reduce_permits","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-reduce_permits","(reduction)","<p>Shrinks the number of available permits by the indicated reduction.\n<p>@param [Fixnum] reduction Number of \n"],["register","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-register","(key, &block)","<p>Element assignment. Associates the value given by value with the key given\nby key.\n<p>@param [Object] key \n"],["registered?","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-registered-3F","(key)","<p>Returns true if the given key is present.\n<p>@param [Object] key @return [true, false] if the key is registered \n"],["reject","Concurrent::Promise","Concurrent/Promise.html#method-c-reject","(reason, opts = {})","<p>Create a new `Promise` and reject it immediately.\n<p>@!macro executor_and_deref_options\n<p>@!macro promise_init_options \n"],["rejected?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-rejected-3F","()","<p>Has the obligation been rejected?\n<p>@return [Boolean]\n"],["rejected?","Concurrent::Maybe","Concurrent/Maybe.html#method-i-rejected-3F","()",""],["release","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-release","(permits = 1)","<p>@!macro semaphore_method_release\n"],["release_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-release_read_lock","()","<p>Release a previously acquired read lock.\n<p>@return [Boolean] true if the lock is successfully released\n"],["release_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-release_read_lock","()","<p>Release a previously acquired read lock.\n<p>@return [Boolean] true if the lock is successfully released\n"],["release_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-release_write_lock","()","<p>Release a previously acquired write lock.\n<p>@return [Boolean] true if the lock is successfully released \n"],["release_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-release_write_lock","()","<p>Release a previously acquired write lock.\n<p>@return [Boolean] true if the lock is successfully released \n"],["remaining_capacity","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-remaining_capacity","()","<p>@!macro thread_pool_executor_attr_reader_remaining_capacity\n"],["remaining_capacity","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-remaining_capacity","()","<p>@!macro thread_pool_executor_attr_reader_remaining_capacity\n"],["remove","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-remove","(key)",""],["remove_busy_worker","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-remove_busy_worker","(worker)","<p>@!visibility private\n"],["remove_task","Concurrent::TimerSet","Concurrent/TimerSet.html#method-i-remove_task","(task)","<p>Remove the given task from the queue.\n<p>@note This is intended as a callback method from `ScheduledTask` \n"],["replace_if_exists","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_if_exists","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-replace_if_exists","(key, new_value)",""],["replace_pair","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::MriMapBackend","Concurrent/Collection/MriMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["replace_pair","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-replace_pair","(key, old_value, new_value)",""],["reschedule","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-reschedule","(delay)","<p>Reschedule the task using the given delay and the current time. A task can\nonly be reset while it is \n"],["rescue","Concurrent::Promise","Concurrent/Promise.html#method-i-rescue","(&block)","<p>Chain onto this promise an action to be undertaken on failure (rejection).\n<p>@yield The block to execute \n"],["reset","Concurrent::Atom","Concurrent/Atom.html#method-i-reset","(new_value)","<p>Atomically sets the value of atom to the new value without regard for the\ncurrent value so long as the \n"],["reset","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-reset","()","<p>resets the barrier to its initial state If there is at least one waiting\nthread, it will be woken up, \n"],["reset","Concurrent::Event","Concurrent/Event.html#method-i-reset","()","<p>Reset a previously set event back to the `unset` state. Has no effect if\nthe `Event` has not yet been \n"],["reset","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-reset","()","<p>Reschedule the task using the original delay and the current time. A task\ncan only be reset while it \n"],["reset","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-reset","()",""],["restart","Concurrent::Agent","Concurrent/Agent.html#method-i-restart","(new_value, opts = {})","<p>When an Agent is {#failed?}, changes the Agent {#value} to `new_value` then\nun-fails the Agent so that \n"],["retry_update","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-retry_update","(x, hash_code, was_uncontended)","<p>Handles cases of updates involving initialization, resizing, creating new\nCells, and/or contention.  \n"],["ruby_engine","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-ruby_engine","()",""],["ruby_version","Concurrent::Utility::EngineDetector","Concurrent/Utility/EngineDetector.html#method-i-ruby_version","(comparison, major, minor = 0, patch = 0)",""],["run","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-run","()","<p>run the handlers manually @return ids of the handlers\n"],["run","Concurrent::JavaExecutorService::Job","Concurrent/JavaExecutorService/Job.html#method-i-run","()",""],["run_task","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-run_task","(pool, task, args)",""],["runner","Concurrent::AtExitImplementation","Concurrent/AtExitImplementation.html#method-i-runner","()",""],["running?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-running-3F","()","<p>@!macro executor_service_method_running_question\n"],["running?","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-running-3F","()","<p>Is the executor running?\n<p>@return [Boolean] `true` when running, `false` when shutting down or\nshutdown \n"],["running_readers","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_readers","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_readers","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_readers?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_readers-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_writer?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["running_writer?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["safe_execute","Concurrent::IVar","Concurrent/IVar.html#method-i-safe_execute","(task, args = [])","<p>@!visibility private\n"],["safe_initialization!","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-safe_initialization-21","()","<p>By calling this method on a class, it and all its children are marked to be\nconstructed safely. Meaning \n"],["safe_initialization?","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-safe_initialization-3F","()","<p>@return [true, false] if this class is safely initialized.\n"],["schedule_next_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-schedule_next_task","(interval = execution_interval)","<p>@!visibility private\n"],["schedule_time","Concurrent::ScheduledTask","Concurrent/ScheduledTask.html#method-i-schedule_time","()","<p>The monotonic time at which the the task is scheduled to be executed.\n<p>@return [Float] the schedule time \n"],["scheduled_task_count","Concurrent::JavaThreadPoolExecutor","Concurrent/JavaThreadPoolExecutor.html#method-i-scheduled_task_count","()","<p>@!macro thread_pool_executor_attr_reader_scheduled_task_count\n"],["scheduled_task_count","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-scheduled_task_count","()","<p>@!macro thread_pool_executor_attr_reader_scheduled_task_count\n"],["select","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-select","(&block)","<p>@!macro struct_select\n"],["select","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-select","(&block)","<p>@!macro [attach] struct_select\n\n<pre>Yields each member value from the struct to the block and returns an Array ...</pre>\n"],["select","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-select","(&block)","<p>@!macro struct_select\n"],["send","Concurrent::Agent","Concurrent/Agent.html#method-i-send","(*args, &action)","<p>@!macro [attach] agent_send\n\n<pre>Dispatches an action to the Agent and returns immediately. Subsequently,\nin ...</pre>\n"],["send!","Concurrent::Agent","Concurrent/Agent.html#method-i-send-21","(*args, &action)","<p>@!macro agent_send\n<p>@!macro [attach] send_bang_return_and_raise\n\n<pre>@return [Boolean] true if the action is ...</pre>\n"],["send_off","Concurrent::Agent","Concurrent/Agent.html#method-i-send_off","(*args, &action)","<p>@!macro agent_send @!macro send_return\n"],["send_off!","Concurrent::Agent","Concurrent/Agent.html#method-i-send_off-21","(*args, &action)","<p>@!macro agent_send @!macro send_bang_return_and_raise\n"],["send_via","Concurrent::Agent","Concurrent/Agent.html#method-i-send_via","(executor, *args, &action)","<p>@!macro agent_send @!macro send_return @param [Concurrent::ExecutorService]\nexecutor the executor on \n"],["send_via!","Concurrent::Agent","Concurrent/Agent.html#method-i-send_via-21","(executor, *args, &action)","<p>@!macro agent_send @!macro send_bang_return_and_raise @param\n[Concurrent::ExecutorService] executor the \n"],["serialized?","Concurrent::ExecutorService","Concurrent/ExecutorService.html#method-i-serialized-3F","()","<p>@!macro executor_service_method_serialized_question\n<p>@note Always returns `false`\n"],["serialized?","Concurrent::SerialExecutorService","Concurrent/SerialExecutorService.html#method-i-serialized-3F","()","<p>@!macro executor_service_method_serialized_question\n<p>@note Always returns `true`\n"],["set","Concurrent::Event","Concurrent/Event.html#method-i-set","()","<p>Trigger the event, setting the state to `set` and releasing all threads\nwaiting on the event. Has no \n"],["set","Concurrent::Future","Concurrent/Future.html#method-i-set","(value = NULL, &block)","<p>@!macro ivar_set_method\n"],["set","Concurrent::IVar","Concurrent/IVar.html#method-i-set","(value = NULL)","<p>@!macro [attach] ivar_set_method\n\n<pre>Set the `IVar` to a value and wake or notify all threads waiting on it. ...</pre>\n"],["set","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-set","(new_value)","<p>@!macro atomic_reference_method_set\n"],["set","Concurrent::Promise","Concurrent/Promise.html#method-i-set","(value = NULL, &block)","<p>@!macro ivar_set_method\n<p>@raise [Concurrent::PromiseExecutionError] if not the root promise\n"],["set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-set","(i, value)","<p>Set the element at the given index to the given value\n<p>@param [Integer] i the index for the element to \n"],["set!","Concurrent::MVar","Concurrent/MVar.html#method-i-set-21","(value)","<p>Non-blocking version of `put` that will overwrite an existing value.\n"],["set?","Concurrent::Event","Concurrent/Event.html#method-i-set-3F","()","<p>Is the object in the set state?\n<p>@return [Boolean] indicating whether or not the `Event` has been set\n"],["set_c_extensions_loaded","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-set_c_extensions_loaded","()",""],["set_deref_options","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-set_deref_options","(opts = {})","<p>@!macro [attach] dereferenceable_set_deref_options\n\n<pre>Set the options which define the operations #value ...</pre>\n"],["set_java_extensions_loaded","Concurrent::Utility::NativeExtensionLoader","Concurrent/Utility/NativeExtensionLoader.html#method-i-set_java_extensions_loaded","()",""],["set_pending","Concurrent::Promise","Concurrent/Promise.html#method-i-set_pending","()","<p>@!visibility private\n"],["set_state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-set_state","(success, value, reason)","<p>@!visibility private\n"],["set_state!","Concurrent::Promise","Concurrent/Promise.html#method-i-set_state-21","(success, value, reason)","<p>@!visibility private\n"],["set_threadlocal_array","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-set_threadlocal_array","(array, thread = Thread.current)",""],["setup","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-setup","()",""],["shift","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-shift","()",""],["shift","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-shift","()",""],["shutdown","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-shutdown","()",""],["shutdown","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-shutdown","()",""],["shutdown","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shutdown","()","<p>@!macro executor_service_method_shutdown\n"],["shutdown?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shutdown?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shutdown?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shutdown-3F","()","<p>@!macro executor_service_method_shutdown_question\n"],["shuttingdown?","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["shuttingdown?","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["shuttingdown?","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-shuttingdown-3F","()","<p>@!macro executor_service_method_shuttingdown_question\n"],["signal","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-signal","()",""],["signal","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-signal","()",""],["sink","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-sink","(k)","<p>Percolate down to maintain heap invariant.\n<p>@param [Integer] k the index at which to start the percolation \n"],["size","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-size","()",""],["size","Concurrent::Collection::JavaNonConcurrentPriorityQueue","Concurrent/Collection/JavaNonConcurrentPriorityQueue.html#method-i-size","()",""],["size","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-size","()",""],["size","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-size","()",""],["size","Concurrent::Collection::SynchronizedMapBackend","Concurrent/Collection/SynchronizedMapBackend.html#method-i-size","()",""],["size","Concurrent::Map","Concurrent/Map.html#method-i-size","()",""],["size","Concurrent::Synchronization::AbstractStruct","Concurrent/Synchronization/AbstractStruct.html#method-i-size","()",""],["split_bin","Concurrent::Collection","Concurrent/Collection.html#method-i-split_bin","(new_table, i, node, node_hash)",""],["split_old_bin","Concurrent::Collection","Concurrent/Collection.html#method-i-split_old_bin","(table, new_table, i, node, node_hash, forwarder)","<p>Splits a normal bin with list headed by e into lo and hi parts; installs in\ngiven table.\n"],["state","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-state","()","<p>The current state of the obligation.\n<p>@return [Symbol] the current state\n"],["state=","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-state-3D","(value)","<p>@!visibility private\n"],["stop","Concurrent::RubyThreadPoolExecutor::Worker","Concurrent/RubyThreadPoolExecutor/Worker.html#method-i-stop","()",""],["stop_event","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-stop_event","()",""],["stopped?","Concurrent::Agent","Concurrent/Agent.html#method-i-stopped-3F","()",""],["stopped_event","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-stopped_event","()",""],["store","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-store","(key, &block)",""],["store_computed_value","Concurrent::Collection::NonConcurrentMapBackend","Concurrent/Collection/NonConcurrentMapBackend.html#method-i-store_computed_value","(key, new_value)",""],["sum","Concurrent::ThreadSafe::Util::Adder","Concurrent/ThreadSafe/Util/Adder.html#method-i-sum","()","<p>Returns the current sum.  The returned value is <em>NOT</em> an atomic\nsnapshot: Invocation in the absence of \n"],["swap","Concurrent::Atom","Concurrent/Atom.html#method-i-swap","(*args)","<p>Atomically swaps the value of atom using the given block. The current value\nwill be passed to the block, \n"],["swap","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-swap","(x, y)","<p>Exchange the values at the given indexes within the internal array.\n<p>@param [Integer] x the first index \n"],["swap","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-swap","(new_value)",""],["swim","Concurrent::Collection::RubyNonConcurrentPriorityQueue","Concurrent/Collection/RubyNonConcurrentPriorityQueue.html#method-i-swim","(k)","<p>Percolate up to maintain heap invariant.\n<p>@param [Integer] k the index at which to start the percolation \n"],["synchronize","Concurrent::MVar","Concurrent/MVar.html#method-i-synchronize","(&block)",""],["synchronize","Concurrent::Synchronization::AbstractLockableObject","Concurrent/Synchronization/AbstractLockableObject.html#method-i-synchronize","()","<p>@!macro [attach] synchronization_object_method_synchronize\n\n<pre>@yield runs the block synchronized against ...</pre>\n"],["synchronize","Concurrent::Synchronization::MriMonitorLockableObject","Concurrent/Synchronization/MriMonitorLockableObject.html#method-i-synchronize","()",""],["synchronize","Concurrent::Synchronization::MriMutexLockableObject","Concurrent/Synchronization/MriMutexLockableObject.html#method-i-synchronize","()",""],["synchronize","Concurrent::Synchronization::RbxLockableObject","Concurrent/Synchronization/RbxLockableObject.html#method-i-synchronize","(&block)",""],["synchronized_set_state!","Concurrent::Promise","Concurrent/Promise.html#method-i-synchronized_set_state-21","(success, value, reason)","<p>@!visibility private\n"],["table_size_for","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-table_size_for","(entry_count)","<p>Returns a power of two table size for the given desired capacity.\n"],["take","Concurrent::MVar","Concurrent/MVar.html#method-i-take","(timeout = nil)","<p>Remove the value from an `MVar`, leaving it empty, and blocking if there\nisn&#39;t a value. A timeout \n"],["teardown","Concurrent::SynchronizedDelegator","Concurrent/SynchronizedDelegator.html#method-i-teardown","()",""],["terminate_at_exit","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-terminate_at_exit","()",""],["then","Concurrent::Promise","Concurrent/Promise.html#method-i-then","(rescuer = nil, &block)","<p>Chain a new promise off the current promise.\n<p>@param [Proc] rescuer An optional rescue block to be executed \n"],["thread_finalizer","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-c-thread_finalizer","(array)","<p>@!visibility private\n"],["threadlocal_finalizer","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-c-threadlocal_finalizer","(index)","<p>@!visibility private\n"],["timeout_interval","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_interval","()","<p>@!attribute [rw] timeout_interval @return [Fixnum] Number of seconds the\ntask can run before it is\n\n<pre>considered ...</pre>\n"],["timeout_interval=","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_interval-3D","(value)","<p>@!attribute [rw] timeout_interval @return [Fixnum] Number of seconds the\ntask can run before it is\n\n<pre>considered ...</pre>\n"],["timeout_task","Concurrent::TimerTask","Concurrent/TimerTask.html#method-i-timeout_task","(completion)","<p>@!visibility private\n"],["to_a","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_a","()",""],["to_a","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_a","()",""],["to_a","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_a","()",""],["to_h","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_h","()","<p>@!macro struct_to_h\n"],["to_h","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_h","()","<p>@!macro [attach] struct_to_h\n\n<pre>Returns a hash containing the names and values for the structs members. ...</pre>\n"],["to_h","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_h","()","<p>@!macro struct_to_h\n"],["to_s","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-to_s","()",""],["to_s","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-to_s","()",""],["to_s","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-to_s","()",""],["true?","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-true-3F","()","<p>@!macro atomic_boolean_method_true_question\n"],["try?","Concurrent::Event","Concurrent/Event.html#method-i-try-3F","()",""],["try_acquire","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire","(permits = 1, timeout = nil)","<p>@!macro semaphore_method_try_acquire\n"],["try_acquire_now","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire_now","(permits)","<p>@!visibility private\n"],["try_acquire_timed","Concurrent::MutexSemaphore","Concurrent/MutexSemaphore.html#method-i-try_acquire_timed","(permits, timeout)","<p>@!visibility private\n"],["try_await_lock","Concurrent::Collection::AtomicReferenceMapBackend","Concurrent/Collection/AtomicReferenceMapBackend.html#method-i-try_await_lock","(current_table, i, node)",""],["try_await_lock","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-try_await_lock","(table, i)","<p>Spins a while if <code>LOCKED</code> bit set and this node is the first of\nits bin, and then sets <code>WAITING</code> bits on \n"],["try_exchange","Concurrent::AbstractExchanger","Concurrent/AbstractExchanger.html#method-i-try_exchange","(value, timeout = nil)","<p>@!macro exchanger_method_do_exchange\n<p>@!macro [attach] exchanger_method_try_exchange\n\n<pre>The return value will ...</pre>\n"],["try_in_busy","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_in_busy","()",""],["try_in_resize_lock","Concurrent::Collection","Concurrent/Collection.html#method-i-try_in_resize_lock","(current_table, size_ctrl)",""],["try_initialize_cells","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_initialize_cells","(x, hash)",""],["try_lock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-try_lock_via_hash","(node_hash = hash)",""],["try_lock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-try_lock_via_hash","(i, node, node_hash)",""],["try_put!","Concurrent::MVar","Concurrent/MVar.html#method-i-try_put-21","(value)","<p>Non-blocking version of `put`, that returns whether or not it was\nsuccessful.\n"],["try_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-try_read_lock","()","<p>Try to acquire a read lock and return true if we succeed. If it cannot be\nacquired immediately, return \n"],["try_set","Concurrent::IVar","Concurrent/IVar.html#method-i-try_set","(value = NULL, &block)","<p>Attempt to set the `IVar` with the given value or block. Return a boolean\nindicating the success or failure \n"],["try_take!","Concurrent::MVar","Concurrent/MVar.html#method-i-try_take-21","()","<p>Non-blocking version of `take`, that returns `EMPTY` instead of blocking.\n"],["try_to_cas_in_computed","Concurrent::Collection::AtomicReferenceMapBackend::Table","Concurrent/Collection/AtomicReferenceMapBackend/Table.html#method-i-try_to_cas_in_computed","(i, hash, key)",""],["try_to_install_new_cell","Concurrent::ThreadSafe::Util::Striped64","Concurrent/ThreadSafe/Util/Striped64.html#method-i-try_to_install_new_cell","(new_cell, hash)",""],["try_update","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-try_update","()","<p>@!macro [attach] atomic_reference_method_try_update\n<p>Pass the current value to the given block, replacing \n"],["try_update!","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-try_update-21","()","<p>@!macro [attach] atomic_reference_method_try_update!\n<p>Pass the current value to the given block, replacing \n"],["try_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-try_write_lock","()","<p>Try to acquire a write lock and return true if we succeed. If it cannot be\nacquired immediately, return \n"],["unlock","Concurrent::Transaction","Concurrent/Transaction.html#method-i-unlock","()",""],["unlock_via_hash","Concurrent::Collection::AtomicReferenceMapBackend::Node","Concurrent/Collection/AtomicReferenceMapBackend/Node.html#method-i-unlock_via_hash","(locked_hash, node_hash)",""],["unlocked_empty?","Concurrent::MVar","Concurrent/MVar.html#method-i-unlocked_empty-3F","()",""],["unlocked_full?","Concurrent::MVar","Concurrent/MVar.html#method-i-unlocked_full-3F","()",""],["unregister","Concurrent::LazyRegister","Concurrent/LazyRegister.html#method-i-unregister","(key)","<p>Un-registers the object under key, realized or not.\n<p>@param [Object] key\n<p>@return [LazyRegister] self\n"],["unscheduled?","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-unscheduled-3F","()","<p>Is the obligation still unscheduled?\n<p>@return [Boolean]\n"],["up","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-up","(delta = 1)",""],["update","Concurrent::AtomicDirectUpdate","Concurrent/AtomicDirectUpdate.html#method-i-update","()","<p>@!macro [attach] atomic_reference_method_update\n<p>Pass the current value to the given block, replacing it \n"],["update","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-update","()","<p>@!macro atomic_fixnum_method_update\n"],["use_stdlib_logger","Concurrent","Concurrent.html#method-c-use_stdlib_logger","(level = Logger::FATAL, output = $stderr)","<p>Use logger created by #create_stdlib_logger to log concurrent-ruby\nmessages.\n"],["valid?","Concurrent::Atom","Concurrent/Atom.html#method-i-valid-3F","(new_value)","<p>Is the new value valid?\n<p>@param [Object] new_value The intended new value. @return [Boolean] false\nif the \n"],["valid?","Concurrent::Transaction","Concurrent/Transaction.html#method-i-valid-3F","()",""],["validate_argc","Concurrent::Async","Concurrent/Async.html#method-c-validate_argc","(obj, method, *args)","<p>Check for the presence of a method on an object and determine if a given\nset of arguments matches the \n"],["validate_options_hash!","Concurrent::Map","Concurrent/Map.html#method-i-validate_options_hash-21","(options)",""],["value","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::Agent","Concurrent/Agent.html#method-i-value","()","<p>The current value (state) of the Agent, irrespective of any pending or\nin-progress actions. The value \n"],["value","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-value","()","<p>Return the value this object represents after applying the options\nspecified by the `#set_deref_options` \n"],["value","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-value","(timeout = nil)","<p>The current value of the obligation. Will be `nil` while the state is\npending or the operation has been \n"],["value","Concurrent::Delay","Concurrent/Delay.html#method-i-value","(timeout = nil)","<p>Return the value this object represents after applying the options\nspecified by the `#set_deref_options` \n"],["value","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-value","()","<p>@!macro atomic_boolean_method_value_get\n"],["value","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-value","()","<p>@!macro atomic_fixnum_method_value_get\n"],["value","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-value","()",""],["value","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value","()","<p>@!macro thread_local_var_method_get\n"],["value","Concurrent::TVar","Concurrent/TVar.html#method-i-value","()","<p>Get the value of a `TVar`.\n"],["value!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-value-21","(timeout = nil)","<p>The current value of the obligation. Will be `nil` while the state is\npending or the operation has been \n"],["value!","Concurrent::Delay","Concurrent/Delay.html#method-i-value-21","(timeout = nil)","<p>Return the value this object represents after applying the options\nspecified by the `#set_deref_options` \n"],["value=","Concurrent::AbstractThreadLocalVar","Concurrent/AbstractThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::Concern::Dereferenceable","Concurrent/Concern/Dereferenceable.html#method-i-value-3D","(value)","<p>Set the internal value of this object\n<p>@param [Object] value the new value\n"],["value=","Concurrent::JavaThreadLocalVar","Concurrent/JavaThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::MutexAtomicBoolean","Concurrent/MutexAtomicBoolean.html#method-i-value-3D","(value)","<p>@!macro atomic_boolean_method_value_set\n"],["value=","Concurrent::MutexAtomicFixnum","Concurrent/MutexAtomicFixnum.html#method-i-value-3D","(value)","<p>@!macro atomic_fixnum_method_value_set\n"],["value=","Concurrent::MutexAtomicReference","Concurrent/MutexAtomicReference.html#method-i-value-3D","(new_value)",""],["value=","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value-3D","(value)","<p>@!macro thread_local_var_method_set\n"],["value=","Concurrent::TVar","Concurrent/TVar.html#method-i-value-3D","(value)","<p>Set the value of a `TVar`.\n"],["value?","Concurrent::Map","Concurrent/Map.html#method-i-value-3F","(value)",""],["value_for","Concurrent::RubyThreadLocalVar","Concurrent/RubyThreadLocalVar.html#method-i-value_for","(thread)","<p>This exists only for use in testing @!visibility private\n"],["values","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-values","()","<p>@!macro struct_values\n"],["values","Concurrent::Map","Concurrent/Map.html#method-i-values","()",""],["values","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-values","()","<p>@!macro [attach] struct_values\n\n<pre>Returns the values for this struct as an Array.\n\n@return [Array] the values ...</pre>\n"],["values","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-values","()","<p>@!macro struct_values\n"],["values_at","Concurrent::ImmutableStruct","Concurrent/ImmutableStruct.html#method-i-values_at","(*indexes)","<p>@!macro struct_values_at\n"],["values_at","Concurrent::MutableStruct","Concurrent/MutableStruct.html#method-i-values_at","(*indexes)","<p>@!macro [attach] struct_values_at\n\n<pre>Returns the struct member values for each selector as an Array.\n\nA selector ...</pre>\n"],["values_at","Concurrent::SettableStruct","Concurrent/SettableStruct.html#method-i-values_at","(*indexes)","<p>@!macro struct_values_at\n"],["volatile_cas_fields","Concurrent::Synchronization::Object","Concurrent/Synchronization/Object.html#method-c-volatile_cas_fields","(inherited = true)","<p>@param [true,false] inherited should inherited volatile with CAS fields be\nreturned? @return [Array&lt;Symbol&gt;] \n"],["volatile_get","Concurrent::Tuple","Concurrent/Tuple.html#method-i-volatile_get","(i)",""],["volatile_get_by_hash","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-volatile_get_by_hash","(hash)",""],["volatile_set","Concurrent::Tuple","Concurrent/Tuple.html#method-i-volatile_set","(i, value)",""],["volatile_set_by_hash","Concurrent::ThreadSafe::Util::PowerOfTwoTuple","Concurrent/ThreadSafe/Util/PowerOfTwoTuple.html#method-i-volatile_set_by_hash","(hash, value)",""],["wait","Concurrent::Agent","Concurrent/Agent.html#method-i-wait","(timeout = nil)","<p>Blocks the current thread until all actions dispatched thus far, from this\nthread or nested by the Agent \n"],["wait","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-wait","(timeout = nil)","<p>Wait until obligation is complete or the timeout has been reached.\n<p>@param [Numeric] timeout the maximum \n"],["wait","Concurrent::CyclicBarrier","Concurrent/CyclicBarrier.html#method-i-wait","(timeout = nil)","<p>Blocks on the barrier until the number of waiting threads is equal to\n`parties` or until `timeout` is \n"],["wait","Concurrent::Delay","Concurrent/Delay.html#method-i-wait","(timeout = nil)","<p>Return the value this object represents after applying the options\nspecified by the `#set_deref_options` \n"],["wait","Concurrent::Event","Concurrent/Event.html#method-i-wait","(timeout = nil)","<p>Wait a given number of seconds for the `Event` to be set by another thread.\nWill wait forever when no \n"],["wait","Concurrent::JavaCountDownLatch","Concurrent/JavaCountDownLatch.html#method-i-wait","(timeout = nil)","<p>@!macro count_down_latch_method_wait\n"],["wait","Concurrent::MutexCountDownLatch","Concurrent/MutexCountDownLatch.html#method-i-wait","(timeout = nil)","<p>@!macro count_down_latch_method_wait\n"],["wait","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-wait","(timeout = nil)",""],["wait","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-wait","(timeout = nil)","<p>TODO use JavaReentrantLock on JRuby\n"],["wait!","Concurrent::Concern::Obligation","Concurrent/Concern/Obligation.html#method-i-wait-21","(timeout = nil)","<p>Wait until obligation is complete or the timeout is reached. Will re-raise\nany exceptions raised during \n"],["wait_for_empty","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_for_empty","(timeout)",""],["wait_for_full","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_for_full","(timeout)",""],["wait_for_termination","Concurrent::AbstractExecutorService","Concurrent/AbstractExecutorService.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_for_termination","Concurrent::ImmediateExecutor","Concurrent/ImmediateExecutor.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_for_termination","Concurrent::JavaExecutorService","Concurrent/JavaExecutorService.html#method-i-wait_for_termination","(timeout = nil)",""],["wait_for_termination","Concurrent::RubyExecutorService","Concurrent/RubyExecutorService.html#method-i-wait_for_termination","(timeout = nil)",""],["wait_for_termination","Concurrent::SimpleExecutorService","Concurrent/SimpleExecutorService.html#method-i-wait_for_termination","(timeout = nil)","<p>@!macro executor_service_method_wait_for_termination\n"],["wait_or_cancel","Concurrent::Future","Concurrent/Future.html#method-i-wait_or_cancel","(timeout)","<p>Wait the given number of seconds for the operation to complete. On timeout\nattempt to cancel the operation. \n"],["wait_until","Concurrent::Synchronization::Condition","Concurrent/Synchronization/Condition.html#method-i-wait_until","(timeout = nil, &condition)",""],["wait_until","Concurrent::Synchronization::Lock","Concurrent/Synchronization/Lock.html#method-i-wait_until","(timeout = nil, &condition)",""],["wait_while","Concurrent::MVar","Concurrent/MVar.html#method-i-wait_while","(condition, timeout)",""],["waiting_or_running_writer?","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-waiting_or_running_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_writer?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-waiting_writer-3F","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_writers","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-waiting_writers","(c = @Counter.value)","<p>@!visibility private\n"],["waiting_writers","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-waiting_writers","(c = @Counter.value)","<p>@!visibility private\n"],["with_observer","Concurrent::Concern::Observable","Concurrent/Concern/Observable.html#method-i-with_observer","(observer = nil, func = :update, &block)","<p>As `#add_observer` but can be used for chaining.\n<p>@param [Object] observer the observer to add @param [Symbol] \n"],["with_read_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-with_read_lock","()","<p>Execute a block operation within a read lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_read_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-with_read_lock","()","<p>Execute a block operation within a read lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_write_lock","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-with_write_lock","()","<p>Execute a block operation within a write lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["with_write_lock","Concurrent::ReentrantReadWriteLock","Concurrent/ReentrantReadWriteLock.html#method-i-with_write_lock","()","<p>Execute a block operation within a write lock.\n<p>@yield the task to be performed within the lock.\n<p>@return \n"],["work","Concurrent::SerializedExecution","Concurrent/SerializedExecution.html#method-i-work","(job)","<p>ensures next job is executed if any is stashed\n"],["worker_died","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_died","(worker)","<p>@!visibility private\n"],["worker_not_old_enough","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_not_old_enough","(worker)","<p>@!visibility private\n"],["worker_task_completed","Concurrent::RubyThreadPoolExecutor","Concurrent/RubyThreadPoolExecutor.html#method-i-worker_task_completed","()","<p>@!visibility private\n"],["write","Concurrent::Transaction","Concurrent/Transaction.html#method-i-write","(tvar, value)",""],["write_locked?","Concurrent::ReadWriteLock","Concurrent/ReadWriteLock.html#method-i-write_locked-3F","()","<p>Queries if the write lock is held by any thread.\n<p>@return [Boolean] true if the write lock is held else \n"],["xorshift","Concurrent::ThreadSafe::Util::XorShiftRandom","Concurrent/ThreadSafe/Util/XorShiftRandom.html#method-i-xorshift","(x)","<p>using the y=y&gt;&gt;a; y=y&lt;&lt;b; y=y&gt;&gt;c; transform with the\n(a,b,c) tuple with \n"],["zip","Concurrent::Promise","Concurrent/Promise.html#method-c-zip","(*promises)","<p>Builds a promise that produces the result of promises in an Array and fails\nif any of them fails.\n<p>@param \n"],["zip","Concurrent::Promise","Concurrent/Promise.html#method-i-zip","(*others)","<p>Builds a promise that produces the result of self and others in an Array\nand fails if any of them fails. \n"],["CHANGELOG","","CHANGELOG_md.html","","<p>Current Release v1.0.2 (2 May 2016)\n<p>Fix bug with <code>Concurrent::Map</code> MRI backend <code>#inspect</code>\nmethod\n<p>Fix bug with \n"],["LICENSE","","LICENSE_txt.html","","<p>Copyright  Jerry D&#39;Antonio  released under the MIT license.\n<p>www.opensource.org/licenses/mit-license.php \n"],["README","","README_md.html","","<p>Concurrent Ruby\n<p>{Gem Version]\n{Build Status]\n{Build status]\n{Code Climate]\n{Inline\ndocs]\n{Dependency Status ...\n"]]}}